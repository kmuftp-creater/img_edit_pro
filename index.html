<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>✏️ ECF PDF/IMG Editor v3.0</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@100;200;300;400;500;600;700;800;900&display=swap" rel="stylesheet">
    <!-- 圓角字體 -->
    <link href="https://fonts.googleapis.com/css2?family=Kosugi+Maru&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;500;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Varela+Round&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Comfortaa:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- 中文圓角字體 (jf open 粉圓) -->
    <link href="https://cdn.jsdelivr.net/npm/jf-openhuninn-1.1@1.0.0/stylesheet.css" rel="stylesheet">
    <!-- Tesseract.js - 延遲載入 -->
    <!-- <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js"></script> -->
    <!-- PDF.js - 延遲載入 -->
    <!-- <script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.min.js"></script> -->
    <!-- 所有第三方庫都改為延遲載入以避免 Worker 問題 -->
    <!-- <script src="https://cdn.jsdelivr.net/npm/pptxgenjs@3.12.0/dist/pptxgen.bundle.js"></script> -->
    <!-- <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script> -->
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Noto Sans TC', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #0a0a0b;
            color: #fff;
            height: 100vh;
            overflow: hidden;
        }

        .app {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .header {
            padding: 8px 16px;
            background: #111;
            border-bottom: 1px solid #222;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-shrink: 0;
        }

        .logo {
            font-weight: 600;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .logo-icon {
            width: 28px;
            height: 28px;
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .logo-img {
            height: 36px;
            width: auto;
            object-fit: contain;
        }

        .header-btns { display: flex; gap: 8px; }

        .btn {
            padding: 7px 14px;
            font-size: 12px;
            font-weight: 500;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            font-family: inherit;
            transition: all 0.15s;
        }

        .btn-outline {
            background: transparent;
            color: #aaa;
            border: 1px solid #333;
        }

        .btn-outline:hover { background: #222; color: #fff; }

        .btn-primary {
            background: #6366f1;
            color: #fff;
        }

        .btn-primary:hover { background: #7c7ff2; }

        .btn-success {
            background: #22c55e;
            color: #fff;
        }

        .btn-danger {
            background: #ef4444;
            color: #fff;
        }

        .main {
            flex: 1;
            display: flex;
            overflow: hidden;
            transition: margin-left 0.3s ease;
        }
        
        .main.with-thumbnails {
            margin-left: 180px;
        }

        .canvas-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .toolbar {
            padding: 8px 12px;
            background: #111;
            border-bottom: 1px solid #222;
            display: flex;
            align-items: center;
            gap: 4px;
            flex-wrap: wrap;
            flex-shrink: 0;
        }

        .tool-btn {
            padding: 6px 10px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 5px;
            color: #aaa;
            font-size: 11px;
            cursor: pointer;
            font-family: inherit;
            transition: all 0.15s;
        }

        .tool-btn:hover { color: #fff; border-color: #6366f1; }
        .tool-btn.active { background: #6366f1; color: #fff; border-color: #6366f1; }

        /* 工具群組樣式 */
        .tool-group {
            position: relative;
            display: flex;
            align-items: stretch;
        }
        
        .tool-group .tool-btn {
            border-radius: 5px 0 0 5px;
            border-right: none;
        }
        
        .tool-group-toggle {
            padding: 6px 4px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 0 5px 5px 0;
            color: #666;
            font-size: 8px;
            cursor: pointer;
            transition: all 0.15s;
        }
        
        .tool-group-toggle:hover {
            color: #fff;
            border-color: #6366f1;
            background: #252525;
        }
        
        .tool-submenu {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            margin-top: 4px;
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 8px;
            padding: 6px;
            z-index: 1000;
            min-width: 120px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.5);
        }
        
        .tool-submenu.show {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        
        .tool-submenu button {
            padding: 8px 12px;
            background: transparent;
            border: none;
            border-radius: 4px;
            color: #ccc;
            font-size: 12px;
            cursor: pointer;
            text-align: left;
            transition: all 0.15s;
            white-space: nowrap;
        }
        
        .tool-submenu button:hover {
            background: #6366f1;
            color: #fff;
        }
        
        .tool-submenu button.active {
            background: #4f46e5;
            color: #fff;
        }

        .tool-divider {
            width: 1px;
            height: 20px;
            background: #333;
            margin: 0 4px;
        }

        .mode-tag {
            padding: 4px 10px;
            background: #f59e0b;
            color: #000;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
        }

        .zoom-info {
            margin-left: auto;
            font-size: 11px;
            color: #666;
        }

        .canvas-wrapper {
            flex: 1;
            overflow: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            background: #050505;
            position: relative;
        }

        .canvas-container {
            position: relative;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
            transform-origin: center center;
        }

        #main-canvas {
            display: block;
            cursor: default;
        }

        #main-canvas.crosshair { cursor: crosshair; }

        .select-rect {
            position: absolute;
            border: 2px dashed #6366f1;
            background: rgba(99, 102, 241, 0.15);
            pointer-events: none;
            display: none;
            z-index: 50;
        }

        /* 區域層 */
        #regions-layer {
            position: absolute;
            inset: 0;
            pointer-events: auto;
            z-index: 10;
        }

        /* 編輯區域標記 */
        .edit-region {
            position: absolute;
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.15s;
        }

        .edit-region:hover {
            border-color: #6366f1;
            background: rgba(99, 102, 241, 0.1);
        }

        .edit-region.active {
            border-color: #6366f1;
            background: rgba(99, 102, 241, 0.15);
        }
        
        .edit-region.edited {
            border-color: #22c55e;
            border-style: solid;
        }
        
        .edit-region.edited:hover {
            border-color: #22c55e;
            background: rgba(34, 197, 94, 0.1);
            box-shadow: 0 0 8px rgba(34, 197, 94, 0.3);
        }
        
        .edit-region.edited.active {
            border-color: #22c55e;
            background: rgba(34, 197, 94, 0.15);
        }
        
        /* 浮動文字區域 - 特殊樣式 */
        .edit-region.floating {
            border-color: #22c55e !important;
            border-width: 2px;
            border-style: dashed;
            background: transparent;
            animation: floatingPulse 1.5s ease-in-out infinite;
            overflow: visible;
        }
        
        .edit-region.floating:hover {
            border-color: #4ade80 !important;
            box-shadow: 0 0 15px rgba(34, 197, 94, 0.5);
        }
        
        .edit-region.floating.active {
            border-color: #4ade80 !important;
            border-style: solid;
            box-shadow: 0 0 20px rgba(34, 197, 94, 0.6);
        }
        
        @keyframes floatingPulse {
            0%, 100% { box-shadow: 0 0 5px rgba(34, 197, 94, 0.3); }
            50% { box-shadow: 0 0 15px rgba(34, 197, 94, 0.6); }
        }
        
        /* 魔術棒選取區域 - 虛線框 */
        .edit-region.magic-wand {
            border: 2px dashed #f59e0b;
            background: transparent;
        }
        
        .edit-region.magic-wand:hover {
            border-color: #f59e0b;
            background: rgba(245, 158, 11, 0.1);
        }
        
        .edit-region.magic-wand.active {
            border-color: #ef4444;
            background: transparent;
            animation: marching-ants 0.5s linear infinite;
        }
        
        @keyframes marching-ants {
            0% { border-color: #ef4444; }
            50% { border-color: #fbbf24; }
            100% { border-color: #ef4444; }
        }
        
        /* 放大鏡 */
        .magnifier {
            position: absolute;
            width: 150px;
            height: 150px;
            border: 2px solid #6366f1;
            border-radius: 50%;
            pointer-events: none;
            background-repeat: no-repeat;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            z-index: 100;
        }
        
        .magnifier.hidden { display: none; }
        
        /* 取色器游標 */
        .eyedropper-cursor {
            cursor: crosshair !important;
        }
        
        /* 魔術棒游標 */
        .magicwand-cursor {
            cursor: cell !important;
        }
        
        /* 畫筆游標 */
        .brush-cursor {
            cursor: crosshair !important;
        }
        
        /* 多選區塊樣式 */
        .edit-region.multi-selected {
            border-color: #f59e0b;
            border-width: 3px;
            background: rgba(245, 158, 11, 0.2);
        }
        
        /* 取色預覽 */
        .color-preview-float {
            position: fixed;
            padding: 8px 12px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 6px;
            font-size: 12px;
            pointer-events: none;
            z-index: 500;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .color-preview-float .swatch {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            border: 1px solid #555;
        }

        /* Panel */
        .panel {
            width: 320px;
            background: #111;
            border-left: 1px solid #222;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }

        .panel-header {
            padding: 12px;
            font-size: 13px;
            font-weight: 600;
            border-bottom: 1px solid #222;
            flex-shrink: 0;
        }

        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
        }

        .section {
            margin-bottom: 16px;
        }

        .section-title {
            font-size: 10px;
            font-weight: 600;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }

        .prop-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .prop-label {
            font-size: 12px;
            color: #888;
        }

        .prop-input {
            width: 100px;
            padding: 6px 8px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 4px;
            color: #fff;
            font-size: 12px;
            font-family: inherit;
        }

        .prop-input:focus { outline: none; border-color: #6366f1; }

        .prop-select {
            width: 120px;
            padding: 6px 8px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 4px;
            color: #fff;
            font-size: 12px;
            font-family: inherit;
        }

        .color-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .color-input {
            width: 36px;
            height: 36px;
            border: 2px solid #333;
            border-radius: 6px;
            cursor: pointer;
            padding: 0;
        }

        .color-hex {
            font-size: 11px;
            color: #666;
            font-family: monospace;
        }

        .info-box {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 6px;
            padding: 12px;
            font-size: 12px;
            color: #888;
            line-height: 1.6;
        }

        .edit-textarea {
            width: 100%;
            min-height: 80px;
            padding: 10px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 6px;
            color: #fff;
            font-size: 13px;
            font-family: 'Inter', 'Noto Sans TC', sans-serif;
            resize: vertical;
            line-height: 1.4;
        }

        .edit-textarea:focus {
            outline: none;
            border-color: #6366f1;
        }

        .preview-box {
            margin-top: 12px;
            padding: 16px;
            border-radius: 6px;
            min-height: 60px;
            display: flex;
            align-items: center;
        }

        .btn-group {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }

        .btn-group .btn {
            flex: 1;
        }

        /* Region list */
        .region-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
            max-height: 250px;
            overflow-y: auto;
        }

        .region-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.15s;
        }

        .region-item:hover { border-color: #6366f1; }
        .region-item.active { border-color: #6366f1; background: rgba(99, 102, 241, 0.1); }

        .region-item-text {
            flex: 1;
            font-size: 12px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .region-item-badge {
            font-size: 10px;
            padding: 2px 6px;
            background: #333;
            border-radius: 3px;
            color: #888;
        }

        .region-item-badge.edited {
            background: #22c55e;
            color: #fff;
        }

        /* Upload */
        .upload-modal {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .upload-modal.hidden { display: none; }

        .upload-box {
            width: 100%;
            max-width: 420px;
            background: #111;
            border: 1px solid #333;
            border-radius: 12px;
            padding: 28px;
            text-align: center;
        }

        .upload-icon {
            width: 56px;
            height: 56px;
            margin: 0 auto 16px;
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            border-radius: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
        }

        .upload-title { font-size: 18px; font-weight: 600; margin-bottom: 6px; }
        .upload-desc { font-size: 13px; color: #888; margin-bottom: 20px; }

        .dropzone {
            border: 2px dashed #333;
            border-radius: 10px;
            padding: 36px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .dropzone:hover, .dropzone.dragover {
            border-color: #6366f1;
            background: rgba(99, 102, 241, 0.05);
        }

        .dropzone-text { font-size: 14px; color: #888; }
        .dropzone-text span { color: #6366f1; font-weight: 500; }

        #file-input { display: none; }

        /* Loading */
        .loading {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }

        .loading.hidden { display: none; }

        .spinner {
            width: 36px;
            height: 36px;
            border: 3px solid #333;
            border-top-color: #6366f1;
            border-radius: 50%;
            animation: spin 0.6s linear infinite;
        }

        @keyframes spin { to { transform: rotate(360deg); } }

        .loading-text { margin-top: 12px; font-size: 13px; color: #888; }

        .loading-bar-wrap {
            width: 180px;
            height: 4px;
            background: #333;
            border-radius: 2px;
            margin-top: 12px;
            overflow: hidden;
        }

        .loading-bar {
            height: 100%;
            background: #6366f1;
            transition: width 0.2s;
        }

        /* Toast */
        .toasts {
            position: fixed;
            bottom: 16px;
            right: 16px;
            z-index: 300;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .toast {
            padding: 12px 16px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 6px;
            font-size: 13px;
            animation: slideIn 0.2s;
        }

        @keyframes slideIn { from { transform: translateX(100%); opacity: 0; } }

        .toast.success { border-left: 3px solid #22c55e; }
        .toast.error { border-left: 3px solid #ef4444; }
        .toast.warning { border-left: 3px solid #f59e0b; }
        .toast.info { border-left: 3px solid #3b82f6; }

        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #1a1a1a; }
        ::-webkit-scrollbar-thumb { background: #333; border-radius: 3px; }
        
        /* 歷史記錄面板 */
        .history-panel {
            position: fixed;
            top: 60px;
            right: 340px;
            width: 250px;
            max-height: 400px;
            background: #1e1e1e;
            border: 1px solid #333;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            z-index: 1000;
            display: none;
            overflow: hidden;
        }
        
        .history-panel.show {
            display: block;
            animation: fadeIn 0.2s;
        }
        
        @keyframes fadeIn { from { opacity: 0; transform: translateY(-10px); } }
        
        .history-panel-header {
            padding: 12px;
            background: #252525;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .history-panel-header h3 {
            margin: 0;
            font-size: 14px;
            color: #fff;
        }
        
        .history-panel-close {
            background: none;
            border: none;
            color: #888;
            cursor: pointer;
            font-size: 18px;
            padding: 0;
        }
        
        .history-panel-close:hover {
            color: #fff;
        }
        
        .history-list {
            max-height: 340px;
            overflow-y: auto;
            padding: 8px;
        }
        
        .history-item {
            padding: 8px 12px;
            margin: 2px 0;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            color: #aaa;
            transition: all 0.15s;
        }
        
        .history-item:hover {
            background: #333;
            color: #fff;
        }
        
        .history-item.current {
            background: #3b82f6;
            color: #fff;
        }
        
        .history-item.future {
            opacity: 0.5;
        }
        
        .history-item-icon {
            width: 20px;
            text-align: center;
        }
        
        .history-item-name {
            flex: 1;
        }
        
        .history-item-time {
            font-size: 10px;
            color: #666;
        }
        
        /* 拼接對話框 */
        .stitch-dialog {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
        }
        
        .stitch-dialog.show {
            display: flex;
        }
        
        .stitch-dialog-content {
            background: #1e1e1e;
            border-radius: 12px;
            width: 90%;
            max-width: 800px;
            max-height: 80vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .stitch-dialog-header {
            padding: 16px 20px;
            background: #252525;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .stitch-dialog-header h2 {
            margin: 0;
            font-size: 18px;
            color: #fff;
        }
        
        .stitch-dialog-body {
            padding: 20px;
            overflow-y: auto;
            flex: 1;
        }
        
        .stitch-dropzone {
            border: 2px dashed #444;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            color: #888;
            cursor: pointer;
            transition: all 0.2s;
            margin-bottom: 16px;
        }
        
        .stitch-dropzone:hover, .stitch-dropzone.dragover {
            border-color: #6366f1;
            background: rgba(99, 102, 241, 0.1);
            color: #fff;
        }
        
        .stitch-images-list {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-bottom: 16px;
            min-height: 100px;
        }
        
        .stitch-image-item {
            position: relative;
            width: 120px;
            height: 90px;
            border-radius: 6px;
            overflow: hidden;
            border: 2px solid #333;
            cursor: move;
        }
        
        .stitch-image-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .stitch-image-item .remove-btn {
            position: absolute;
            top: 4px;
            right: 4px;
            width: 20px;
            height: 20px;
            background: rgba(239, 68, 68, 0.9);
            border: none;
            border-radius: 50%;
            color: #fff;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .stitch-image-item .order-num {
            position: absolute;
            bottom: 4px;
            left: 4px;
            width: 20px;
            height: 20px;
            background: rgba(99, 102, 241, 0.9);
            border-radius: 50%;
            color: #fff;
            font-size: 11px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .stitch-options {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            margin-bottom: 16px;
        }
        
        .stitch-option {
            padding: 12px;
            background: #252525;
            border: 2px solid #333;
            border-radius: 8px;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
        }
        
        .stitch-option:hover {
            border-color: #6366f1;
        }
        
        .stitch-option.selected {
            border-color: #6366f1;
            background: rgba(99, 102, 241, 0.2);
        }
        
        .stitch-option-icon {
            font-size: 24px;
            margin-bottom: 4px;
        }
        
        .stitch-option-name {
            font-size: 12px;
            color: #ccc;
        }
        
        .stitch-preview {
            background: #111;
            border-radius: 8px;
            padding: 16px;
            text-align: center;
            min-height: 150px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .stitch-preview img {
            max-width: 100%;
            max-height: 300px;
            border-radius: 4px;
        }
        
        .stitch-dialog-footer {
            padding: 16px 20px;
            background: #252525;
            border-top: 1px solid #333;
            display: flex;
            justify-content: flex-end;
            gap: 12px;
        }
        
        /* PDF 頁面網格 */
        .pdf-pages-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 12px;
            max-height: 400px;
            overflow-y: auto;
            padding: 8px;
            background: #111;
            border-radius: 8px;
        }
        
        .pdf-page-item {
            position: relative;
            border: 3px solid #333;
            border-radius: 6px;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.2s;
            aspect-ratio: 3/4;
        }
        
        .pdf-page-item:hover {
            border-color: #6366f1;
        }
        
        .pdf-page-item.selected {
            border-color: #22c55e;
            box-shadow: 0 0 10px rgba(34, 197, 94, 0.5);
        }
        
        .pdf-page-item img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            background: #fff;
        }
        
        .pdf-page-item .page-num {
            position: absolute;
            bottom: 4px;
            right: 4px;
            background: rgba(0,0,0,0.7);
            color: #fff;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
        }
        
        .pdf-page-item .check-mark {
            position: absolute;
            top: 4px;
            right: 4px;
            width: 24px;
            height: 24px;
            background: #22c55e;
            border-radius: 50%;
            display: none;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 14px;
        }
        
        .pdf-page-item.selected .check-mark {
            display: flex;
        }
        
        /* PDF 頁面導航 */
        .pdf-nav {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            padding: 8px 16px;
            border-radius: 20px;
            display: none;
            align-items: center;
            gap: 12px;
            z-index: 100;
        }
        
        .pdf-nav.show {
            display: flex;
        }
        
        .pdf-nav button {
            background: #333;
            border: none;
            color: #fff;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .pdf-nav button:hover {
            background: #6366f1;
        }
        
        .pdf-nav button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .pdf-nav span {
            color: #ccc;
            font-size: 13px;
        }
        
        .pdf-nav-divider {
            color: #555;
            margin: 0 8px;
        }
        
        .pdf-page-jump {
            display: flex;
            align-items: center;
            gap: 6px;
            color: #ccc;
            font-size: 13px;
        }
        
        .pdf-page-jump input {
            width: 50px;
            padding: 4px 8px;
            background: #333;
            border: 1px solid #555;
            border-radius: 4px;
            color: #fff;
            text-align: center;
            font-size: 13px;
        }
        
        .pdf-page-jump input:focus {
            outline: none;
            border-color: #6366f1;
        }
        
        /* 浮水印預覽 */
        .watermark-preview-container {
            margin-top: 16px;
        }
        
        .watermark-preview-label {
            font-size: 12px;
            color: #888;
            margin-bottom: 8px;
        }
        
        .watermark-preview-wrap {
            position: relative;
            background: #222;
            border-radius: 8px;
            overflow: visible;
            display: inline-block;
            margin: 0 auto;
        }
        
        .watermark-preview-container {
            text-align: center;
        }
        
        #watermark-preview-canvas {
            display: block;
        }
        
        .watermark-overlay {
            position: absolute;
            border: 2px dashed #22c55e;
            cursor: move;
            box-sizing: border-box;
            background: rgba(34, 197, 94, 0.1);
            display: none;
        }
        
        .watermark-overlay:hover {
            border-color: #4ade80;
            background: rgba(34, 197, 94, 0.2);
        }
        
        .watermark-overlay.dragging {
            border-color: #86efac;
            background: rgba(34, 197, 94, 0.3);
        }
        
        /* 浮水印縮放控制點 */
        .watermark-resize-handle {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #22c55e;
            border: 2px solid #fff;
            border-radius: 2px;
            z-index: 10;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .watermark-resize-handle:hover {
            background: #4ade80;
            transform: scale(1.2);
        }
        
        .watermark-resize-handle.nw { top: -6px; left: -6px; cursor: nw-resize; }
        .watermark-resize-handle.ne { top: -6px; right: -6px; cursor: ne-resize; }
        .watermark-resize-handle.sw { bottom: -6px; left: -6px; cursor: sw-resize; }
        .watermark-resize-handle.se { bottom: -6px; right: -6px; cursor: se-resize; }
        
        /* 浮水印邊緣縮放控制點 */
        .watermark-edge-handle {
            position: absolute;
            background: #22c55e;
            border: 2px solid #fff;
            border-radius: 3px;
            z-index: 10;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .watermark-edge-handle:hover {
            background: #4ade80;
        }
        
        .watermark-edge-handle.n { top: -5px; left: 50%; transform: translateX(-50%); width: 30px; height: 10px; cursor: n-resize; }
        .watermark-edge-handle.s { bottom: -5px; left: 50%; transform: translateX(-50%); width: 30px; height: 10px; cursor: s-resize; }
        .watermark-edge-handle.e { right: -5px; top: 50%; transform: translateY(-50%); width: 10px; height: 30px; cursor: e-resize; }
        .watermark-edge-handle.w { left: -5px; top: 50%; transform: translateY(-50%); width: 10px; height: 30px; cursor: w-resize; }
        
        /* 浮水印尺寸顯示 */
        .watermark-size-display {
            position: absolute;
            bottom: -24px;
            left: 50%;
            transform: translateX(-50%);
            background: #22c55e;
            color: #000;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
            white-space: nowrap;
        }
        
        /* 旋轉控制點 */
        .watermark-rotate-handle {
            position: absolute;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            width: 20px;
            height: 20px;
            background: #22c55e;
            border: 2px solid #fff;
            border-radius: 50%;
            cursor: grab;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: #fff;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            z-index: 10;
        }
        
        .watermark-rotate-handle:hover {
            background: #4ade80;
            transform: translateX(-50%) scale(1.2);
        }
        
        .watermark-rotate-handle:active,
        .watermark-rotate-handle.rotating {
            cursor: grabbing;
            background: #86efac;
        }
        
        .watermark-rotate-line {
            position: absolute;
            top: -28px;
            left: 50%;
            width: 2px;
            height: 28px;
            background: #22c55e;
            transform: translateX(-50%);
        }
        
        .watermark-angle-display {
            position: absolute;
            top: -50px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            color: #22c55e;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 11px;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .watermark-overlay:hover .watermark-angle-display,
        .watermark-overlay.rotating .watermark-angle-display {
            opacity: 1;
        }
        
        /* 下載下拉選單 */
        .download-dropdown {
            position: relative;
            display: inline-block;
        }
        
        .download-menu {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            min-width: 200px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            z-index: 1000;
            overflow: hidden;
            margin-top: 4px;
        }
        
        .download-menu.show {
            display: block;
        }
        
        .download-menu button {
            display: block;
            width: 100%;
            padding: 10px 16px;
            background: none;
            border: none;
            color: #ddd;
            text-align: left;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.2s;
        }
        
        .download-menu button:hover {
            background: #333;
            color: #fff;
        }
        
        .download-menu-divider {
            height: 1px;
            background: #333;
            margin: 4px 0;
        }
        
        /* ============ 頁面縮圖側邊欄 ============ */
        .page-thumbnails-panel {
            position: fixed;
            left: 0;
            top: 60px;
            bottom: 0;
            width: 180px;
            background: #1a1a1a;
            border-right: 1px solid #333;
            z-index: 500;
            display: none;
            flex-direction: column;
            overflow: hidden;
        }
        
        .page-thumbnails-panel.show {
            display: flex;
        }
        
        .thumbnails-header {
            padding: 12px;
            background: #222;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .thumbnails-header h3 {
            font-size: 13px;
            font-weight: 500;
            color: #fff;
        }
        
        .thumbnails-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }
        
        .thumbnail-item {
            position: relative;
            margin-bottom: 12px;
            cursor: pointer;
            border: 2px solid transparent;
            border-radius: 6px;
            overflow: hidden;
            transition: all 0.2s;
            background: #222;
        }
        
        .thumbnail-item:hover {
            border-color: #555;
        }
        
        .thumbnail-item.active {
            border-color: #22c55e;
            box-shadow: 0 0 10px rgba(34, 197, 94, 0.3);
        }
        
        .thumbnail-item img {
            width: 100%;
            display: block;
        }
        
        .thumbnail-number {
            position: absolute;
            bottom: 4px;
            left: 4px;
            background: rgba(0,0,0,0.7);
            color: #fff;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
        }
        
        .thumbnail-actions {
            position: absolute;
            top: 4px;
            right: 4px;
            display: none;
            gap: 2px;
        }
        
        .thumbnail-item:hover .thumbnail-actions {
            display: flex;
        }
        
        .thumbnail-action-btn {
            width: 22px;
            height: 22px;
            border: none;
            background: rgba(0,0,0,0.7);
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .thumbnail-action-btn:hover {
            background: #22c55e;
        }
        
        .thumbnail-item.dragging {
            opacity: 0.5;
            border-color: #f59e0b;
        }
        
        .thumbnail-item.drag-over {
            border-color: #3b82f6;
            background: rgba(59, 130, 246, 0.2);
        }
        
        /* ============ 印章對話框 ============ */
        .stamp-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 12px;
            max-height: 300px;
            overflow-y: auto;
            padding: 10px;
            background: #1a1a1a;
            border-radius: 8px;
        }
        
        .stamp-item {
            aspect-ratio: 1;
            background: #222;
            border: 2px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            transition: all 0.2s;
        }
        
        .stamp-item:hover {
            border-color: #555;
            transform: scale(1.05);
        }
        
        .stamp-item.selected {
            border-color: #22c55e;
            background: rgba(34, 197, 94, 0.2);
        }
        
        .stamp-item img {
            max-width: 80%;
            max-height: 80%;
        }
        
        .stamp-preview {
            background: #1a1a1a;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            min-height: 150px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .stamp-preview-content {
            font-size: 80px;
        }
        
        .stamp-color-options {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .stamp-color-btn {
            width: 30px;
            height: 30px;
            border: 2px solid transparent;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .stamp-color-btn:hover, .stamp-color-btn.active {
            border-color: #fff;
            transform: scale(1.1);
        }
        
        /* ============ 頁面管理對話框 ============ */
        .page-manager-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 16px;
            max-height: 500px;
            overflow-y: auto;
            padding: 10px;
        }
        
        .page-manager-item {
            position: relative;
            background: #222;
            border: 2px solid #333;
            border-radius: 8px;
            overflow: hidden;
            cursor: move;
            transition: all 0.2s;
        }
        
        .page-manager-item:hover {
            border-color: #555;
        }
        
        .page-manager-item.selected {
            border-color: #22c55e;
        }
        
        .page-manager-item.dragging {
            opacity: 0.5;
            transform: scale(0.95);
        }
        
        .page-manager-item.drag-over {
            border-color: #3b82f6;
            background: rgba(59, 130, 246, 0.2);
        }
        
        .page-manager-img {
            width: 100%;
            aspect-ratio: 1/1.414;
            object-fit: contain;
            background: #111;
        }
        
        .page-manager-info {
            padding: 8px;
            background: #1a1a1a;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .page-manager-number {
            font-size: 12px;
            color: #888;
        }
        
        .page-manager-actions {
            display: flex;
            gap: 4px;
        }
        
        .page-manager-action {
            width: 24px;
            height: 24px;
            border: none;
            background: #333;
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .page-manager-action:hover {
            background: #22c55e;
        }
        
        .page-manager-action.danger:hover {
            background: #ef4444;
        }
        
        /* ============ 圖片優化對話框 ============ */
        .optimize-preview-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            margin-bottom: 16px;
        }
        
        .optimize-preview-box {
            background: #1a1a1a;
            border-radius: 8px;
            padding: 10px;
            text-align: center;
        }
        
        .optimize-preview-label {
            font-size: 12px;
            color: #888;
            margin-bottom: 8px;
        }
        
        .optimize-preview-canvas {
            max-width: 100%;
            max-height: 200px;
            border-radius: 4px;
        }
        
        .optimize-presets {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 16px;
        }
        
        .optimize-preset-btn {
            padding: 12px;
            background: #222;
            border: 2px solid #333;
            border-radius: 8px;
            color: #fff;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
        }
        
        .optimize-preset-btn:hover {
            border-color: #555;
        }
        
        .optimize-preset-btn.active {
            border-color: #22c55e;
            background: rgba(34, 197, 94, 0.2);
        }
        
        .optimize-preset-icon {
            font-size: 24px;
            margin-bottom: 6px;
        }
        
        .optimize-preset-name {
            font-size: 12px;
            color: #ddd;
        }
        
        /* ============ 頁首頁尾對話框 ============ */
        .header-footer-preview {
            background: #fff;
            border-radius: 8px;
            padding: 20px;
            min-height: 300px;
            position: relative;
            color: #000;
        }
        
        .hf-preview-header {
            position: absolute;
            top: 10px;
            left: 20px;
            right: 20px;
            text-align: center;
            border-bottom: 1px dashed #ccc;
            padding-bottom: 8px;
        }
        
        .hf-preview-footer {
            position: absolute;
            bottom: 10px;
            left: 20px;
            right: 20px;
            text-align: center;
            border-top: 1px dashed #ccc;
            padding-top: 8px;
        }
        
        .hf-preview-content {
            position: absolute;
            top: 50px;
            bottom: 50px;
            left: 20px;
            right: 20px;
            background: repeating-linear-gradient(
                #f5f5f5,
                #f5f5f5 10px,
                #fff 10px,
                #fff 20px
            );
            border-radius: 4px;
        }
        
        .hf-input-row {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .hf-input-row label {
            width: 80px;
            font-size: 13px;
            color: #aaa;
        }
        
        .hf-variables {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            margin-top: 8px;
        }
        
        .hf-variable-btn {
            padding: 4px 10px;
            background: #333;
            border: 1px solid #444;
            border-radius: 4px;
            color: #ddd;
            font-size: 11px;
            cursor: pointer;
        }
        
        .hf-variable-btn:hover {
            background: #444;
            border-color: #22c55e;
        }
        
        /* ============ PDF 加密設定 ============ */
        .pdf-encrypt-options {
            background: #1a1a1a;
            border-radius: 8px;
            padding: 16px;
        }
        
        .encrypt-option-row {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
        }
        
        .encrypt-option-row label {
            width: 120px;
            font-size: 13px;
            color: #aaa;
        }
        
        .encrypt-permissions {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 12px;
        }
        
        .encrypt-permission-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            background: #222;
            border-radius: 6px;
            cursor: pointer;
        }
        
        .encrypt-permission-item:hover {
            background: #2a2a2a;
        }
        
        /* ============ 濾鏡對話框 ============ */
        .filter-preview-container {
            background: #222;
            border-radius: 8px;
            padding: 12px;
            text-align: center;
            margin-bottom: 16px;
        }
        
        #filter-preview-canvas {
            max-width: 100%;
            max-height: 250px;
            border-radius: 4px;
        }
        
        .filter-controls {
            display: grid;
            gap: 12px;
            margin-bottom: 16px;
        }
        
        .filter-row {
            display: grid;
            grid-template-columns: 80px 1fr 50px;
            align-items: center;
            gap: 12px;
        }
        
        .filter-row label {
            font-size: 13px;
            color: #ccc;
        }
        
        .filter-row input[type="range"] {
            width: 100%;
        }
        
        .filter-row span {
            font-size: 12px;
            color: #888;
            text-align: right;
        }
        
        .filter-presets {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        /* 裁切工具 */
        .crop-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 200;
            pointer-events: none;
        }
        
        .crop-overlay.hidden {
            display: none;
        }
        
        .crop-mask {
            position: absolute;
            pointer-events: auto;
        }
        
        .crop-box {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: 2px dashed #fff;
            background: transparent;
            cursor: move;
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.6);
        }
        
        .crop-handle {
            position: absolute;
            width: 14px;
            height: 14px;
            background: #fff;
            border: 2px solid #6366f1;
            border-radius: 2px;
            z-index: 10;
        }
        
        .crop-handle.nw { top: -7px; left: -7px; cursor: nw-resize; }
        .crop-handle.ne { top: -7px; right: -7px; cursor: ne-resize; }
        .crop-handle.sw { bottom: -7px; left: -7px; cursor: sw-resize; }
        .crop-handle.se { bottom: -7px; right: -7px; cursor: se-resize; }
        .crop-handle.n { top: -7px; left: 50%; transform: translateX(-50%); cursor: n-resize; }
        .crop-handle.s { bottom: -7px; left: 50%; transform: translateX(-50%); cursor: s-resize; }
        .crop-handle.e { top: 50%; right: -7px; transform: translateY(-50%); cursor: e-resize; }
        .crop-handle.w { top: 50%; left: -7px; transform: translateY(-50%); cursor: w-resize; }
        
        .crop-toolbar {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            background: rgba(0,0,0,0.9);
            padding: 12px 16px;
            border-radius: 8px;
            z-index: 1000;
        }
        
        .crop-toolbar.hidden {
            display: none;
        }
        
        .crop-toolbar select {
            padding: 8px 12px;
            background: #333;
            border: 1px solid #555;
            border-radius: 6px;
            color: #fff;
            font-size: 13px;
        }
        
        /* 輔助線 */
        .guides-container {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 50;
            overflow: visible;
        }
        
        .guides-container.hidden {
            display: none;
        }
        
        .guide-line {
            position: absolute;
            display: none;
        }
        
        .guide-line.guide-h {
            height: 2px;
            left: 0;
            background: #22c55e;
        }
        
        .guide-line.guide-v {
            width: 2px;
            top: 0;
            background: #22c55e;
        }
        
        .guide-line.active {
            display: block;
        }
        
        .guide-line.snap {
            background: #22c55e !important;
            box-shadow: 0 0 6px #22c55e;
        }
        
        .guide-line.center-line {
            background: rgba(99, 102, 241, 0.4);
        }
        
        /* 滑鼠跟隨十字線 - 更明顯的顏色 */
        .guide-crosshair {
            position: absolute;
            pointer-events: none;
            z-index: 60;
        }
        
        .guide-crosshair-h {
            height: 0;
            border-top: 2px dashed #ff6b6b;
            left: 0;
        }
        
        .guide-crosshair-v {
            width: 0;
            border-left: 2px dashed #ff6b6b;
            top: 0;
        }
        
        /* 固定的輔助線 */
        .guide-fixed {
            position: absolute;
            pointer-events: none;
        }
        
        .guide-fixed.guide-h {
            height: 0;
            border-top: 2px solid #3b82f6;
            left: 0;
        }
        
        .guide-fixed.guide-v {
            width: 0;
            border-left: 2px solid #3b82f6;
            top: 0;
        }
        
        .guide-coord {
            position: absolute;
            background: rgba(255, 107, 107, 0.95);
            color: #fff;
            font-size: 11px;
            padding: 3px 8px;
            border-radius: 4px;
            white-space: nowrap;
            font-weight: 500;
            z-index: 70;
        }
        
        .guide-fixed-count {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(59, 130, 246, 0.9);
            color: #fff;
            font-size: 11px;
            padding: 4px 10px;
            border-radius: 4px;
            z-index: 70;
        }
        
        /* 前後對照比較 */
        .compare-dialog {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 2000;
            display: none;
            flex-direction: column;
        }
        
        .compare-dialog.show {
            display: flex;
        }
        
        .compare-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 24px;
            background: #1a1a1a;
            border-bottom: 1px solid #333;
        }
        
        .compare-header h2 {
            margin: 0;
            font-size: 18px;
            color: #fff;
        }
        
        .compare-body {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            overflow: hidden;
        }
        
        .compare-container {
            position: relative;
            max-width: 90%;
            max-height: 80vh;
            overflow: hidden;
        }
        
        .compare-wrapper {
            position: relative;
            display: inline-block;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
            cursor: ew-resize;
            border-radius: 8px;
            overflow: hidden;
        }
        
        .compare-wrapper.sidebyside {
            display: flex;
            gap: 20px;
            box-shadow: none;
        }
        
        .compare-wrapper.sidebyside .compare-image {
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
            border-radius: 8px;
        }
        
        .compare-image {
            display: block;
            max-width: 100%;
            max-height: 75vh;
            object-fit: contain;
            transition: opacity 0.3s ease;
        }
        
        .compare-image-after {
            display: block;
        }
        
        .compare-image-before {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
            clip-path: inset(0 50% 0 0);
        }
        
        .compare-wrapper.sidebyside .compare-image-before {
            position: relative;
            clip-path: none;
            max-width: 45vw;
        }
        
        .compare-wrapper.sidebyside .compare-image-after {
            max-width: 45vw;
        }
        
        .compare-slider {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 4px;
            background: #fff;
            left: 50%;
            transform: translateX(-50%);
            cursor: ew-resize;
            z-index: 10;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        
        .compare-slider::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 44px;
            height: 44px;
            background: #fff;
            border-radius: 50%;
            box-shadow: 0 2px 10px rgba(0,0,0,0.4);
        }
        
        .compare-slider::after {
            content: '◀ ▶';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 14px;
            color: #333;
            white-space: nowrap;
            letter-spacing: 4px;
            font-weight: bold;
        }
        
        .compare-labels {
            position: absolute;
            top: 15px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            pointer-events: none;
            z-index: 15;
        }
        
        .compare-label {
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: 500;
        }
        
        .compare-label.before {
            background: rgba(239, 68, 68, 0.8);
        }
        
        .compare-label.after {
            background: rgba(34, 197, 94, 0.8);
        }
        
        .compare-footer {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            padding: 16px 24px;
            background: #1a1a1a;
            border-top: 1px solid #333;
        }
        
        .compare-mode-btns {
            display: flex;
            gap: 8px;
        }
        
        .compare-mode-btn {
            padding: 8px 16px;
            background: #333;
            border: 1px solid #555;
            border-radius: 6px;
            color: #fff;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .compare-mode-btn:hover {
            background: #444;
        }
        
        .compare-mode-btn.active {
            background: #6366f1;
            border-color: #6366f1;
        }
        
        .compare-info {
            color: #888;
            font-size: 12px;
        }
        
        /* 標記符號選項 */
        .marker-options {
            display: flex;
            gap: 8px;
            padding: 8px;
            background: #1a1a1a;
            border-radius: 6px;
            margin-top: 8px;
        }
        
        .marker-btn {
            width: 36px;
            height: 36px;
            border: 2px solid #444;
            border-radius: 6px;
            background: #2a2a2a;
            color: #fff;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        
        .marker-btn:hover {
            border-color: #6366f1;
            background: #333;
        }
        
        .marker-btn.active {
            border-color: #6366f1;
            background: #4338ca;
        }
        
        /* 箭頭樣式選項 */
        .arrow-options {
            display: flex;
            gap: 8px;
            align-items: center;
            padding: 8px;
            background: #1a1a1a;
            border-radius: 6px;
            margin-top: 8px;
        }
        
        /* 圖層面板 */
        .layer-panel {
            position: fixed;
            right: 300px;
            top: 60px;
            width: 340px;
            max-height: 550px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            z-index: 1000;
            display: none;
            flex-direction: column;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }
        .layer-panel.show { display: flex; }
        .layer-panel-header {
            padding: 12px;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
        }
        .layer-panel-body {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
            max-height: 350px;
        }
        .layer-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            background: #222;
            border-radius: 6px;
            margin-bottom: 6px;
            cursor: pointer;
            border: 2px solid transparent;
        }
        .layer-item:hover { background: #2a2a2a; }
        .layer-item.active { border-color: #6366f1; background: #252538; }
        .layer-item-preview {
            width: 50px;
            height: 50px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
            flex-shrink: 0;
        }
        .layer-item-preview img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        .layer-item-info { flex: 1; min-width: 0; }
        .layer-item-name {
            font-size: 12px;
            font-weight: 500;
            margin-bottom: 2px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .layer-item-size {
            font-size: 10px;
            color: #888;
        }
        .layer-item-actions {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 2px;
            width: 78px;
        }
        .layer-item-actions button {
            width: 24px;
            height: 24px;
            border: none;
            background: #333;
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            padding: 0;
        }
        .layer-item-actions button:hover { background: #444; }
        .layer-panel-footer {
            padding: 10px 12px;
            border-top: 1px solid #333;
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }
        .layer-panel-footer button {
            padding: 5px 8px;
            font-size: 11px;
        }
        
        /* 顏色替換對話框 */
        .color-replace-dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 12px;
            padding: 20px;
            z-index: 2000;
            display: none;
            width: 350px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }
        .color-replace-dialog.show { display: block; }
        .color-replace-dialog h3 {
            margin-bottom: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .color-replace-row {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 16px;
        }
        .color-replace-row label {
            width: 80px;
            font-size: 13px;
        }
        .color-replace-row input[type="color"] {
            width: 50px;
            height: 35px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
        }
        .color-replace-row input[type="range"] {
            flex: 1;
        }
        .color-replace-preview {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
        }
        .color-replace-preview div {
            flex: 1;
            height: 40px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }
        
        /* 去背進度 */
        .remove-bg-progress {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            padding: 30px 50px;
            border-radius: 12px;
            z-index: 3000;
            text-align: center;
            display: none;
        }
        .remove-bg-progress.show { display: block; }
        
        /* 克隆圖章游標 */
        .clone-cursor {
            cursor: crosshair;
        }
        .clone-source-marker {
            position: fixed;
            border: 3px dashed #ff4444;
            border-radius: 50%;
            pointer-events: none;
            z-index: 9999;
            box-shadow: 0 0 0 2px rgba(255,255,255,0.5), 0 0 10px rgba(255,0,0,0.5);
        }
        
        /* 文字工具游標 */
        .text-cursor {
            cursor: text;
        }
        
        /* 填充工具游標 */
        .fill-cursor {
            cursor: cell;
        }
        
        /* 橡皮擦游標 */
        .eraser-cursor {
            cursor: crosshair;
        }
        
        /* ============ 語音泡泡樣式 ============ */
        .bubble-type-selector {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 16px;
        }
        
        .bubble-type-btn {
            width: 80px;
            height: 60px;
            background: #2a2a2a;
            border: 2px solid #444;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 4px;
            transition: all 0.2s;
            color: #fff;
        }
        
        .bubble-type-btn:hover { border-color: #6366f1; background: #333; }
        .bubble-type-btn.active { border-color: #6366f1; background: #4338ca; }
        .bubble-type-btn span { font-size: 24px; }
        .bubble-type-btn small { font-size: 10px; color: #aaa; }
        
        .bubble-preview-box {
            width: 100%;
            height: 150px;
            background: #1a1a1a;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* 語音泡泡物件樣式 */
        .speech-bubble-obj {
            transition: box-shadow 0.2s;
        }
        
        .speech-bubble-obj:hover {
            box-shadow: 0 6px 30px rgba(99, 102, 241, 0.4) !important;
        }
        
        /* ============ 長圖拼接樣式 ============ */
        .long-stitch-preview {
            max-height: 350px;
            overflow-y: auto;
            background: #1a1a1a;
            border-radius: 8px;
            padding: 10px;
        }
        
        .long-stitch-item {
            position: relative;
            margin-bottom: 8px;
            border: 2px solid #333;
            border-radius: 6px;
            overflow: hidden;
            cursor: move;
        }
        
        .long-stitch-item:hover { border-color: #6366f1; }
        .long-stitch-item.dragging { opacity: 0.5; border-color: #22c55e; }
        .long-stitch-item img { width: 100%; display: block; }
        
        .long-stitch-item-controls {
            position: absolute;
            top: 5px;
            right: 5px;
            display: flex;
            gap: 4px;
        }
        
        .long-stitch-item-btn {
            width: 26px;
            height: 26px;
            background: rgba(0,0,0,0.7);
            border: none;
            border-radius: 4px;
            color: #fff;
            cursor: pointer;
            font-size: 12px;
        }
        
        .long-stitch-item-btn:hover { background: #ef4444; }
        
        .long-stitch-dropzone {
            border: 2px dashed #444;
            border-radius: 8px;
            padding: 25px;
            text-align: center;
            color: #888;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .long-stitch-dropzone:hover,
        .long-stitch-dropzone.dragover {
            border-color: #6366f1;
            background: rgba(99, 102, 241, 0.1);
        }
        
        /* ============ 透視校正樣式 ============ */
        .perspective-wrapper {
            position: relative;
            display: inline-block;
        }
        
        .perspective-point {
            position: absolute;
            width: 18px;
            height: 18px;
            background: #6366f1;
            border: 3px solid #fff;
            border-radius: 50%;
            cursor: move;
            transform: translate(-50%, -50%);
            z-index: 100;
            box-shadow: 0 2px 8px rgba(0,0,0,0.5);
        }
        
        .perspective-point:hover {
            background: #22c55e;
            transform: translate(-50%, -50%) scale(1.2);
        }
    </style>
</head>
<body>
    <div class="app">
        <header class="header">
            <div class="logo">
                <span class="logo-icon">✏️</span><span>ECF Editor</span>
                <span>ECF PDF/IMG Editor v3.0</span>
            </div>
            <div class="header-btns">
                <button class="btn btn-outline" onclick="openUpload()">📂 開啟圖片</button>
                <button class="btn btn-outline" onclick="zoomFit()">🔍 適合大小</button>
                <div class="download-dropdown" id="download-dropdown">
                    <button class="btn btn-success" onclick="toggleDownloadMenu()" id="btn-download" disabled>💾 下載 ▼</button>
                    <div class="download-menu" id="download-menu">
                        <button onclick="downloadImage()">📷 下載當前頁 (PNG)</button>
                        <button onclick="downloadImageJpg()">📷 下載當前頁 (JPG)</button>
                        <button onclick="downloadImageWebp()">📷 下載當前頁 (WebP)</button>
                        <button onclick="downloadImageSvg()">📐 下載為向量 (SVG)</button>
                        <div class="download-menu-divider" id="pdf-export-divider"></div>
                        <button onclick="downloadAllImages()" id="btn-download-all" style="display:none;">📦 下載所有頁面 (ZIP)</button>
                        <button onclick="downloadAsPdf()" id="btn-download-pdf" style="display:none;">📄 輸出為 PDF</button>
                        <button onclick="openPdfEncryptDialog()" id="btn-download-encrypted-pdf">🔐 加密 PDF</button>
                    </div>
                </div>
                <button class="btn btn-outline" onclick="downloadPptx()" id="btn-pptx" disabled title="輸出為 PowerPoint">📊 輸出 PPTX</button>
            </div>
        </header>

        <div class="main">
            <main class="canvas-area">
                <div class="toolbar">
                    <!-- 選取工具群組 -->
                    <div class="tool-group">
                        <button class="tool-btn active" onclick="setMode('select')" id="mode-select" title="選取模式">⬚ 選取</button>
                        <button class="tool-group-toggle" onclick="toggleToolGroup('select-group')">▼</button>
                        <div class="tool-submenu" id="select-group">
                            <button onclick="setMode('region')" id="mode-region" title="框選文字">⛶ 框選</button>
                            <button onclick="setMode('imageSelect')" id="mode-imageSelect" title="矩形圖像選取">🖼️ 圖選</button>
                            <button onclick="setMode('lasso')" id="mode-lasso" title="套索選取">✂️ 套索</button>
                            <button onclick="setMode('magicwand')" id="mode-magicwand" title="魔術棒">🪄 魔術棒</button>
                            <button onclick="setMode('crop')" id="mode-crop" title="裁切工具">✂️ 裁切</button>
                        </div>
                    </div>
                    
                    <!-- 繪圖工具群組 -->
                    <div class="tool-group">
                        <button class="tool-btn" onclick="setMode('brush')" id="mode-brush" title="畫筆工具">🖌️ 繪圖</button>
                        <button class="tool-group-toggle" onclick="toggleToolGroup('draw-group')">▼</button>
                        <div class="tool-submenu" id="draw-group">
                            <button onclick="setMode('brush')" id="mode-brush-sub" title="畫筆">🖌️ 畫筆</button>
                            <button onclick="setMode('airbrush')" id="mode-airbrush" title="噴槍">🎨 噴槍</button>
                            <button onclick="setMode('highlighter')" id="mode-highlighter" title="螢光筆">🖍️ 螢光筆</button>
                            <button onclick="setMode('pencil')" id="mode-pencil" title="鉛筆">✏️ 鉛筆</button>
                            <button onclick="setMode('eraser')" id="mode-eraser" title="橡皮擦">🧽 橡皮擦</button>
                            <button onclick="setMode('clone')" id="mode-clone" title="克隆圖章">🖌️ 克隆</button>
                        </div>
                    </div>
                    
                    <!-- 形狀標註群組 -->
                    <div class="tool-group">
                        <button class="tool-btn" onclick="setMode('shape')" id="mode-shape" title="形狀工具">⬜ 形狀</button>
                        <button class="tool-group-toggle" onclick="toggleToolGroup('shape-group')">▼</button>
                        <div class="tool-submenu" id="shape-group">
                            <button onclick="setMode('shape')" id="mode-shape-sub" title="形狀">⬜ 形狀</button>
                            <button onclick="setMode('arrow')" id="mode-arrow" title="箭頭">➡️ 箭頭</button>
                            <button onclick="setMode('marker')" id="mode-marker" title="標記">⭕ 標記</button>
                            <button onclick="setMode('text')" id="mode-text" title="文字">✏️ 文字</button>
                            <button onclick="flattenTextObjects()" id="btn-flatten-text" title="合併文字">📝 合併文字</button>
                        </div>
                    </div>
                    
                    <!-- 填充效果群組 -->
                    <div class="tool-group">
                        <button class="tool-btn" onclick="setMode('fill')" id="mode-fill" title="填充工具">🪣 填充</button>
                        <button class="tool-group-toggle" onclick="toggleToolGroup('fill-group')">▼</button>
                        <div class="tool-submenu" id="fill-group">
                            <button onclick="setMode('fill')" id="mode-fill-sub" title="油漆桶">🪣 油漆桶</button>
                            <button onclick="setMode('gradient')" id="mode-gradient" title="漸層">🌈 漸層</button>
                            <button onclick="setMode('eyedropper')" id="mode-eyedropper" title="取色器">💧 取色</button>
                            <button onclick="openColorReplaceDialog()" title="顏色替換">🎨 換色</button>
                        </div>
                    </div>
                    
                    <!-- 特效處理群組 -->
                    <div class="tool-group">
                        <button class="tool-btn" onclick="setMode('mosaic')" id="mode-mosaic" title="馬賽克">🔲 特效</button>
                        <button class="tool-group-toggle" onclick="toggleToolGroup('effect-group')">▼</button>
                        <div class="tool-submenu" id="effect-group">
                            <button onclick="setMode('mosaic')" id="mode-mosaic-sub" title="馬賽克">🔲 馬賽克</button>
                            <button onclick="setMode('blur')" id="mode-blur" title="模糊">💨 模糊</button>
                            <button onclick="openFilterDialog()" title="濾鏡">🎨 濾鏡</button>
                            <button onclick="openSpecialEffects()" title="特效">✨ 特效</button>
                            <button onclick="removeBackground()" title="去背">✂️ 去背</button>
                        </div>
                    </div>
                    
                    <!-- 圖像處理群組 -->
                    <div class="tool-group">
                        <button class="tool-btn" onclick="openImageOptimizeDialog()" title="優化">🖼️ 圖像</button>
                        <button class="tool-group-toggle" onclick="toggleToolGroup('image-group')">▼</button>
                        <div class="tool-submenu" id="image-group">
                            <button onclick="openImageOptimizeDialog()" title="自動優化">✨ 優化</button>
                            <button onclick="openSocialSizeDialog()" title="社群尺寸">📱 社群尺寸</button>
                            <button onclick="insertImageToCanvas()" title="插入圖像">🖼️ 插入圖像</button>
                            <button onclick="openStitchDialog()" title="拼接">📑 拼接</button>
                            <button onclick="toggleLayerPanel()" title="圖層">🔄 圖層</button>
                            <div style="border-top:1px solid #444;margin:4px 0;"></div>
                            <button onclick="openLocalAdjustDialog()" title="局部調整">🎯 局部調整</button>
                            <button onclick="openPerspectiveDialog()" title="透視校正">📐 透視校正</button>
                            <button onclick="openLongStitchDialog()" title="長圖拼接">📜 長圖拼接</button>
                        </div>
                    </div>
                    
                    <!-- 標註裝飾群組 -->
                    <div class="tool-group">
                        <button class="tool-btn" onclick="openWatermarkDialog()" title="浮水印">💧 標註</button>
                        <button class="tool-group-toggle" onclick="toggleToolGroup('decor-group')">▼</button>
                        <div class="tool-submenu" id="decor-group">
                            <button onclick="openWatermarkDialog()" title="浮水印">💧 浮水印</button>
                            <button onclick="openStampDialog()" title="印章">🔏 印章</button>
                            <button onclick="openHeaderFooterDialog()" title="頁首尾">📑 頁首尾</button>
                            <button onclick="openStickerLibrary()" title="貼圖">😀 貼圖</button>
                            <button onclick="openChartTool()" title="圖表">📊 圖表</button>
                            <div style="border-top:1px solid #444;margin:4px 0;"></div>
                            <button onclick="openSpeechBubbleDialog()" title="語音泡泡">💬 語音泡泡</button>
                            <button onclick="openNumberLabelDialog()" id="mode-numberLabel" title="編號標籤">🔢 編號標籤</button>
                        </div>
                    </div>
                    
                    <!-- 檢視輔助群組 -->
                    <div class="tool-group">
                        <button class="tool-btn" onclick="toggleGuides()" id="btn-guides" title="輔助線">📏 檢視</button>
                        <button class="tool-group-toggle" onclick="toggleToolGroup('view-group')">▼</button>
                        <div class="tool-submenu" id="view-group">
                            <button onclick="toggleGuides()" title="輔助線">📏 輔助線</button>
                            <button onclick="togglePageThumbnails()" id="btn-thumbnails" title="縮圖">🖼️ 縮圖</button>
                            <button onclick="openPageManagerDialog()" title="頁面">📄 頁面</button>
                            <button onclick="openCompareDialog()" id="btn-compare" title="對照">🔀 對照</button>
                            <button onclick="openShortcutsPanel()" title="快捷鍵">⌨️ 快捷鍵</button>
                        </div>
                    </div>
                    
                    <div class="tool-divider"></div>
                    
                    <!-- 偵測搜尋 -->
                    <button class="tool-btn" onclick="detectAll()" title="全圖偵測">🎯 偵測</button>
                    <button class="tool-btn" onclick="ocrAndCreateEditable()" title="OCR辨識後直接建立可編輯區塊">🔍 OCR→編輯</button>
                    <button class="tool-btn" onclick="openSearchReplace()" title="搜尋取代">🔍 搜尋</button>
                    
                    <div class="tool-divider"></div>
                    
                    <!-- 復原重做 -->
                    <button class="tool-btn" onclick="undoLast()" id="undo-btn" title="復原 (Ctrl+Z)">↶</button>
                    <button class="tool-btn" onclick="redoLast()" id="redo-btn" title="重做 (Ctrl+Y)">↷</button>
                    <button class="tool-btn" onclick="toggleHistoryPanel()" title="歷史記錄">📜</button>
                    
                    <!-- 清除 -->
                    <button class="tool-btn" onclick="clearAllRegions()" title="清除所有">🗑️</button>
                    
                    <span id="mode-tag" class="mode-tag" style="display:none;"></span>
                    
                    <div class="tool-divider"></div>
                    
                    <!-- 縮放控制 -->
                    <div style="display:flex;align-items:center;gap:6px;">
                        <span style="font-size:11px;color:#888;">🔍</span>
                        <input type="range" id="zoom-slider" min="5" max="500" value="100" 
                            oninput="setZoomFromSlider(this.value)"
                            style="width:80px;cursor:pointer;accent-color:#6366f1;">
                        <span class="zoom-info" id="zoom-info" style="cursor:pointer;min-width:45px;text-align:center;font-size:11px;" 
                            onclick="showZoomDropdown(event)" title="點擊選擇縮放比例">100%</span>
                        <button class="tool-btn" onclick="zoomFit()" title="適合視窗" style="padding:4px 6px;">🔲</button>
                    </div>
                </div>
                
                <!-- 克隆圖章設定面板 -->
                <div id="clone-settings" style="display:none;align-items:center;gap:15px;padding:8px 15px;background:#2a2a2a;border-radius:6px;margin:5px 0;">
                    <span style="font-size:12px;color:#aaa;">🖌️ 克隆圖章設定</span>
                    <div style="display:flex;align-items:center;gap:8px;">
                        <label style="font-size:12px;color:#ccc;">筆刷大小:</label>
                        <input type="range" min="5" max="150" value="30" 
                            oninput="setCloneSize(+this.value)" 
                            style="width:120px;">
                        <span id="clone-size-value" style="font-size:12px;color:#fff;min-width:45px;">30px</span>
                    </div>
                    <div style="font-size:11px;color:#888;">
                        Alt+點擊設定來源 → 拖曳塗抹複製
                    </div>
                </div>
                
                <!-- 橡皮擦設定面板 -->
                <div id="eraser-settings" style="display:none;align-items:center;gap:15px;padding:8px 15px;background:#2a2a2a;border-radius:6px;margin:5px 0;flex-wrap:wrap;">
                    <span style="font-size:12px;color:#aaa;">🧽 橡皮擦設定</span>
                    <div style="display:flex;align-items:center;gap:8px;">
                        <label style="font-size:12px;color:#ccc;">大小:</label>
                        <input type="range" min="5" max="100" value="20" id="eraser-size-slider"
                            oninput="state.eraserSize=+this.value;document.getElementById('eraser-size-value').textContent=this.value+'px'" 
                            style="width:100px;">
                        <span id="eraser-size-value" style="font-size:12px;color:#fff;min-width:40px;">20px</span>
                    </div>
                    <div style="display:flex;align-items:center;gap:8px;">
                        <label style="font-size:12px;color:#ccc;">模式:</label>
                        <select id="eraser-mode-select" onchange="onEraserModeChange(this.value)" style="padding:4px 8px;background:#333;border:1px solid #555;border-radius:4px;color:#fff;font-size:12px;">
                            <option value="white">擦成白色</option>
                            <option value="transparent">擦成透明</option>
                            <option value="color">自訂顏色</option>
                            <option value="pick">取色塗抹</option>
                        </select>
                    </div>
                    <div id="eraser-color-picker" style="display:none;align-items:center;gap:8px;">
                        <label style="font-size:12px;color:#ccc;">顏色:</label>
                        <input type="color" id="eraser-color" value="#ffffff" 
                            onchange="state.eraserColor=this.value" 
                            style="width:36px;height:28px;border:none;border-radius:4px;cursor:pointer;">
                        <button onclick="pickEraserColor()" class="btn btn-outline" style="padding:4px 10px;font-size:11px;">💧 取色</button>
                    </div>
                    <div id="eraser-pick-hint" style="display:none;font-size:11px;color:#4a90d9;">
                        Alt+點擊 從圖片取色
                    </div>
                </div>
                
                <!-- 填充設定面板 -->
                <div id="fill-settings" style="display:none;align-items:center;gap:15px;padding:8px 15px;background:#2a2a2a;border-radius:6px;margin:5px 0;">
                    <span style="font-size:12px;color:#aaa;">🪣 油漆桶設定</span>
                    <div style="display:flex;align-items:center;gap:8px;">
                        <label style="font-size:12px;color:#ccc;">填充顏色:</label>
                        <input type="color" value="#ff0000" 
                            onchange="state.fillColor=this.value" 
                            style="width:40px;height:28px;border:none;border-radius:4px;cursor:pointer;">
                    </div>
                    <div style="display:flex;align-items:center;gap:8px;">
                        <label style="font-size:12px;color:#ccc;">容差:</label>
                        <input type="range" min="1" max="100" value="32" 
                            oninput="state.fillTolerance=+this.value;document.getElementById('fill-tolerance-value').textContent=this.value" 
                            style="width:80px;">
                        <span id="fill-tolerance-value" style="font-size:12px;color:#fff;min-width:30px;">32</span>
                    </div>
                </div>
                
                <!-- 漸層設定面板 -->
                <div id="gradient-settings" style="display:none;align-items:center;gap:12px;padding:8px 15px;background:#2a2a2a;border-radius:6px;margin:5px 0;flex-wrap:wrap;">
                    <span style="font-size:12px;color:#aaa;">🌈 漸層設定</span>
                    <div style="display:flex;align-items:center;gap:8px;">
                        <label style="font-size:12px;color:#ccc;">類型:</label>
                        <select onchange="state.gradientType=this.value" style="padding:4px 8px;background:#333;border:1px solid #555;border-radius:4px;color:#fff;font-size:12px;">
                            <option value="linear">線性漸層</option>
                            <option value="radial">放射漸層</option>
                        </select>
                    </div>
                    <div style="display:flex;align-items:center;gap:8px;">
                        <label style="font-size:12px;color:#ccc;">形狀:</label>
                        <select onchange="state.gradientShape=this.value" style="padding:4px 8px;background:#333;border:1px solid #555;border-radius:4px;color:#fff;font-size:12px;">
                            <option value="rect">矩形</option>
                            <option value="circle">圓形</option>
                            <option value="ellipse">橢圓</option>
                            <option value="roundRect">圓角矩形</option>
                        </select>
                    </div>
                    <div style="display:flex;align-items:center;gap:8px;">
                        <label style="font-size:12px;color:#ccc;">顏色1:</label>
                        <input type="color" id="gradient-color1" value="#ff0000" 
                            onchange="state.gradientColor1=this.value" 
                            style="width:32px;height:24px;border:none;border-radius:4px;cursor:pointer;">
                        <label style="font-size:12px;color:#ccc;">顏色2:</label>
                        <input type="color" id="gradient-color2" value="#0000ff" 
                            onchange="state.gradientColor2=this.value" 
                            style="width:32px;height:24px;border:none;border-radius:4px;cursor:pointer;">
                    </div>
                    <div style="display:flex;align-items:center;gap:8px;">
                        <label style="font-size:12px;color:#ccc;">透明度:</label>
                        <input type="range" min="0" max="100" value="100" 
                            oninput="state.gradientOpacity=this.value/100;document.getElementById('gradient-opacity-value').textContent=this.value+'%'" 
                            style="width:80px;">
                        <span id="gradient-opacity-value" style="font-size:11px;color:#fff;min-width:35px;">100%</span>
                    </div>
                    <div style="font-size:11px;color:#888;">拖曳繪製漸層範圍和方向</div>
                </div>

                <div class="canvas-wrapper" id="canvas-wrapper">
                    <div class="canvas-container" id="canvas-container">
                        <canvas id="main-canvas"></canvas>
                        <div class="select-rect" id="select-rect"></div>
                        <div id="regions-layer"></div>
                        <div id="magnifier" class="magnifier hidden"></div>
                    </div>
                    <!-- 裁切工具覆蓋層（放在 wrapper 內，覆蓋整個 wrapper） -->
                    <div class="crop-overlay hidden" id="crop-overlay">
                        <div class="crop-mask" id="crop-mask">
                            <div class="crop-box" id="crop-box">
                                <div class="crop-handle nw" data-handle="nw"></div>
                                <div class="crop-handle ne" data-handle="ne"></div>
                                <div class="crop-handle sw" data-handle="sw"></div>
                                <div class="crop-handle se" data-handle="se"></div>
                                <div class="crop-handle n" data-handle="n"></div>
                                <div class="crop-handle s" data-handle="s"></div>
                                <div class="crop-handle e" data-handle="e"></div>
                                <div class="crop-handle w" data-handle="w"></div>
                            </div>
                        </div>
                    </div>
                    <!-- 裁切工具列 -->
                    <div class="crop-toolbar hidden" id="crop-toolbar">
                        <select id="crop-ratio" onchange="setCropRatio(this.value)">
                            <option value="free">自由裁切</option>
                            <option value="1:1">1:1 正方形</option>
                            <option value="4:3">4:3</option>
                            <option value="16:9">16:9</option>
                            <option value="3:2">3:2</option>
                            <option value="2:3">2:3 直式</option>
                        </select>
                        <button class="btn btn-outline" onclick="cancelCrop()">取消</button>
                        <button class="btn btn-primary" onclick="applyCrop()">確認裁切</button>
                    </div>
                </div>
            </main>

            <aside class="panel">
                <div class="panel-header">編輯面板</div>
                <div class="panel-content" id="panel-content">
                    <div class="info-box">
                        <strong>使用方式：</strong><br><br>
                        1. 點擊「⛶ 框選」選取文字區域<br>
                        2. 選擇「編輯文字」或「清除區域」<br>
                        3. 編輯後點擊「✓ 確認修改」<br>
                        4. 使用方向鍵微調位置<br>
                        5. 下載修改後的圖片<br><br>
                        <strong>工具說明：</strong><br>
                        💧 取色：從圖片吸取顏色
                    </div>
                </div>
            </aside>
        </div>
    </div>

    <div class="upload-modal" id="upload-modal">
        <div class="upload-box">
            <div class="upload-icon">🖼️</div>
            <h3 class="upload-title">上傳圖片或 PDF</h3>
            <p class="upload-desc">支援 JPG、PNG、PDF 格式</p>
            <div class="dropzone" id="dropzone">
                <p class="dropzone-text">拖放圖片/PDF 或 <span>點擊選擇</span></p>
            </div>
            <input type="file" id="file-input" accept="image/*,.pdf,application/pdf">
        </div>
    </div>
    
    <!-- PDF 頁面選擇對話框 -->
    <div class="stitch-dialog" id="pdf-dialog">
        <div class="stitch-dialog-content" style="max-width:900px;">
            <div class="stitch-dialog-header">
                <h2>📄 PDF 載入</h2>
                <button class="history-panel-close" onclick="closePdfDialog()">×</button>
            </div>
            <div class="stitch-dialog-body">
                <div style="margin-bottom:12px;display:flex;justify-content:space-between;align-items:center;">
                    <span id="pdf-info">載入中...</span>
                    <div style="display:flex;gap:8px;">
                        <button class="btn btn-primary" onclick="quickLoadAllPdfPages()">⚡ 快速載入全部頁面</button>
                    </div>
                </div>
                
                <div class="pdf-pages-grid" id="pdf-pages-grid"></div>
                
                <div style="margin-top:16px;padding:12px;background:#1a1a1a;border-radius:8px;">
                    <div style="margin-bottom:12px;display:flex;justify-content:space-between;align-items:center;">
                        <label style="font-size:13px;color:#ccc;">或選擇特定頁面：</label>
                        <div style="display:flex;gap:8px;">
                            <button class="btn btn-outline" style="padding:4px 8px;font-size:11px;" onclick="selectAllPdfPages()">全選</button>
                            <button class="btn btn-outline" style="padding:4px 8px;font-size:11px;" onclick="deselectAllPdfPages()">取消全選</button>
                        </div>
                    </div>
                    <div style="display:flex;gap:12px;align-items:center;">
                        <select id="pdf-output-mode" class="prop-select" style="width:220px;">
                            <option value="selected" selected>逐頁編輯（可切換上下頁）</option>
                            <option value="single">合併為單張長圖</option>
                            <option value="first">僅載入第一頁</option>
                        </select>
                        <button class="btn btn-outline" onclick="applyPdfPages()" id="apply-pdf-btn">載入選取頁面</button>
                    </div>
                </div>
            </div>
            <div class="stitch-dialog-footer">
                <button class="btn btn-outline" onclick="closePdfDialog()">取消</button>
            </div>
        </div>
    </div>

    <div class="loading hidden" id="loading">
        <div class="spinner"></div>
        <p class="loading-text" id="loading-text">處理中...</p>
        <div class="loading-bar-wrap"><div class="loading-bar" id="loading-bar"></div></div>
    </div>

    <!-- PDF 頁面導航 -->
    <div class="pdf-nav" id="pdf-nav">
        <button onclick="prevPdfPage()" id="pdf-prev-btn" title="上一頁 (PageUp)">◀ 上一頁</button>
        <div class="pdf-page-jump">
            <span>第</span>
            <input type="number" id="pdf-page-input" min="1" value="1" onchange="jumpToPdfPage(this.value)" onclick="this.select()">
            <span>/ <span id="pdf-total-pages">1</span> 頁</span>
        </div>
        <button onclick="nextPdfPage()" id="pdf-next-btn" title="下一頁 (PageDown)">下一頁 ▶</button>
        <span class="pdf-nav-divider">|</span>
        <button onclick="addBlankPage()" title="添加空白頁面">➕ 新增頁</button>
        <button onclick="deleteCurrentPage()" title="刪除當前頁面">🗑️ 刪除頁</button>
        <span class="pdf-nav-divider">|</span>
        <button onclick="downloadCurrentPage()" title="下載當前頁為 PNG">💾 存當前頁</button>
        <button onclick="downloadAsPdf()" title="輸出整個 PDF">📄 存全部 PDF</button>
    </div>
    
    <div class="toasts" id="toasts"></div>

    <script>
        const canvas = document.getElementById('main-canvas');
        const ctx = canvas.getContext('2d');
        const selectRect = document.getElementById('select-rect');
        const canvasContainer = document.getElementById('canvas-container');
        const canvasWrapper = document.getElementById('canvas-wrapper');
        const regionsLayer = document.getElementById('regions-layer');

        const FONT_OPTIONS = [
            { value: 'Inter', label: 'Inter' },
            { value: 'Noto Sans TC', label: 'Noto Sans TC (思源黑體)' },
            { value: 'Noto Serif TC', label: 'Noto Serif TC (思源宋體)' },
            { value: 'Microsoft JhengHei', label: '微軟正黑體' },
            { value: 'PMingLiU', label: '新細明體' },
            { value: 'DFKai-SB', label: '標楷體' },
            { value: 'SimHei', label: '黑體' },
            { value: 'SimSun', label: '宋體' },
            { value: 'KaiTi', label: '楷體' },
            // 圓角字體
            { value: 'GenYoGothic TW', label: '源樣黑體 (圓角)' },
            { value: 'jf-openhuninn', label: 'jf open 粉圓' },
            { value: 'Cubic 11', label: 'Cubic 11 (圓點)' },
            { value: 'cwTeXYen', label: '圓體 (cwTeX)' },
            { value: 'TaipeiSansTCBeta', label: '台北黑體' },
            { value: 'Kosugi Maru', label: '小杉圓體' },
            { value: 'M PLUS Rounded 1c', label: 'M+ 圓體' },
            { value: 'Varela Round', label: 'Varela Round' },
            { value: 'Nunito', label: 'Nunito (圓角)' },
            { value: 'Quicksand', label: 'Quicksand (圓角)' },
            { value: 'Comfortaa', label: 'Comfortaa (圓角)' },
            // 英文字體
            { value: 'Arial', label: 'Arial' },
            { value: 'Arial Black', label: 'Arial Black' },
            { value: 'Arial Rounded MT Bold', label: 'Arial Rounded' },
            { value: 'Times New Roman', label: 'Times New Roman' },
            { value: 'Georgia', label: 'Georgia' },
            { value: 'Verdana', label: 'Verdana' },
            { value: 'Tahoma', label: 'Tahoma' },
            { value: 'Trebuchet MS', label: 'Trebuchet MS' },
            { value: 'Comic Sans MS', label: 'Comic Sans' }
        ];
        
        // 空白鍵拖拉畫布的全域狀態
        let isSpacePressed = false;
        let isPanning = false;

        const state = {
            image: null,
            originalImageData: null, // 原始圖片數據（用於前後對照比較）
            mode: 'select', // select, region, eyedropper, magicwand, brush, shape, mosaic, blur
            isSelecting: false,
            selStart: null,
            history: [],
            historyIndex: -1, // 當前歷史位置（支持 redo）
            historyNames: [], // 歷史操作名稱
            regions: [],
            activeRegion: null,
            selectedRegions: [], // 多選區塊
            copiedStyle: null, // 複製的樣式
            copiedFontStyle: null, // 複製的字體樣式（跨系統共用）
            textTemplates: JSON.parse(localStorage.getItem('ecf_text_templates') || '[]'), // 文字範本庫
            zoom: 1,
            displayScale: 1,
            // 框選區域（用於顏色替換等功能）
            selectBox: null, // { x, y, w, h }
            onSelectComplete: null, // 框選完成回調
            // 拖動相關
            isDragging: false,
            dragRegion: null,
            dragOffset: null,
            dragStartPos: null,
            // 取色器
            eyedropperTarget: null, // 'color' 或 'bgColor'
            // 魔術棒
            magicWandTolerance: 32, // 顏色容差 (0-255)
            // 繪圖工具
            brushColor: '#ff0000',
            brushSize: 5,
            brushOpacity: 1,
            isDrawing: false,
            lastPoint: null,
            // 噴槍
            airbrushColor: '#ff0000',
            airbrushSize: 30,
            airbrushDensity: 30, // 噴灑密度
            airbrushOpacity: 0.3,
            airbrushParticleSize: 2, // 顆粒大小
            // 螢光筆
            highlighterColor: '#ffff00',
            highlighterSize: 20,
            highlighterOpacity: 0.4,
            // 鉛筆
            pencilColor: '#333333',
            pencilSize: 2,
            pencilJitter: 0.5, // 抖動效果
            // 形狀工具
            shapeType: 'rect', // rect, circle, line, arrow
            shapeStroke: true,
            shapeFill: false,
            shapeStrokeColor: '#ff0000',
            shapeFillColor: '#ffff00',
            shapeStrokeWidth: 3,
            // 馬賽克/模糊
            mosaicSize: 10,
            blurRadius: 5,
            // 克隆圖章
            cloneSize: 30,
            // 橡皮擦
            eraserSize: 20,
            eraserMode: 'white', // 'white', 'transparent', 'color', 'pick'
            eraserColor: '#ffffff',
            eraserPickingColor: false,
            // 油漆桶填充
            fillColor: '#ff0000',
            fillTolerance: 32,
            // 漸層填充
            gradientType: 'linear', // 'linear' 或 'radial'
            gradientShape: 'rect', // 'rect', 'circle', 'ellipse', 'roundRect'
            gradientOpacity: 1, // 0-1
            gradientStart: null,
            // 文字漸層
            gradientEnabled: false,
            gradientColor1: '#ff0000',
            gradientColor2: '#0000ff',
            gradientDirection: 'horizontal', // horizontal, vertical, diagonal
            // 樣式範本
            stylePresets: [
                { name: '標題', fontSize: 36, fontWeight: '700', color: '#ffffff', bgColor: '#000000', strokeWidth: 2, strokeColor: '#000000' },
                { name: '副標題', fontSize: 24, fontWeight: '600', color: '#333333', bgColor: 'transparent', strokeWidth: 0 },
                { name: '內文', fontSize: 16, fontWeight: '400', color: '#000000', bgColor: 'transparent', strokeWidth: 0 },
                { name: '標註', fontSize: 14, fontWeight: '500', color: '#ff0000', bgColor: '#ffff00', strokeWidth: 0 },
                { name: '浮水印', fontSize: 20, fontWeight: '300', color: 'rgba(128,128,128,0.5)', bgColor: 'transparent', strokeWidth: 0 }
            ],
            // 曲線文字
            curveEnabled: false,
            curveRadius: 100,
            curveStartAngle: 0,
            // 圖片拼接
            stitchImages: [], // 待拼接的圖片列表
            stitchMode: 'vertical', // vertical, horizontal, grid
            stitchGap: 0, // 圖片間距
            // PDF 相關
            pdfDoc: null,
            pdfPages: [], // PDF 頁面圖片列表
            currentPdfPage: 0,
            // 浮水印
            watermark: null, // 浮水印圖片
            watermarkX: 0,
            watermarkY: 0,
            watermarkWidth: 100,
            watermarkHeight: 100,
            watermarkOpacity: 0.5,
            watermarkOriginalWidth: 0,
            watermarkOriginalHeight: 0,
            isWatermarkDragging: false,
            watermarkDragOffset: null,
            // 圖像選取
            imageRegions: [], // 圖像選取區塊列表
            activeImageRegion: null, // 活動的圖像區塊
            isImageDragging: false,
            imageDragOffset: null,
            isImageResizing: false,
            imageResizeCorner: null,
            imageResizeStart: null,
            isImageRotating: false,
            imageRotateCenter: null,
            // 套索選取
            lassoPath: [], // 套索路徑點
            isLassoDrawing: false, // 是否正在繪製套索
            // 匯出設定
            exportFormat: 'png',
            exportQuality: 0.92,
            // 裁切工具
            cropMode: false,
            cropBox: { x: 0, y: 0, w: 100, h: 100 },
            cropRatio: 'free',
            cropDragging: false,
            cropResizing: false,
            cropHandle: null,
            // 箭頭工具
            arrowStart: null,
            arrowColor: '#ff0000',
            arrowWidth: 3,
            arrowStyle: 'solid', // solid, dashed
            // 標記符號
            markerType: 'circle', // circle, rect, check, cross, number
            markerColor: '#ff0000',
            markerSize: 40,
            markerNumber: 1,
            markerFilled: false,
            // 輔助線
            guidesVisible: false,
            // 濾鏡
            filterOriginalData: null,
            // 搜尋
            searchMatches: [],
            searchIndex: 0,
            // 自動儲存
            autoSaveEnabled: true,
            autoSaveInterval: 60000, // 60 秒
            lastAutoSave: null
        };
        
        // 自動儲存功能
        let autoSaveTimer = null;
        
        function initAutoSave() {
            if (autoSaveTimer) clearInterval(autoSaveTimer);
            
            autoSaveTimer = setInterval(() => {
                if (state.autoSaveEnabled && state.image) {
                    performAutoSave();
                }
            }, state.autoSaveInterval);
            
            // 嘗試恢復上次的自動儲存
            checkAutoSaveRecovery();
        }
        
        // ============ 工具群組控制 ============
        let activeToolGroup = null;
        
        function toggleToolGroup(groupId) {
            const submenu = document.getElementById(groupId);
            const allSubmenus = document.querySelectorAll('.tool-submenu');
            
            // 關閉其他群組
            allSubmenus.forEach(menu => {
                if (menu.id !== groupId) {
                    menu.classList.remove('show');
                }
            });
            
            // 切換當前群組
            if (submenu.classList.contains('show')) {
                submenu.classList.remove('show');
                activeToolGroup = null;
            } else {
                submenu.classList.add('show');
                activeToolGroup = groupId;
            }
        }
        
        // 點擊外部關閉群組選單
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.tool-group')) {
                document.querySelectorAll('.tool-submenu').forEach(menu => {
                    menu.classList.remove('show');
                });
                activeToolGroup = null;
            }
        });
        
        function performAutoSave() {
            try {
                const saveData = {
                    timestamp: Date.now(),
                    canvasData: canvas.toDataURL('image/png'),
                    canvasWidth: canvas.width,
                    canvasHeight: canvas.height,
                    textObjects: JSON.stringify(textObjects),
                    gradientObjects: JSON.stringify(gradientObjects),
                    regions: JSON.stringify(state.regions),
                    pdfPages: state.pdfPages.length > 1 ? state.pdfPages.map((p, i) => ({
                        dataUrl: i === state.currentPdfPage ? canvas.toDataURL() : (p.editedData || p.dataUrl),
                        regions: i === state.currentPdfPage ? state.regions : p.regions
                    })) : null,
                    currentPdfPage: state.currentPdfPage
                };
                
                localStorage.setItem('ecf-editor-autosave', JSON.stringify(saveData));
                state.lastAutoSave = Date.now();
                
                // 顯示儲存指示
                showAutoSaveIndicator();
            } catch (e) {
                console.warn('自動儲存失敗:', e);
            }
        }
        
        function showAutoSaveIndicator() {
            let indicator = document.getElementById('autosave-indicator');
            if (!indicator) {
                indicator = document.createElement('div');
                indicator.id = 'autosave-indicator';
                indicator.style.cssText = `
                    position: fixed;
                    bottom: 20px;
                    left: 20px;
                    background: rgba(34, 197, 94, 0.9);
                    color: white;
                    padding: 8px 16px;
                    border-radius: 20px;
                    font-size: 12px;
                    z-index: 9999;
                    transition: opacity 0.3s;
                `;
                document.body.appendChild(indicator);
            }
            
            const time = new Date().toLocaleTimeString();
            indicator.textContent = `💾 已自動儲存 ${time}`;
            indicator.style.opacity = '1';
            
            setTimeout(() => {
                indicator.style.opacity = '0';
            }, 2000);
        }
        
        function checkAutoSaveRecovery() {
            try {
                const saved = localStorage.getItem('ecf-editor-autosave');
                if (!saved) return;
                
                const saveData = JSON.parse(saved);
                const savedTime = new Date(saveData.timestamp);
                const now = new Date();
                const hoursDiff = (now - savedTime) / (1000 * 60 * 60);
                
                // 如果儲存時間超過 24 小時，忽略
                if (hoursDiff > 24) {
                    localStorage.removeItem('ecf-editor-autosave');
                    return;
                }
                
                // 顯示恢復對話框
                const dialog = document.createElement('div');
                dialog.id = 'recovery-dialog';
                dialog.style.cssText = `
                    position: fixed;
                    left: 50%;
                    top: 50%;
                    transform: translate(-50%, -50%);
                    background: #1a1a1a;
                    border: 1px solid #444;
                    border-radius: 12px;
                    padding: 20px;
                    z-index: 10002;
                    min-width: 400px;
                    box-shadow: 0 10px 40px rgba(0,0,0,0.5);
                `;
                
                dialog.innerHTML = `
                    <h3 style="margin:0 0 15px 0;">💾 發現自動儲存的內容</h3>
                    <p style="margin-bottom:15px;color:#ccc;">
                        上次編輯時間：${savedTime.toLocaleString()}<br>
                        是否要恢復上次的編輯內容？
                    </p>
                    <div style="display:flex;gap:10px;justify-content:flex-end;">
                        <button onclick="dismissAutoSave()" class="btn btn-outline">忽略</button>
                        <button onclick="recoverAutoSave()" class="btn btn-primary">恢復</button>
                    </div>
                `;
                
                document.body.appendChild(dialog);
            } catch (e) {
                console.warn('檢查自動儲存失敗:', e);
            }
        }
        
        function dismissAutoSave() {
            document.getElementById('recovery-dialog').remove();
            localStorage.removeItem('ecf-editor-autosave');
        }
        
        async function recoverAutoSave() {
            document.getElementById('recovery-dialog').remove();
            
            try {
                const saved = localStorage.getItem('ecf-editor-autosave');
                if (!saved) return;
                
                const saveData = JSON.parse(saved);
                
                showLoading('正在恢復...');
                
                // 恢復畫布
                const img = await loadImageFromUrl(saveData.canvasData);
                state.image = img;
                canvas.width = saveData.canvasWidth;
                canvas.height = saveData.canvasHeight;
                ctx.drawImage(img, 0, 0);
                
                // 恢復文字和漸層物件
                if (saveData.textObjects) {
                    textObjects = JSON.parse(saveData.textObjects);
                    renderTextObjects();
                }
                if (saveData.gradientObjects) {
                    gradientObjects = JSON.parse(saveData.gradientObjects);
                    renderGradientObjects();
                }
                
                // 恢復區塊
                if (saveData.regions) {
                    state.regions = JSON.parse(saveData.regions);
                    renderRegions();
                }
                
                // 恢復 PDF 頁面
                if (saveData.pdfPages) {
                    state.pdfPages = saveData.pdfPages;
                    state.currentPdfPage = saveData.currentPdfPage;
                    document.getElementById('pdf-nav').style.display = 'flex';
                    updatePdfNav();
                }
                
                fitCanvasToScreen();
                enableTools();
                hideLoading();
                
                toast('已恢復上次的編輯內容', 'success');
            } catch (e) {
                hideLoading();
                toast('恢復失敗: ' + e.message, 'error');
            }
        }
        
        // 初始化自動儲存
        initAutoSave();
        
        // PDF.js 和 Tesseract 延遲載入
        let pdfjsLoaded = false;
        let pdfjsLoading = false;
        let pdfjsFailed = false;
        
        async function loadPdfJs() {
            if (pdfjsFailed) return false;
            if (pdfjsLoaded) return true;
            if (pdfjsLoading) {
                let waited = 0;
                while (pdfjsLoading && waited < 10000) {
                    await new Promise(r => setTimeout(r, 100));
                    waited += 100;
                }
                return pdfjsLoaded;
            }
            
            pdfjsLoading = true;
            
            // 使用 Promise.race 添加 10 秒超時
            const timeout = new Promise((resolve) => {
                setTimeout(() => {
                    if (!pdfjsLoaded) {
                        pdfjsLoading = false;
                        pdfjsFailed = true;
                        resolve(false);
                    }
                }, 10000);
            });
            
            const loadPromise = new Promise((resolve) => {
                const script = document.createElement('script');
                script.src = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.min.js';
                script.onload = () => {
                    if (typeof pdfjsLib !== 'undefined') {
                        pdfjsLib.GlobalWorkerOptions.workerSrc = '';
                    }
                    pdfjsLoaded = true;
                    pdfjsLoading = false;
                    resolve(true);
                };
                script.onerror = () => {
                    pdfjsLoading = false;
                    pdfjsFailed = true;
                    resolve(false);
                };
                document.head.appendChild(script);
            });
            
            return Promise.race([loadPromise, timeout]);
        }
        
        // Tesseract 延遲載入
        let tesseractLoaded = false;
        let tesseractLoading = false;
        let tesseractFailed = false;
        
        // 手動輸入文字區塊（OCR 失敗時的備用方案）
        function createManualTextRegion(x, y, w, h) {
            try {
                let colors = { textColor: '#000000', bgColor: '#ffffff' };
                let fontSize = 16;
                
                try {
                    const regionData = ctx.getImageData(x, y, w, h);
                    colors = analyzeColors(regionData);
                    const textInfo = analyzeTextHeight(regionData, colors.bgColor);
                    fontSize = Math.max(12, Math.round(textInfo.textHeight * 0.85)) || 16;
                } catch (e) {
                    // 使用預設值
                }
                
                const region = {
                    id: Date.now(),
                    x, y, w, h,
                    originalText: '',
                    text: '請輸入文字',
                    fontSize,
                    fontFamily: 'Noto Sans TC, sans-serif',
                    fontWeight: '400',
                    scaleY: 1.0,
                    color: colors.textColor,
                    bgColor: colors.bgColor,
                    transparentBg: true,
                    lineHeight: 1.2,
                    textAlign: 'left',
                    letterSpacing: 0,
                    padding: 2,
                    strokeWidth: 0,
                    strokeColor: '#000000',
                    shadowColor: '#000000',
                    shadowBlur: 0,
                    shadowOffsetX: 0,
                    shadowOffsetY: 0,
                    rotation: 0,
                    gradientEnabled: false,
                    gradientColor1: '#ff0000',
                    gradientColor2: '#0000ff',
                    gradientDirection: 'horizontal',
                    curveEnabled: false,
                    curveRadius: 100,
                    curveStartAngle: 0,
                    layerIndex: activeLayerIndex // 記錄所屬圖層
                };
                
                state.regions.push(region);
                state.activeRegion = region;
                
                renderRegions();
                updatePanel();
            } catch (err) {
                console.error('createManualTextRegion error:', err);
            }
        }
        
        async function loadTesseract() {
            if (tesseractFailed) return false;
            if (tesseractLoaded) return true;
            if (tesseractLoading) {
                let waited = 0;
                while (tesseractLoading && waited < 3000) {
                    await new Promise(r => setTimeout(r, 100));
                    waited += 100;
                }
                return tesseractLoaded;
            }
            
            tesseractLoading = true;
            
            // 3 秒超時（平台限制時快速失敗）
            const timeout = new Promise((resolve) => {
                setTimeout(() => {
                    if (!tesseractLoaded) {
                        tesseractLoading = false;
                        tesseractFailed = true;
                        resolve(false);
                    }
                }, 3000);
            });
            
            const loadPromise = new Promise((resolve) => {
                const script = document.createElement('script');
                script.src = 'https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js';
                script.onload = () => {
                    tesseractLoaded = true;
                    tesseractLoading = false;
                    resolve(true);
                };
                script.onerror = () => {
                    tesseractLoading = false;
                    tesseractFailed = true;
                    resolve(false);
                };
                document.head.appendChild(script);
            });
            
            return Promise.race([loadPromise, timeout]);
        }
        
        // PptxGenJS 延遲載入
        let pptxLoaded = false;
        let pptxLoading = false;
        
        async function loadPptxGenJS() {
            if (pptxLoaded) return true;
            if (pptxLoading) {
                while (pptxLoading) {
                    await new Promise(r => setTimeout(r, 100));
                }
                return pptxLoaded;
            }
            
            pptxLoading = true;
            
            return new Promise((resolve) => {
                const script = document.createElement('script');
                script.src = 'https://cdn.jsdelivr.net/npm/pptxgenjs@3.12.0/dist/pptxgen.bundle.js';
                script.onload = () => {
                    pptxLoaded = true;
                    pptxLoading = false;
                    // console.log('PptxGenJS loaded');
                    resolve(true);
                };
                script.onerror = () => {
                    pptxLoading = false;
                    // console.error('Failed to load PptxGenJS');
                    resolve(false);
                };
                document.head.appendChild(script);
            });
        }
        
        // jsPDF 延遲載入
        let jspdfLoaded = false;
        let jspdfLoading = false;
        
        async function loadJsPDF() {
            if (jspdfLoaded) return true;
            if (jspdfLoading) {
                while (jspdfLoading) {
                    await new Promise(r => setTimeout(r, 100));
                }
                return jspdfLoaded;
            }
            
            jspdfLoading = true;
            
            return new Promise((resolve) => {
                const script = document.createElement('script');
                script.src = 'https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js';
                script.onload = () => {
                    jspdfLoaded = true;
                    jspdfLoading = false;
                    // console.log('jsPDF loaded');
                    resolve(true);
                };
                script.onerror = () => {
                    jspdfLoading = false;
                    // console.error('Failed to load jsPDF');
                    resolve(false);
                };
                document.head.appendChild(script);
            });
        }

        // Init
        document.addEventListener('DOMContentLoaded', () => {
            const dropzone = document.getElementById('dropzone');
            const fileInput = document.getElementById('file-input');

            dropzone.onclick = () => fileInput.click();
            dropzone.ondragover = e => { e.preventDefault(); dropzone.classList.add('dragover'); };
            dropzone.ondragleave = () => dropzone.classList.remove('dragover');
            dropzone.ondrop = e => {
                e.preventDefault();
                dropzone.classList.remove('dragover');
                if (e.dataTransfer.files[0]) loadImage(e.dataTransfer.files[0]);
            };
            fileInput.onchange = e => { if (e.target.files[0]) loadImage(e.target.files[0]); };

            // 綁定到 canvasContainer 以確保清除模式能正常運作
            canvasContainer.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
            
            // 右鍵選單 - 以點擊位置為中心放大
            canvasWrapper.addEventListener('contextmenu', (e) => {
                // 如果點擊在編輯區域上，讓原本的右鍵選單處理
                if (e.target.closest('.edit-region') || e.target.closest('.image-region-box')) {
                    return;
                }
                
                if (!state.image) return;
                e.preventDefault();
                
                // 顯示縮放選單
                showZoomContextMenu(e);
            });
            
            // 空白鍵 + 滑鼠拖拉畫布功能
            (function() {
                let startX, startY, startScrollLeft, startScrollTop;
                
                function onPanMove(e) {
                    if (!isPanning) return;
                    e.preventDefault();
                    e.stopPropagation();
                    const dx = e.pageX - startX;
                    const dy = e.pageY - startY;
                    canvasWrapper.scrollLeft = startScrollLeft - dx;
                    canvasWrapper.scrollTop = startScrollTop - dy;
                }
                
                function onPanEnd(e) {
                    if (!isPanning) return;
                    isPanning = false;
                    canvasWrapper.style.cursor = isSpacePressed ? 'grab' : '';
                    document.removeEventListener('mousemove', onPanMove, true);
                    document.removeEventListener('mouseup', onPanEnd, true);
                }
                
                // 空白鍵按下
                document.addEventListener('keydown', (e) => {
                    if (e.code === 'Space' && !e.repeat && !isSpacePressed) {
                        const tag = document.activeElement.tagName;
                        if (tag === 'INPUT' || tag === 'TEXTAREA' || document.activeElement.isContentEditable) {
                            return;
                        }
                        e.preventDefault();
                        isSpacePressed = true;
                        canvasWrapper.style.cursor = 'grab';
                    }
                }, true);
                
                // 空白鍵放開
                document.addEventListener('keyup', (e) => {
                    if (e.code === 'Space') {
                        isSpacePressed = false;
                        if (!isPanning) {
                            canvasWrapper.style.cursor = '';
                        }
                    }
                }, true);
                
                // 使用 capture phase 在 document 上監聽 mousedown，優先攔截
                document.addEventListener('mousedown', (e) => {
                    if (!isSpacePressed || e.button !== 0) return;
                    
                    // 確保是在 canvasWrapper 區域內
                    if (!canvasWrapper.contains(e.target)) return;
                    
                    e.preventDefault();
                    e.stopPropagation();
                    
                    isPanning = true;
                    startX = e.pageX;
                    startY = e.pageY;
                    startScrollLeft = canvasWrapper.scrollLeft;
                    startScrollTop = canvasWrapper.scrollTop;
                    canvasWrapper.style.cursor = 'grabbing';
                    
                    document.addEventListener('mousemove', onPanMove, true);
                    document.addEventListener('mouseup', onPanEnd, true);
                }, true);
                
                // 視窗失焦重置
                window.addEventListener('blur', () => {
                    isSpacePressed = false;
                    isPanning = false;
                    canvasWrapper.style.cursor = '';
                    document.removeEventListener('mousemove', onPanMove, true);
                    document.removeEventListener('mouseup', onPanEnd, true);
                });
            })();
            
            // 鍵盤快捷鍵
            document.addEventListener('keydown', (e) => {
                // 如果正在拖拉畫布，忽略其他快捷鍵
                if (isSpacePressed || isPanning) return;
                
                // Ctrl+V 貼上圖片
                if (e.ctrlKey && e.key === 'v') {
                    // 讓瀏覽器處理 paste 事件
                    return;
                }
                
                // Ctrl+Z 復原
                if (e.ctrlKey && e.key === 'z' && !e.shiftKey) {
                    e.preventDefault();
                    undoLast();
                    return;
                }
                
                // Ctrl+Y 或 Ctrl+Shift+Z 重做
                if ((e.ctrlKey && e.key === 'y') || (e.ctrlKey && e.shiftKey && e.key === 'z')) {
                    e.preventDefault();
                    redoLast();
                    return;
                }
                
                // Escape 取消選取
                if (e.key === 'Escape') {
                    if (document.getElementById('stitch-dialog').classList.contains('show')) {
                        closeStitchDialog();
                    } else if (document.getElementById('history-panel').classList.contains('show')) {
                        toggleHistoryPanel();
                    } else if (state.lassoPath && state.lassoPath.length > 0) {
                        // 取消套索選取
                        clearLassoPath();
                        toast('已取消套索選取', 'info');
                    } else if (state.activeImageRegion) {
                        cancelImageRegion();
                    } else if (state.activeRegion) {
                        cancelRegion();
                    }
                    return;
                }
                
                // Tab / Shift+Tab 切換區塊
                if (e.key === 'Tab' && state.activeRegion && state.regions.length > 1) {
                    if (document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'TEXTAREA') {
                        e.preventDefault();
                        navigateRegion(e.shiftKey ? -1 : 1);
                        return;
                    }
                }
                
                // Delete 鍵刪除可拖拉物件（語音泡泡、編號標籤）
                if (e.key === 'Delete' || e.key === 'Backspace') {
                    if (document.activeElement.tagName === 'INPUT' || 
                        document.activeElement.tagName === 'TEXTAREA' ||
                        document.activeElement.closest('.panel')) {
                        return; // 在輸入框中不處理
                    }
                    
                    // 刪除選中的語音泡泡
                    if (typeof activeBubble !== 'undefined' && activeBubble) {
                        e.preventDefault();
                        speechBubbleObjects = speechBubbleObjects.filter(b => b.id !== activeBubble.id);
                        activeBubble = null;
                        renderSpeechBubbles();
                        toast('已刪除語音泡泡', 'info');
                        return;
                    }
                    
                    // 刪除選中的編號標籤
                    if (typeof activeNumberLabel !== 'undefined' && activeNumberLabel) {
                        e.preventDefault();
                        numberLabelObjects = numberLabelObjects.filter(l => l.id !== activeNumberLabel.id);
                        activeNumberLabel = null;
                        renderNumberLabels();
                        toast('已刪除編號標籤', 'info');
                        return;
                    }
                    
                    // 刪除選中的圖層
                    if (typeof state !== 'undefined' && state.layers && state.activeLayerIndex > 0) {
                        // 不在這裡處理，讓後面的邏輯處理
                    }
                }
                
                // Backspace 刪除套索的最後一個點
                if (e.key === 'Backspace' && state.mode === 'lasso' && state.lassoPath && state.lassoPath.length > 0) {
                    if (!document.activeElement.closest('.panel') && 
                        document.activeElement.tagName !== 'INPUT' && 
                        document.activeElement.tagName !== 'TEXTAREA') {
                        e.preventDefault();
                        state.lassoPath.pop();
                        if (state.lassoPath.length === 0) {
                            clearLassoPath();
                        } else {
                            updateLassoPathSVG();
                        }
                        return;
                    }
                }
                
                // Enter 鍵閉合套索
                if (e.key === 'Enter' && state.mode === 'lasso' && state.lassoPath && state.lassoPath.length >= 3) {
                    if (!document.activeElement.closest('.panel') && 
                        document.activeElement.tagName !== 'INPUT' && 
                        document.activeElement.tagName !== 'TEXTAREA') {
                        e.preventDefault();
                        processLassoSelect();
                        clearLassoPath();
                        return;
                    }
                }
                
                // PageUp/PageDown 切換 PDF 頁面
                if (e.key === 'PageUp' && state.pdfPages.length > 1) {
                    e.preventDefault();
                    prevPdfPage();
                    return;
                }
                if (e.key === 'PageDown' && state.pdfPages.length > 1) {
                    e.preventDefault();
                    nextPdfPage();
                    return;
                }
                
                // 如果正在輸入文字，不處理方向鍵
                if (document.activeElement.tagName === 'TEXTAREA' || 
                    document.activeElement.tagName === 'INPUT') return;
                
                const step = e.shiftKey ? 10 : 1; // Shift 加速
                
                // 圖像區塊的鍵盤操作
                if (state.activeImageRegion) {
                    const r = state.activeImageRegion;
                    switch(e.key) {
                        case 'ArrowUp':
                            r.y = Math.max(0, r.y - step);
                            renderImageRegions();
                            e.preventDefault();
                            break;
                        case 'ArrowDown':
                            r.y = Math.min(canvas.height - r.h, r.y + step);
                            renderImageRegions();
                            e.preventDefault();
                            break;
                        case 'ArrowLeft':
                            r.x = Math.max(0, r.x - step);
                            renderImageRegions();
                            e.preventDefault();
                            break;
                        case 'ArrowRight':
                            r.x = Math.min(canvas.width - r.w, r.x + step);
                            renderImageRegions();
                            e.preventDefault();
                            break;
                        case 'Delete':
                        case 'Backspace':
                            if (!document.activeElement.closest('.panel')) {
                                deleteImageRegion();
                                e.preventDefault();
                            }
                            break;
                        case 'Enter':
                            if (!document.activeElement.closest('.panel')) {
                                commitImageRegion();
                                e.preventDefault();
                            }
                            break;
                    }
                    return;
                }
                
                if (!state.activeRegion) return;
                
                switch(e.key) {
                    case 'ArrowUp':
                        nudgeRegion(0, -step);
                        e.preventDefault();
                        break;
                    case 'ArrowDown':
                        nudgeRegion(0, step);
                        e.preventDefault();
                        break;
                    case 'ArrowLeft':
                        nudgeRegion(-step, 0);
                        e.preventDefault();
                        break;
                    case 'ArrowRight':
                        nudgeRegion(step, 0);
                        e.preventDefault();
                        break;
                    case 'Delete':
                    case 'Backspace':
                        if (!document.activeElement.closest('.panel')) {
                            deleteRegion();
                            e.preventDefault();
                        }
                        break;
                }
            });
            
            // 剪貼簿貼上事件
            document.addEventListener('paste', handlePaste);
            
            // 拼接對話框拖放事件
            const stitchDropzone = document.getElementById('stitch-dropzone');
            stitchDropzone.addEventListener('dragover', (e) => {
                e.preventDefault();
                stitchDropzone.classList.add('dragover');
            });
            stitchDropzone.addEventListener('dragleave', () => {
                stitchDropzone.classList.remove('dragover');
            });
            stitchDropzone.addEventListener('drop', (e) => {
                e.preventDefault();
                stitchDropzone.classList.remove('dragover');
                handleStitchFiles(e.dataTransfer.files);
            });
            
            window.addEventListener('resize', () => {
                if (state.image) zoomFit();
            });
        });

        function loadImage(file) {
            // 檢查是否為 PDF
            if (file.type === 'application/pdf' || file.name.toLowerCase().endsWith('.pdf')) {
                loadPdf(file);
                return;
            }
            
            const reader = new FileReader();
            reader.onload = e => {
                const img = new Image();
                img.onload = () => {
                    initializeWithImage(img);
                    toast('圖片載入成功', 'success');
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
        
        function initializeWithImage(img) {
            // 完整重置所有狀態
            resetAllState();
            
            state.image = img;
            
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            
            // 保存原始圖片（用於前後對照比較）
            state.originalImageData = canvas.toDataURL();
            
            // 初始化歷史（第一個狀態）
            state.history = [{
                imageData: ctx.getImageData(0, 0, canvas.width, canvas.height),
                regions: [],
                timestamp: Date.now()
            }];
            state.historyNames = ['載入圖片'];
            state.historyIndex = 0;
            
            document.getElementById('upload-modal').classList.add('hidden');
            document.getElementById('btn-download').disabled = false;
            document.getElementById('btn-pptx').disabled = false;
            
            // 隱藏 PDF 導航
            document.getElementById('pdf-nav').classList.remove('show');
            
            // 更新下載選項
            updateDownloadOptions();
            
            // 自動縮放到適合大小
            zoomFit();
            
            updatePanel();
            updateUndoButton();
            updateHistoryPanel();
        }
        
        // 完整重置所有狀態
        function resetAllState() {
            // 重置基本狀態
            state.image = null;
            state.originalImageData = null;
            state.history = [];
            state.historyNames = [];
            state.historyIndex = -1;
            state.regions = [];
            state.activeRegion = null;
            state.selectedRegions = [];
            state.pdfPages = [];
            state.currentPdfPage = 0;
            state.pdfDoc = null;
            
            // 重置圖像區塊
            state.imageRegions = [];
            state.activeImageRegion = null;
            
            // 重置選取狀態
            state.selectBox = null;
            state.onSelectComplete = null;
            state.isSelecting = false;
            state.selStart = null;
            
            // 重置拖動狀態
            state.isDragging = false;
            state.dragRegion = null;
            state.dragOffset = null;
            state.dragStartPos = null;
            
            // 重置取色器狀態
            state.eyedropperTarget = null;
            
            // 重置複製的樣式
            state.copiedStyle = null;
            
            // 重置文字物件
            textObjects = [];
            activeTextObject = null;
            textDragOffset = null;
            
            // 重置漸層物件
            gradientObjects = [];
            activeGradientObject = null;
            gradientDragOffset = null;
            
            // 清除畫布上的覆蓋層
            document.querySelectorAll('.text-object-overlay').forEach(el => el.remove());
            document.querySelectorAll('.gradient-object-overlay').forEach(el => el.remove());
            document.querySelectorAll('.image-region-overlay').forEach(el => el.remove());
            
            // 重置縮放
            state.zoom = 1;
            state.displayScale = 1;
            
            // 重置模式
            state.mode = 'select';
            
            // 更新工具列狀態
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            const selectBtn = document.querySelector('.tool-btn[onclick*="setMode(\'select\')"]');
            if (selectBtn) selectBtn.classList.add('active');
            
            // 清除所有區塊渲染
            const regionsLayer = document.getElementById('regions-layer');
            if (regionsLayer) {
                regionsLayer.innerHTML = '';
            }
        }
        
        // ============ PDF 處理 ============
        
        async function loadPdf(file) {
            showLoading('載入 PDF 引擎...');
            
            // 延遲載入 PDF.js
            const loaded = await loadPdfJs();
            if (!loaded) {
                hideLoading();
                toast('PDF 引擎載入失敗（可能是平台限制）', 'error');
                return;
            }
            
            showLoading('解析 PDF 頁面中...');
            
            try {
                const arrayBuffer = await file.arrayBuffer();
                const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                
                state.pdfDoc = pdf;
                state.pdfPages = [];
                
                const numPages = pdf.numPages;
                document.getElementById('pdf-info').textContent = `共 ${numPages} 頁`;
                
                // 渲染所有頁面縮圖
                const grid = document.getElementById('pdf-pages-grid');
                grid.innerHTML = '';
                
                for (let i = 1; i <= numPages; i++) {
                    setProgress(Math.round((i / numPages) * 100));
                    
                    const page = await pdf.getPage(i);
                    const scale = 1.5; // 縮圖品質
                    const viewport = page.getViewport({ scale });
                    
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = viewport.width;
                    tempCanvas.height = viewport.height;
                    const tempCtx = tempCanvas.getContext('2d');
                    
                    await page.render({
                        canvasContext: tempCtx,
                        viewport: viewport
                    }).promise;
                    
                    const imgData = tempCanvas.toDataURL('image/png');
                    state.pdfPages.push({
                        dataUrl: imgData,
                        width: viewport.width,
                        height: viewport.height,
                        selected: true
                    });
                    
                    // 創建縮圖元素
                    const item = document.createElement('div');
                    item.className = 'pdf-page-item selected';
                    item.dataset.index = i - 1;
                    item.onclick = () => togglePdfPageSelection(i - 1);
                    item.innerHTML = `
                        <img src="${imgData}" alt="Page ${i}">
                        <span class="page-num">第 ${i} 頁</span>
                        <span class="check-mark">✓</span>
                    `;
                    grid.appendChild(item);
                }
                
                hideLoading();
                document.getElementById('upload-modal').classList.add('hidden');
                document.getElementById('pdf-dialog').classList.add('show');
                
            } catch (e) {
                // console.error(e);
                hideLoading();
                toast('PDF 載入失敗: ' + e.message, 'error');
            }
        }
        
        function togglePdfPageSelection(index) {
            state.pdfPages[index].selected = !state.pdfPages[index].selected;
            
            const items = document.querySelectorAll('.pdf-page-item');
            items[index].classList.toggle('selected', state.pdfPages[index].selected);
        }
        
        function selectAllPdfPages() {
            state.pdfPages.forEach((p, i) => {
                p.selected = true;
                document.querySelectorAll('.pdf-page-item')[i].classList.add('selected');
            });
        }
        
        function deselectAllPdfPages() {
            state.pdfPages.forEach((p, i) => {
                p.selected = false;
                document.querySelectorAll('.pdf-page-item')[i].classList.remove('selected');
            });
        }
        
        function closePdfDialog() {
            document.getElementById('pdf-dialog').classList.remove('show');
        }
        
        async function quickLoadAllPdfPages() {
            // 直接載入全部頁面進入逐頁編輯模式
            if (state.pdfPages.length === 0) {
                toast('沒有可載入的頁面', 'error');
                return;
            }
            
            closePdfDialog();
            showLoading('載入全部頁面...');
            
            try {
                const allPages = state.pdfPages;
                
                // 重置所有狀態
                resetAllState();
                
                const img = await loadImageFromUrl(allPages[0].dataUrl);
                
                state.image = img;
                state.currentPdfPage = 0;
                
                canvas.width = img.width;
                canvas.height = img.height;
                ctx.drawImage(img, 0, 0);
                
                // 保存原始圖片
                state.originalImageData = canvas.toDataURL();
                
                state.history = [{
                    imageData: ctx.getImageData(0, 0, canvas.width, canvas.height),
                    regions: [],
                    timestamp: Date.now()
                }];
                state.historyNames = ['載入圖片'];
                state.historyIndex = 0;
                
                // 設置多頁 PDF 狀態
                state.pdfPages = allPages;
                state.currentPdfPage = 0;
                
                document.getElementById('upload-modal').classList.add('hidden');
                document.getElementById('btn-download').disabled = false;
                document.getElementById('btn-pptx').disabled = false;
                
                // 顯示 PDF 導航
                if (allPages.length > 1) {
                    document.getElementById('pdf-nav').classList.add('show');
                    updatePdfNavigation();
                }
                
                // 更新下載選項
                updateDownloadOptions();
                
                zoomFit();
                updatePanel();
                updateUndoButton();
                updateHistoryPanel();
                
                hideLoading();
                toast(`已載入全部 ${allPages.length} 頁，使用底部導航切換編輯`, 'success');
                
            } catch (e) {
                // console.error(e);
                hideLoading();
                toast('載入失敗: ' + e.message, 'error');
            }
        }
        
        async function applyPdfPages() {
            const mode = document.getElementById('pdf-output-mode').value;
            const selectedPages = state.pdfPages.filter(p => p.selected);
            
            if (selectedPages.length === 0) {
                toast('請至少選擇一頁', 'error');
                return;
            }
            
            closePdfDialog();
            showLoading('處理頁面中...');
            
            try {
                if (mode === 'first') {
                    // 僅載入第一頁
                    const img = new Image();
                    img.onload = () => {
                        initializeWithImage(img);
                        hideLoading();
                        toast('已載入 PDF 第一頁', 'success');
                    };
                    img.src = state.pdfPages[0].dataUrl;
                    
                } else if (mode === 'single') {
                    // 合併為單張圖片（垂直拼接）
                    const totalHeight = selectedPages.reduce((sum, p) => sum + p.height, 0);
                    const maxWidth = Math.max(...selectedPages.map(p => p.width));
                    
                    const mergedCanvas = document.createElement('canvas');
                    mergedCanvas.width = maxWidth;
                    mergedCanvas.height = totalHeight;
                    const mergedCtx = mergedCanvas.getContext('2d');
                    
                    // 白色背景
                    mergedCtx.fillStyle = '#ffffff';
                    mergedCtx.fillRect(0, 0, maxWidth, totalHeight);
                    
                    let y = 0;
                    for (let i = 0; i < selectedPages.length; i++) {
                        setProgress(Math.round((i / selectedPages.length) * 100));
                        
                        const pageData = selectedPages[i];
                        const img = await loadImageFromUrl(pageData.dataUrl);
                        const x = (maxWidth - pageData.width) / 2;
                        mergedCtx.drawImage(img, x, y);
                        y += pageData.height;
                    }
                    
                    const mergedImg = new Image();
                    mergedImg.onload = () => {
                        initializeWithImage(mergedImg);
                        hideLoading();
                        toast(`已合併 ${selectedPages.length} 頁`, 'success');
                    };
                    mergedImg.src = mergedCanvas.toDataURL('image/png');
                    
                } else {
                    // 載入選取頁面（可切換）
                    const pagesToLoad = selectedPages;
                    
                    // 重置所有狀態
                    resetAllState();
                    
                    const img = await loadImageFromUrl(pagesToLoad[0].dataUrl);
                    
                    state.image = img;
                    state.currentPdfPage = 0;
                    
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);
                    
                    // 保存原始圖片
                    state.originalImageData = canvas.toDataURL();
                    
                    state.history = [{
                        imageData: ctx.getImageData(0, 0, canvas.width, canvas.height),
                        regions: [],
                        timestamp: Date.now()
                    }];
                    state.historyNames = ['載入圖片'];
                    state.historyIndex = 0;
                    
                    // 設置多頁 PDF 狀態
                    state.pdfPages = pagesToLoad;
                    state.currentPdfPage = 0;
                    
                    document.getElementById('upload-modal').classList.add('hidden');
                    document.getElementById('btn-download').disabled = false;
                    document.getElementById('btn-pptx').disabled = false;
                    
                    // 顯示 PDF 導航
                    if (pagesToLoad.length > 1) {
                        document.getElementById('pdf-nav').classList.add('show');
                        updatePdfNavigation();
                    }
                    
                    // 更新下載選項（顯示多頁選項）
                    updateDownloadOptions();
                    
                    zoomFit();
                    updatePanel();
                    updateUndoButton();
                    updateHistoryPanel();
                    
                    hideLoading();
                    toast(`已載入 ${pagesToLoad.length} 頁，可使用底部導航切換`, 'success');
                }
                
            } catch (e) {
                // console.error(e);
                hideLoading();
                toast('處理失敗: ' + e.message, 'error');
            }
        }
        
        function loadImageFromUrl(url) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = reject;
                img.src = url;
            });
        }
        
        function updatePdfNavigation() {
            const total = state.pdfPages.length;
            const current = state.currentPdfPage + 1;
            
            document.getElementById('pdf-page-input').value = current;
            document.getElementById('pdf-page-input').max = total;
            document.getElementById('pdf-total-pages').textContent = total;
            document.getElementById('pdf-prev-btn').disabled = current <= 1;
            document.getElementById('pdf-next-btn').disabled = current >= total;
        }
        
        async function jumpToPdfPage(pageNum) {
            pageNum = parseInt(pageNum);
            if (isNaN(pageNum) || pageNum < 1 || pageNum > state.pdfPages.length) {
                updatePdfNavigation(); // 恢復顯示
                return;
            }
            
            const targetIndex = pageNum - 1;
            if (targetIndex === state.currentPdfPage) return;
            
            // 保存當前頁面的編輯狀態（使用 JPEG 減少記憶體）
            state.pdfPages[state.currentPdfPage].editedData = canvas.toDataURL('image/jpeg', 0.92);
            state.pdfPages[state.currentPdfPage].regions = JSON.parse(JSON.stringify(state.regions));
            
            state.currentPdfPage = targetIndex;
            await loadPdfPageToCanvas(state.currentPdfPage);
        }
        
        async function prevPdfPage() {
            if (state.currentPdfPage <= 0) return;
            
            // 保存當前頁面的編輯狀態（使用 JPEG 減少記憶體）
            state.pdfPages[state.currentPdfPage].editedData = canvas.toDataURL('image/jpeg', 0.92);
            state.pdfPages[state.currentPdfPage].regions = JSON.parse(JSON.stringify(state.regions));
            
            state.currentPdfPage--;
            await loadPdfPageToCanvas(state.currentPdfPage);
        }
        
        async function nextPdfPage() {
            if (state.currentPdfPage >= state.pdfPages.length - 1) return;
            
            // 保存當前頁面的編輯狀態（使用 JPEG 減少記憶體）
            state.pdfPages[state.currentPdfPage].editedData = canvas.toDataURL('image/jpeg', 0.92);
            state.pdfPages[state.currentPdfPage].regions = JSON.parse(JSON.stringify(state.regions));
            
            state.currentPdfPage++;
            await loadPdfPageToCanvas(state.currentPdfPage);
        }
        
        // 添加空白頁面
        function addBlankPage() {
            // 詢問頁面尺寸
            const dialog = document.createElement('div');
            dialog.id = 'blank-page-dialog';
            dialog.style.cssText = `
                position: fixed;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                background: #1a1a1a;
                border: 1px solid #444;
                border-radius: 12px;
                padding: 20px;
                z-index: 10001;
                min-width: 350px;
                box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            `;
            
            // 預設尺寸為當前畫布或 A4
            const defaultWidth = state.image ? canvas.width : 595;
            const defaultHeight = state.image ? canvas.height : 842;
            
            dialog.innerHTML = `
                <h3 style="margin:0 0 15px 0;display:flex;justify-content:space-between;align-items:center;">
                    <span>➕ 新增空白頁面</span>
                    <button onclick="document.getElementById('blank-page-dialog').remove()" 
                        style="background:none;border:none;color:#fff;font-size:20px;cursor:pointer;">×</button>
                </h3>
                <div style="margin-bottom:15px;">
                    <label style="display:block;margin-bottom:8px;font-size:12px;color:#aaa;">預設尺寸</label>
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;">
                        <button onclick="setBlankPageSize(595, 842)" class="btn btn-outline" style="padding:8px;">A4 直向</button>
                        <button onclick="setBlankPageSize(842, 595)" class="btn btn-outline" style="padding:8px;">A4 橫向</button>
                        <button onclick="setBlankPageSize(1920, 1080)" class="btn btn-outline" style="padding:8px;">1080p</button>
                        <button onclick="setBlankPageSize(1080, 1080)" class="btn btn-outline" style="padding:8px;">正方形</button>
                    </div>
                </div>
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-bottom:15px;">
                    <div>
                        <label style="display:block;margin-bottom:4px;font-size:12px;color:#aaa;">寬度 (px)</label>
                        <input type="number" id="blank-page-width" value="${defaultWidth}" min="100" max="5000" 
                            style="width:100%;padding:8px;background:#2a2a2a;border:1px solid #444;border-radius:6px;color:#fff;">
                    </div>
                    <div>
                        <label style="display:block;margin-bottom:4px;font-size:12px;color:#aaa;">高度 (px)</label>
                        <input type="number" id="blank-page-height" value="${defaultHeight}" min="100" max="5000" 
                            style="width:100%;padding:8px;background:#2a2a2a;border:1px solid #444;border-radius:6px;color:#fff;">
                    </div>
                </div>
                <div style="margin-bottom:15px;">
                    <label style="display:block;margin-bottom:4px;font-size:12px;color:#aaa;">背景顏色</label>
                    <input type="color" id="blank-page-color" value="#ffffff" style="width:100%;height:40px;border:none;border-radius:6px;cursor:pointer;">
                </div>
                <div style="margin-bottom:15px;">
                    <label style="display:block;margin-bottom:4px;font-size:12px;color:#aaa;">插入位置</label>
                    <select id="blank-page-position" style="width:100%;padding:8px;background:#2a2a2a;border:1px solid #444;border-radius:6px;color:#fff;">
                        <option value="after">當前頁面之後</option>
                        <option value="before">當前頁面之前</option>
                        <option value="first">文件開頭</option>
                        <option value="last">文件結尾</option>
                    </select>
                </div>
                <div style="display:flex;gap:10px;justify-content:flex-end;">
                    <button onclick="document.getElementById('blank-page-dialog').remove()" class="btn btn-outline">取消</button>
                    <button onclick="confirmAddBlankPage()" class="btn btn-primary">新增</button>
                </div>
            `;
            
            document.body.appendChild(dialog);
        }
        
        // 設定空白頁尺寸
        function setBlankPageSize(w, h) {
            document.getElementById('blank-page-width').value = w;
            document.getElementById('blank-page-height').value = h;
        }
        
        // 確認新增空白頁
        async function confirmAddBlankPage() {
            const width = parseInt(document.getElementById('blank-page-width').value);
            const height = parseInt(document.getElementById('blank-page-height').value);
            const bgColor = document.getElementById('blank-page-color').value;
            const position = document.getElementById('blank-page-position').value;
            
            document.getElementById('blank-page-dialog').remove();
            
            // 創建空白頁面
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = width;
            tempCanvas.height = height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.fillStyle = bgColor;
            tempCtx.fillRect(0, 0, width, height);
            
            const blankPageData = {
                dataUrl: tempCanvas.toDataURL('image/jpeg', 0.92),
                editedData: null,
                regions: []
            };
            
            // 保存當前頁面（使用 JPEG 減少記憶體）
            if (state.image && state.pdfPages.length > 0) {
                state.pdfPages[state.currentPdfPage].editedData = canvas.toDataURL('image/jpeg', 0.92);
                state.pdfPages[state.currentPdfPage].regions = JSON.parse(JSON.stringify(state.regions));
            }
            
            // 如果沒有頁面，先初始化並直接載入
            if (state.pdfPages.length === 0) {
                state.pdfPages = [blankPageData];
                state.currentPdfPage = 0;
                
                // 直接載入空白頁到畫布
                const img = await loadImageFromUrl(blankPageData.dataUrl);
                state.image = img;
                canvas.width = width;
                canvas.height = height;
                ctx.drawImage(img, 0, 0);
                
                // 保存原始圖片
                state.originalImageData = blankPageData.dataUrl;
                
                // 初始化歷史
                state.history = [{
                    imageData: ctx.getImageData(0, 0, canvas.width, canvas.height),
                    regions: [],
                    timestamp: Date.now(),
                    canvasWidth: width,
                    canvasHeight: height
                }];
                state.historyNames = ['新增空白頁'];
                state.historyIndex = 0;
                state.regions = [];
                
                fitCanvasToScreen();
                enableTools();
            } else {
                // 根據位置插入
                let insertIndex;
                switch (position) {
                    case 'before':
                        insertIndex = state.currentPdfPage;
                        break;
                    case 'first':
                        insertIndex = 0;
                        break;
                    case 'last':
                        insertIndex = state.pdfPages.length;
                        break;
                    case 'after':
                    default:
                        insertIndex = state.currentPdfPage + 1;
                        break;
                }
                
                state.pdfPages.splice(insertIndex, 0, blankPageData);
                state.currentPdfPage = insertIndex;
                
                // 載入新頁面
                await loadPdfPageToCanvas(state.currentPdfPage);
            }
            
            // 顯示 PDF 導航
            document.getElementById('pdf-nav').style.display = 'flex';
            document.getElementById('btn-download-all').style.display = 'block';
            document.getElementById('btn-download-pdf').style.display = 'block';
            updatePdfNav();
            
            toast('已新增空白頁面 (' + width + '×' + height + ')', 'success');
        }
        
        // 刪除當前頁面
        function deleteCurrentPage() {
            if (state.pdfPages.length <= 1) {
                toast('至少需保留一個頁面', 'warning');
                return;
            }
            
            // 確認對話框
            const dialog = document.createElement('div');
            dialog.id = 'delete-page-dialog';
            dialog.style.cssText = `
                position: fixed;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                background: #1a1a1a;
                border: 1px solid #444;
                border-radius: 12px;
                padding: 20px;
                z-index: 10001;
                min-width: 320px;
                box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            `;
            
            dialog.innerHTML = `
                <h3 style="margin:0 0 15px 0;color:#ff6b6b;">⚠️ 確認刪除</h3>
                <p style="margin-bottom:20px;color:#ccc;">確定要刪除第 ${state.currentPdfPage + 1} 頁嗎？此操作無法復原。</p>
                <div style="display:flex;gap:10px;justify-content:flex-end;">
                    <button onclick="document.getElementById('delete-page-dialog').remove()" class="btn btn-outline">取消</button>
                    <button onclick="confirmDeletePage()" class="btn" style="background:#ff4444;color:white;">刪除</button>
                </div>
            `;
            
            document.body.appendChild(dialog);
        }
        
        // 確認刪除頁面
        async function confirmDeletePage() {
            document.getElementById('delete-page-dialog').remove();
            
            const deletedIndex = state.currentPdfPage;
            state.pdfPages.splice(deletedIndex, 1);
            
            // 調整當前頁面索引
            if (state.currentPdfPage >= state.pdfPages.length) {
                state.currentPdfPage = state.pdfPages.length - 1;
            }
            
            // 載入新的當前頁面
            await loadPdfPageToCanvas(state.currentPdfPage);
            
            // 如果只剩一頁，隱藏部分 UI
            if (state.pdfPages.length === 1) {
                document.getElementById('btn-download-all').style.display = 'none';
            }
            
            toast(`已刪除第 ${deletedIndex + 1} 頁`, 'info');
        }
        
        async function loadPdfPageToCanvas(index) {
            const pageData = state.pdfPages[index];
            const imgUrl = pageData.editedData || pageData.dataUrl;
            
            const img = await loadImageFromUrl(imgUrl);
            state.image = img;
            
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            
            // 保存原始圖片（用於前後對照比較）
            // 如果有編輯過的數據，使用原始 dataUrl；否則使用當前畫布
            state.originalImageData = pageData.dataUrl;
            
            // 恢復該頁的 regions（如果有）
            state.regions = pageData.regions ? JSON.parse(JSON.stringify(pageData.regions)) : [];
            state.activeRegion = null;
            
            // 重置歷史
            state.history = [{
                imageData: ctx.getImageData(0, 0, canvas.width, canvas.height),
                regions: JSON.parse(JSON.stringify(state.regions)),
                timestamp: Date.now()
            }];
            state.historyNames = ['切換頁面'];
            state.historyIndex = 0;
            
            zoomFit();
            renderRegions();
            updatePanel();
            updateUndoButton();
            updateHistoryPanel();
            updatePdfNavigation();
        }
        
        // ============ PPTX 輸出 ============
        
        async function downloadPptx() {
            if (!state.image) {
                toast('請先載入圖片', 'error');
                return;
            }
            
            showLoading('載入 PPTX 引擎中...');
            
            // 延遲載入 PptxGenJS
            const loaded = await loadPptxGenJS();
            if (!loaded) {
                hideLoading();
                toast('無法載入 PPTX 引擎', 'error');
                return;
            }
            
            showLoading('生成 PPTX 中...');
            
            try {
                const pptx = new PptxGenJS();
                
                // 計算投影片尺寸（英寸）
                const slideWidth = 13.33; // 標準寬螢幕寬度
                const imgRatio = canvas.width / canvas.height;
                const slideHeight = slideWidth / imgRatio;
                
                pptx.defineLayout({ name: 'CUSTOM', width: slideWidth, height: slideHeight });
                pptx.layout = 'CUSTOM';
                
                // 像素到英寸的轉換比例
                const pxToInch = slideWidth / canvas.width;
                
                // 如果有多頁 PDF
                if (state.pdfPages.length > 1) {
                    // 保存當前頁面編輯（使用 JPEG 減少記憶體）
                    state.pdfPages[state.currentPdfPage].editedData = canvas.toDataURL('image/jpeg', 0.92);
                    state.pdfPages[state.currentPdfPage].regions = JSON.parse(JSON.stringify(state.regions));
                    
                    for (let i = 0; i < state.pdfPages.length; i++) {
                        setProgress(Math.round((i / state.pdfPages.length) * 100));
                        
                        const pageData = state.pdfPages[i];
                        const pageRegions = pageData.regions || [];
                        const slide = pptx.addSlide();
                        
                        // 創建背景圖片（清除已編輯的文字區域）
                        const img = await loadImageFromUrl(pageData.editedData || pageData.dataUrl);
                        const bgCanvas = document.createElement('canvas');
                        bgCanvas.width = img.width;
                        bgCanvas.height = img.height;
                        const bgCtx = bgCanvas.getContext('2d');
                        bgCtx.drawImage(img, 0, 0);
                        
                        // 計算此頁的轉換比例
                        const pagePxToInch = slideWidth / img.width;
                        
                        // 用背景色清除已編輯的文字區域（為了添加可編輯文字方塊）
                        for (const r of pageRegions) {
                            if (r.edited && r.text.trim()) {
                                const pad = r.padding || 5;
                                // 透明背景模式也需要清除（因為要用文字方塊替代）
                                bgCtx.fillStyle = r.bgColor;
                                bgCtx.fillRect(
                                    Math.max(0, r.x - pad),
                                    Math.max(0, r.y - pad),
                                    r.w + pad * 2,
                                    r.h + pad * 2
                                );
                            }
                        }
                        
                        // 添加背景圖片
                        slide.addImage({
                            data: bgCanvas.toDataURL('image/png'),
                            x: 0,
                            y: 0,
                            w: '100%',
                            h: '100%'
                        });
                        
                        // 添加可編輯文字方塊（透明背景的文字方塊不會有背景色）
                        for (const r of pageRegions) {
                            if (r.edited && r.text.trim()) {
                                addTextBoxToSlide(slide, r, pagePxToInch);
                            }
                        }
                    }
                } else {
                    // 單張圖片
                    const slide = pptx.addSlide();
                    
                    // 創建背景圖片（清除已編輯的文字區域）
                    const bgCanvas = document.createElement('canvas');
                    bgCanvas.width = canvas.width;
                    bgCanvas.height = canvas.height;
                    const bgCtx = bgCanvas.getContext('2d');
                    
                    // 複製原始 canvas
                    bgCtx.drawImage(canvas, 0, 0);
                    
                    // 用背景色清除已編輯的文字區域（為了添加可編輯文字方塊）
                    for (const r of state.regions) {
                        if (r.edited && r.text.trim()) {
                            const pad = r.padding || 5;
                            // 透明背景模式也需要清除（因為要用文字方塊替代）
                            bgCtx.fillStyle = r.bgColor;
                            bgCtx.fillRect(
                                Math.max(0, r.x - pad),
                                Math.max(0, r.y - pad),
                                r.w + pad * 2,
                                r.h + pad * 2
                            );
                        }
                    }
                    
                    // 添加背景圖片
                    slide.addImage({
                        data: bgCanvas.toDataURL('image/png'),
                        x: 0,
                        y: 0,
                        w: '100%',
                        h: '100%'
                    });
                    
                    // 添加可編輯的文字方塊（透明背景的文字方塊不會有背景色）
                    for (const r of state.regions) {
                        if (r.edited && r.text.trim()) {
                            addTextBoxToSlide(slide, r, pxToInch);
                        }
                    }
                }
                
                // 下載
                await pptx.writeFile({ fileName: 'edited-image.pptx' });
                
                hideLoading();
                toast('PPTX 已下載（文字區域可編輯）', 'success');
                
            } catch (e) {
                // console.error(e);
                hideLoading();
                toast('PPTX 生成失敗: ' + e.message, 'error');
            }
        }
        
        // 添加可編輯文字方塊到投影片
        function addTextBoxToSlide(slide, r, pxToInch) {
            // 轉換座標和尺寸為英寸
            const x = r.x * pxToInch;
            const y = r.y * pxToInch;
            const w = r.w * pxToInch;
            const h = r.h * pxToInch;
            
            // 轉換字體大小
            // pxToInch 是從原圖像素到投影片英寸的比例
            // 字體大小（點數）= 像素大小 × pxToInch × 72（1英寸=72點）
            const fontSizePt = Math.round(r.fontSize * pxToInch * 72);
            
            // 解析顏色（移除 # 符號）
            const textColor = r.color.replace('#', '');
            const bgColor = r.bgColor === 'transparent' ? null : r.bgColor.replace('#', '');
            
            // 字體對應
            const fontFaceMap = {
                'Inter': 'Arial',
                'Noto Sans TC': 'Microsoft JhengHei',
                'Noto Serif TC': 'PMingLiU',
                'Microsoft JhengHei': 'Microsoft JhengHei',
                'PMingLiU': 'PMingLiU',
                'Arial': 'Arial',
                'Times New Roman': 'Times New Roman'
            };
            const fontFace = fontFaceMap[r.fontFamily] || 'Arial';
            
            // 對齊方式
            const alignMap = {
                'left': 'left',
                'center': 'center',
                'right': 'right'
            };
            
            // 字重對應
            const isBold = r.fontWeight === 'bold' || parseInt(r.fontWeight) >= 600;
            
            // 檢查文字是否包含換行符
            const hasLineBreaks = r.text.includes('\n');
            
            // 建立文字選項
            const textOptions = {
                x: x,
                y: y,
                w: w,
                h: h,
                fontSize: fontSizePt,
                fontFace: fontFace,
                color: textColor,
                bold: isBold,
                align: alignMap[r.textAlign] || 'left',
                valign: 'middle',
                wrap: hasLineBreaks,  // 只有包含換行符時才啟用換行
                shrinkText: true,     // 自動縮小文字以適應方塊
                lineSpacingMultiple: r.lineHeight || 1.2
            };
            
            // 透明背景模式不添加背景色
            if (!r.transparentBg && bgColor) {
                textOptions.fill = { color: bgColor };
            }
            
            // 添加描邊（如果有）
            if (r.strokeWidth > 0) {
                textOptions.outline = {
                    size: r.strokeWidth,
                    color: (r.strokeColor || '#000000').replace('#', '')
                };
            }
            
            // 添加陰影（如果有）
            if (r.shadowBlur > 0) {
                textOptions.shadow = {
                    type: 'outer',
                    blur: r.shadowBlur,
                    offset: Math.max(r.shadowOffsetX || 0, r.shadowOffsetY || 0),
                    angle: 45,
                    color: (r.shadowColor || '#000000').replace('#', ''),
                    opacity: 0.5
                };
            }
            
            // 處理漸層文字（PPTX 不直接支援，使用起始顏色）
            if (r.gradientEnabled) {
                textOptions.color = (r.gradientColor1 || '#ff0000').replace('#', '');
            }
            
            // 添加文字方塊
            slide.addText(r.text, textOptions);
        }

        function zoomFit() {
            if (!state.image) return;
            
            const wrapperRect = canvasWrapper.getBoundingClientRect();
            const padding = 40;
            const availableW = wrapperRect.width - padding * 2;
            const availableH = wrapperRect.height - padding * 2;
            
            const scaleW = availableW / canvas.width;
            const scaleH = availableH / canvas.height;
            state.displayScale = Math.min(scaleW, scaleH, 1); // 不超過 100%
            
            canvasContainer.style.transform = `scale(${state.displayScale})`;
            
            updateZoomDisplay();
            
            renderRegions();
        }
        
        // 顯示縮放右鍵選單
        function showZoomContextMenu(e) {
            // 移除已存在的選單
            const existingMenu = document.getElementById('zoom-context-menu');
            if (existingMenu) existingMenu.remove();
            
            // 記錄點擊位置（相對於 canvas 的位置）
            const containerRect = canvasContainer.getBoundingClientRect();
            const clickX = (e.clientX - containerRect.left) / state.displayScale;
            const clickY = (e.clientY - containerRect.top) / state.displayScale;
            
            // 建立選單
            const menu = document.createElement('div');
            menu.id = 'zoom-context-menu';
            menu.style.cssText = `
                position: fixed;
                left: ${e.clientX}px;
                top: ${e.clientY}px;
                background: #1a1a1a;
                border: 1px solid #444;
                border-radius: 8px;
                padding: 6px 0;
                z-index: 10000;
                box-shadow: 0 4px 20px rgba(0,0,0,0.5);
                min-width: 180px;
            `;
            
            const currentZoom = Math.round(state.displayScale * 100);
            
            const menuItems = [
                { label: `🔍 目前: ${currentZoom}%`, disabled: true },
                { divider: true },
                { label: '📍 以此點放大 400%', action: () => zoomToPoint(clickX, clickY, 4) },
                { label: '📍 以此點放大 300%', action: () => zoomToPoint(clickX, clickY, 3) },
                { label: '📍 以此點放大 200%', action: () => zoomToPoint(clickX, clickY, 2) },
                { label: '📍 以此點放大 150%', action: () => zoomToPoint(clickX, clickY, 1.5) },
                { label: '📍 以此點放大 100%', action: () => zoomToPoint(clickX, clickY, 1) },
                { label: '📍 以此點放大 75%', action: () => zoomToPoint(clickX, clickY, 0.75) },
                { label: '📍 以此點放大 50%', action: () => zoomToPoint(clickX, clickY, 0.5) },
                { divider: true },
                { label: '➕ 放大 (+10%)', action: () => zoomToPoint(clickX, clickY, state.displayScale + 0.1) },
                { label: '➖ 縮小 (-10%)', action: () => zoomToPoint(clickX, clickY, Math.max(0.05, state.displayScale - 0.1)) },
                { divider: true },
                { label: '🔲 適合視窗', action: () => { zoomFit(); closeZoomContextMenu(); } },
            ];
            
            menuItems.forEach(item => {
                if (item.divider) {
                    const divider = document.createElement('div');
                    divider.style.cssText = 'height: 1px; background: #333; margin: 4px 8px;';
                    menu.appendChild(divider);
                } else {
                    const menuItem = document.createElement('div');
                    menuItem.textContent = item.label;
                    menuItem.style.cssText = `
                        padding: 8px 16px;
                        font-size: 13px;
                        cursor: ${item.disabled ? 'default' : 'pointer'};
                        color: ${item.disabled ? '#666' : '#ddd'};
                        transition: background 0.15s;
                    `;
                    if (!item.disabled) {
                        menuItem.onmouseenter = () => menuItem.style.background = '#333';
                        menuItem.onmouseleave = () => menuItem.style.background = 'transparent';
                        menuItem.onclick = () => {
                            item.action();
                            closeZoomContextMenu();
                        };
                    }
                    menu.appendChild(menuItem);
                }
            });
            
            document.body.appendChild(menu);
            
            // 確保選單不超出視窗
            const menuRect = menu.getBoundingClientRect();
            if (menuRect.right > window.innerWidth) {
                menu.style.left = (window.innerWidth - menuRect.width - 10) + 'px';
            }
            if (menuRect.bottom > window.innerHeight) {
                menu.style.top = (window.innerHeight - menuRect.height - 10) + 'px';
            }
            
            // 點擊其他地方關閉選單
            setTimeout(() => {
                document.addEventListener('click', closeZoomContextMenu);
                document.addEventListener('contextmenu', closeZoomContextMenuOnRightClick);
            }, 10);
        }
        
        function closeZoomContextMenu() {
            const menu = document.getElementById('zoom-context-menu');
            if (menu) menu.remove();
            document.removeEventListener('click', closeZoomContextMenu);
            document.removeEventListener('contextmenu', closeZoomContextMenuOnRightClick);
        }
        
        function closeZoomContextMenuOnRightClick(e) {
            const menu = document.getElementById('zoom-context-menu');
            if (menu && !menu.contains(e.target)) {
                closeZoomContextMenu();
            }
        }
        
        // 以指定點為中心縮放到指定比例
        function zoomToPoint(pointX, pointY, targetScale) {
            if (!state.image) return;
            
            targetScale = Math.max(0.05, Math.min(10, targetScale));  // 最小 5%，最大 1000%
            
            // 取得 wrapper 的尺寸
            const wrapperRect = canvasWrapper.getBoundingClientRect();
            const wrapperCenterX = wrapperRect.width / 2;
            const wrapperCenterY = wrapperRect.height / 2;
            
            // 更新縮放
            state.displayScale = targetScale;
            canvasContainer.style.transform = `scale(${state.displayScale})`;
            updateZoomDisplay();
            
            // 計算需要的捲軸位置，讓指定點位於視窗中心
            requestAnimationFrame(() => {
                // 指定點在縮放後的位置
                const scaledPointX = pointX * state.displayScale;
                const scaledPointY = pointY * state.displayScale;
                
                // 計算捲軸位置，讓指定點位於視窗中心
                const newScrollLeft = scaledPointX - wrapperCenterX;
                const newScrollTop = scaledPointY - wrapperCenterY;
                
                canvasWrapper.scrollLeft = Math.max(0, newScrollLeft);
                canvasWrapper.scrollTop = Math.max(0, newScrollTop);
                
                renderRegions();
            });
            
            toast(`縮放至 ${Math.round(targetScale * 100)}%`, 'info');
        }
        
        // 設定縮放比例（不改變中心點）
        function setZoom(scale) {
            if (!state.image) return;
            
            scale = Math.max(0.05, Math.min(10, scale));  // 最小 5%，最大 1000%
            state.displayScale = scale;
            canvasContainer.style.transform = `scale(${state.displayScale})`;
            updateZoomDisplay();
            renderRegions();
        }
        
        // 從滑軌設定縮放
        function setZoomFromSlider(value) {
            if (!state.image) return;
            
            const scale = value / 100;
            state.displayScale = Math.max(0.05, Math.min(10, scale));
            canvasContainer.style.transform = `scale(${state.displayScale})`;
            document.getElementById('zoom-info').textContent = `${Math.round(state.displayScale * 100)}%`;
            renderRegions();
        }
        
        // 更新縮放顯示（滑軌和文字）
        function updateZoomDisplay() {
            const percent = Math.round(state.displayScale * 100);
            document.getElementById('zoom-info').textContent = `${percent}%`;
            const slider = document.getElementById('zoom-slider');
            if (slider) {
                // 限制滑軌範圍內的值
                slider.value = Math.min(500, Math.max(5, percent));
            }
        }
        
        // 顯示縮放下拉選單
        function showZoomDropdown(e) {
            e.stopPropagation();
            
            // 移除已存在的選單
            const existingMenu = document.getElementById('zoom-dropdown-menu');
            if (existingMenu) {
                existingMenu.remove();
                return;
            }
            
            const rect = e.target.getBoundingClientRect();
            
            const menu = document.createElement('div');
            menu.id = 'zoom-dropdown-menu';
            menu.style.cssText = `
                position: fixed;
                left: ${rect.left}px;
                top: ${rect.bottom + 5}px;
                background: #1a1a1a;
                border: 1px solid #444;
                border-radius: 8px;
                padding: 6px 0;
                z-index: 10000;
                box-shadow: 0 4px 20px rgba(0,0,0,0.5);
                min-width: 100px;
            `;
            
            const zoomLevels = [
                { label: '1000%', value: 10 },
                { label: '800%', value: 8 },
                { label: '600%', value: 6 },
                { label: '500%', value: 5 },
                { label: '400%', value: 4 },
                { label: '300%', value: 3 },
                { label: '200%', value: 2 },
                { label: '150%', value: 1.5 },
                { label: '125%', value: 1.25 },
                { label: '100%', value: 1 },
                { label: '75%', value: 0.75 },
                { label: '50%', value: 0.5 },
                { label: '33%', value: 0.33 },
                { label: '25%', value: 0.25 },
                { label: '10%', value: 0.1 },
                { divider: true },
                { label: '🔲 適合視窗', action: zoomFit }
            ];
            
            zoomLevels.forEach(item => {
                if (item.divider) {
                    const divider = document.createElement('div');
                    divider.style.cssText = 'height: 1px; background: #333; margin: 4px 8px;';
                    menu.appendChild(divider);
                } else {
                    const menuItem = document.createElement('div');
                    const isActive = item.value && Math.abs(state.displayScale - item.value) < 0.01;
                    menuItem.textContent = item.label;
                    menuItem.style.cssText = `
                        padding: 8px 16px;
                        font-size: 13px;
                        cursor: pointer;
                        color: ${isActive ? '#6366f1' : '#ddd'};
                        font-weight: ${isActive ? '600' : '400'};
                        transition: background 0.15s;
                    `;
                    menuItem.onmouseenter = () => menuItem.style.background = '#333';
                    menuItem.onmouseleave = () => menuItem.style.background = 'transparent';
                    menuItem.onclick = () => {
                        if (item.action) {
                            item.action();
                        } else {
                            setZoom(item.value);
                        }
                        menu.remove();
                    };
                    menu.appendChild(menuItem);
                }
            });
            
            document.body.appendChild(menu);
            
            // 點擊其他地方關閉選單
            setTimeout(() => {
                document.addEventListener('click', function closeZoomDropdown(evt) {
                    if (!menu.contains(evt.target)) {
                        menu.remove();
                        document.removeEventListener('click', closeZoomDropdown);
                    }
                });
            }, 10);
        }

        function setMode(mode) {
            state.mode = mode;
            
            // 關閉所有工具群組選單
            document.querySelectorAll('.tool-submenu').forEach(menu => {
                menu.classList.remove('show');
            });
            
            // 更新按鈕狀態
            const modes = ['select', 'region', 'imageSelect', 'lasso', 'magicwand', 'eyedropper', 'crop', 'clone', 'text', 'brush', 'airbrush', 'highlighter', 'pencil', 'eraser', 'fill', 'gradient', 'shape', 'arrow', 'marker', 'mosaic', 'blur'];
            modes.forEach(m => {
                const btn = document.getElementById('mode-' + m);
                if (btn) btn.classList.toggle('active', mode === m);
                // 也更新子選單中的按鈕
                const subBtn = document.getElementById('mode-' + m + '-sub');
                if (subBtn) subBtn.classList.toggle('active', mode === m);
            });
            
            // 更新群組主按鈕的狀態
            const groupMappings = {
                'select-group': ['select', 'region', 'imageSelect', 'lasso', 'magicwand', 'crop'],
                'draw-group': ['brush', 'airbrush', 'highlighter', 'pencil', 'eraser', 'clone'],
                'shape-group': ['shape', 'arrow', 'marker', 'text'],
                'fill-group': ['fill', 'gradient', 'eyedropper'],
                'effect-group': ['mosaic', 'blur']
            };
            
            Object.entries(groupMappings).forEach(([groupId, groupModes]) => {
                const group = document.getElementById(groupId);
                if (group) {
                    const parentBtn = group.parentElement.querySelector('.tool-btn');
                    if (parentBtn) {
                        parentBtn.classList.toggle('active', groupModes.includes(mode));
                    }
                }
            });
            
            const modeTag = document.getElementById('mode-tag');
            const modeTexts = {
                'select': '',
                'region': '框選模式：拖曳選取區域',
                'imageSelect': '矩形圖選：框選區域可移動縮放',
                'lasso': '套索選取：點擊添加點，點擊綠點或按 Enter 閉合',
                'magicwand': '魔術棒：點擊選取相似顏色區域',
                'eyedropper': '取色模式：點擊圖片吸取顏色',
                'crop': '裁切模式：調整裁切範圍',
                'clone': '克隆圖章：Alt+點擊設定來源，再塗抹複製',
                'text': '文字工具：點擊位置輸入文字',
                'brush': '畫筆模式：按住滑鼠繪畫',
                'airbrush': '噴槍模式：按住滑鼠噴灑顏色',
                'highlighter': '螢光筆：按住滑鼠標記文字',
                'pencil': '鉛筆模式：按住滑鼠繪製細線',
                'eraser': '橡皮擦：按住滑鼠擦除內容',
                'fill': '油漆桶：點擊填充相似顏色區域',
                'gradient': '漸層填充：拖曳繪製漸層方向',
                'shape': '形狀模式：拖曳繪製形狀',
                'arrow': '箭頭模式：拖曳繪製箭頭',
                'marker': '標記模式：點擊放置標記',
                'mosaic': '馬賽克模式：按住滑鼠塗抹',
                'blur': '模糊模式：按住滑鼠塗抹模糊'
            };
            modeTag.textContent = modeTexts[mode] || '';
            modeTag.style.display = mode !== 'select' ? 'inline-block' : 'none';
            
            // 設置游標樣式
            canvas.classList.remove('crosshair', 'eyedropper-cursor', 'magicwand-cursor', 'brush-cursor', 'clone-cursor', 'text-cursor', 'fill-cursor');
            canvasContainer.classList.remove('eyedropper-cursor', 'magicwand-cursor', 'brush-cursor', 'clone-cursor', 'text-cursor', 'fill-cursor');
            
            if (mode === 'region' || mode === 'imageSelect' || mode === 'lasso' || mode === 'shape' || mode === 'arrow' || mode === 'crop' || mode === 'gradient') canvas.classList.add('crosshair');
            if (mode === 'eyedropper') {
                canvas.classList.add('eyedropper-cursor');
                canvasContainer.classList.add('eyedropper-cursor');
            }
            if (mode === 'magicwand' || mode === 'marker') {
                canvas.classList.add('magicwand-cursor');
                canvasContainer.classList.add('magicwand-cursor');
            }
            if (mode === 'brush' || mode === 'airbrush' || mode === 'highlighter' || mode === 'pencil' || mode === 'mosaic' || mode === 'blur' || mode === 'eraser') {
                canvas.classList.add('brush-cursor');
                canvasContainer.classList.add('brush-cursor');
            }
            if (mode === 'clone') {
                canvas.classList.add('clone-cursor');
                canvasContainer.classList.add('clone-cursor');
            }
            if (mode === 'text') {
                canvas.classList.add('text-cursor');
                canvasContainer.classList.add('text-cursor');
            }
            if (mode === 'fill') {
                canvas.classList.add('fill-cursor');
                canvasContainer.classList.add('fill-cursor');
            }
            
            // 在特定模式下，讓滑鼠事件穿透 regionsLayer
            const regionsLayer = document.getElementById('regions-layer');
            const drawModes = ['region', 'imageSelect', 'lasso', 'eyedropper', 'magicwand', 'brush', 'eraser', 'fill', 'gradient', 'text', 'shape', 'arrow', 'marker', 'mosaic', 'blur', 'crop', 'clone'];
            if (drawModes.includes(mode)) {
                regionsLayer.style.pointerEvents = 'none';
            } else {
                regionsLayer.style.pointerEvents = 'auto';
            }
            
            // 清除套索路徑
            if (mode !== 'lasso') {
                clearLassoPath();
            }
            
            // 隱藏所有工具設定面板
            document.getElementById('clone-settings').style.display = 'none';
            document.getElementById('eraser-settings').style.display = 'none';
            document.getElementById('fill-settings').style.display = 'none';
            document.getElementById('gradient-settings').style.display = 'none';
            
            // 隱藏克隆來源標記
            if (mode !== 'clone') {
                document.getElementById('clone-source-marker').style.display = 'none';
                cloneSource = null;
            }
            
            // 顯示對應的工具設定面板
            if (mode === 'clone') {
                document.getElementById('clone-settings').style.display = 'flex';
            } else if (mode === 'eraser') {
                document.getElementById('eraser-settings').style.display = 'flex';
            } else if (mode === 'fill') {
                document.getElementById('fill-settings').style.display = 'flex';
            } else if (mode === 'gradient') {
                document.getElementById('gradient-settings').style.display = 'flex';
            }
            
            // 裁切模式初始化
            if (mode === 'crop') {
                initCrop();
            } else if (state.cropMode) {
                cancelCrop();
            }
            
            // 更新面板顯示繪圖工具設定
            updatePanel();
        }

        function onMouseDown(e) {
            // 如果正在空白鍵拖拉畫布，跳過
            if (isSpacePressed || isPanning) return;
            
            // 檢查是否點擊在 canvas 區域內
            if (!state.image) return;
            
            // 只處理左鍵
            if (e.button !== 0) return;
            
            // 圖層拖拉模式優先處理
            if (layerDragMode && isPreviewMode) {
                e.preventDefault();
                e.stopPropagation();
                startLayerDrag(e);
                return;
            }
            
            const rect = canvasContainer.getBoundingClientRect();
            const x = (e.clientX - rect.left) / state.displayScale;
            const y = (e.clientY - rect.top) / state.displayScale;
            
            // 取色器模式
            if (state.mode === 'eyedropper') {
                e.preventDefault();
                e.stopPropagation();
                pickColor(x, y);
                return;
            }
            
            // 魔術棒模式
            if (state.mode === 'magicwand') {
                e.preventDefault();
                e.stopPropagation();
                magicWandSelect(Math.round(x), Math.round(y));
                return;
            }
            
            // 畫筆模式
            if (state.mode === 'brush') {
                e.preventDefault();
                e.stopPropagation();
                saveHistory('畫筆');
                state.isDrawing = true;
                state.lastPoint = { x, y };
                drawBrushPoint(x, y);
                return;
            }
            
            // 噴槍模式
            if (state.mode === 'airbrush') {
                e.preventDefault();
                e.stopPropagation();
                saveHistory('噴槍');
                state.isDrawing = true;
                state.lastPoint = { x, y };
                drawAirbrush(x, y);
                // 開始連續噴灑
                state.airbrushInterval = setInterval(() => {
                    if (state.isDrawing && state.lastPoint) {
                        drawAirbrush(state.lastPoint.x, state.lastPoint.y);
                    }
                }, 50);
                return;
            }
            
            // 螢光筆模式
            if (state.mode === 'highlighter') {
                e.preventDefault();
                e.stopPropagation();
                saveHistory('螢光筆');
                state.isDrawing = true;
                state.lastPoint = { x, y };
                return;
            }
            
            // 鉛筆模式
            if (state.mode === 'pencil') {
                e.preventDefault();
                e.stopPropagation();
                saveHistory('鉛筆');
                state.isDrawing = true;
                state.lastPoint = { x, y };
                drawPencilPoint(x, y);
                return;
            }
            
            // 馬賽克模式
            if (state.mode === 'mosaic') {
                e.preventDefault();
                e.stopPropagation();
                saveHistory('馬賽克');
                state.isDrawing = true;
                state.lastPoint = { x, y };
                applyMosaic(x, y);
                return;
            }
            
            // 模糊模式
            if (state.mode === 'blur') {
                e.preventDefault();
                e.stopPropagation();
                saveHistory('模糊');
                state.isDrawing = true;
                state.lastPoint = { x, y };
                applyBlur(x, y);
                return;
            }
            
            // 克隆圖章模式
            if (state.mode === 'clone') {
                e.preventDefault();
                e.stopPropagation();
                initCloneStamp(e);
                return;
            }
            
            // 文字工具模式
            if (state.mode === 'text') {
                e.preventDefault();
                e.stopPropagation();
                
                // 檢查是否點擊在現有文字物件上（讓 overlay 處理拖拉）
                const clickedOnText = textObjects.some(obj => {
                    return x >= obj.x && x <= obj.x + obj.width &&
                           y >= obj.y && y <= obj.y + obj.height;
                });
                
                // 如果點擊在現有文字上，不打開輸入介面
                if (clickedOnText) {
                    return;
                }
                
                openTextTool(x, y);
                return;
            }
            
            // 橡皮擦模式
            if (state.mode === 'eraser') {
                e.preventDefault();
                e.stopPropagation();
                
                // Alt+點擊取色（取色塗抹模式或自訂顏色模式）
                if (e.altKey && (state.eraserMode === 'pick' || state.eraserMode === 'color')) {
                    handleEraserColorPick(x, y);
                    return;
                }
                
                // 如果正在取色模式
                if (state.eraserPickingColor) {
                    handleEraserColorPick(x, y);
                    return;
                }
                
                saveHistory('橡皮擦');
                state.isDrawing = true;
                state.lastPoint = { x, y };
                doEraser(x, y);
                return;
            }
            
            // 油漆桶填充模式
            if (state.mode === 'fill') {
                e.preventDefault();
                e.stopPropagation();
                saveHistory('油漆桶填充');
                doFloodFill(Math.round(x), Math.round(y));
                return;
            }
            
            // 漸層填充模式
            if (state.mode === 'gradient') {
                e.preventDefault();
                e.stopPropagation();
                
                // 檢查是否點擊在現有漸層區塊上
                const clickedOnGradient = gradientObjects.some(obj => {
                    return x >= obj.x && x <= obj.x + obj.width &&
                           y >= obj.y && y <= obj.y + obj.height;
                });
                
                // 如果點擊在現有區塊上，不創建新的（讓 overlay 處理拖拉）
                if (clickedOnGradient) {
                    return;
                }
                
                state.isSelecting = true;
                state.gradientStart = { x, y };
                state.selStart = { x, y }; // 需要設置 selStart 讓 onMouseMove 正常工作
                
                // 顯示漸層預覽框
                selectRect.style.left = x + 'px';
                selectRect.style.top = y + 'px';
                selectRect.style.width = '0';
                selectRect.style.height = '0';
                selectRect.style.display = 'block';
                selectRect.style.borderColor = state.gradientColor1 || '#ff0000';
                selectRect.style.background = 'linear-gradient(135deg, ' + (state.gradientColor1 || '#ff0000') + '40, ' + (state.gradientColor2 || '#0000ff') + '40)';
                return;
            }
            
            // 形狀模式
            if (state.mode === 'shape') {
                e.preventDefault();
                e.stopPropagation();
                saveHistory('形狀');
                state.isSelecting = true;
                state.selStart = { x, y };
                
                selectRect.style.left = x + 'px';
                selectRect.style.top = y + 'px';
                selectRect.style.width = '0';
                selectRect.style.height = '0';
                selectRect.style.display = 'block';
                selectRect.style.borderColor = state.shapeStrokeColor;
                selectRect.style.background = 'transparent';
                return;
            }
            
            // 箭頭模式
            if (state.mode === 'arrow') {
                e.preventDefault();
                e.stopPropagation();
                saveHistory('箭頭');
                state.isSelecting = true;
                state.arrowStart = { x, y };
                return;
            }
            
            // 標記模式
            if (state.mode === 'marker') {
                e.preventDefault();
                e.stopPropagation();
                saveHistory('標記');
                drawMarker(x, y, state.markerType, state.markerColor, state.markerSize, state.markerFilled, state.markerNumber);
                if (state.markerType === 'number') {
                    state.markerNumber++;
                }
                // 更新 state.image
                const newImg = new Image();
                newImg.src = canvas.toDataURL();
                state.image = newImg;
                return;
            }
            
            // 框選模式
            if (state.mode === 'region' || state.mode === 'imageSelect') {
                e.preventDefault();
                e.stopPropagation();
                
                state.isSelecting = true;
                state.selStart = { x, y };
                
                // selectRect 在 canvasContainer 內，不需要乘以 displayScale
                selectRect.style.left = x + 'px';
                selectRect.style.top = y + 'px';
                selectRect.style.width = '0';
                selectRect.style.height = '0';
                selectRect.style.display = 'block';
                
                // 不同模式不同顏色
                if (state.mode === 'imageSelect') {
                    selectRect.style.borderColor = '#f59e0b';
                    selectRect.style.background = 'rgba(245, 158, 11, 0.15)';
                } else {
                    selectRect.style.borderColor = '#6366f1';
                    selectRect.style.background = 'rgba(99, 102, 241, 0.15)';
                }
            }
            
            // 套索模式 - 點擊添加點
            if (state.mode === 'lasso') {
                e.preventDefault();
                e.stopPropagation();
                
                // 檢查是否點擊起始點（閉合路徑）
                if (state.lassoPath.length >= 3) {
                    const firstPoint = state.lassoPath[0];
                    const dist = Math.sqrt(Math.pow(x - firstPoint.x, 2) + Math.pow(y - firstPoint.y, 2));
                    
                    // 如果點擊靠近起始點（20px 內），閉合選取
                    if (dist < 20) {
                        processLassoSelect();
                        clearLassoPath();
                        return;
                    }
                }
                
                // 添加新的點
                state.lassoPath.push({ x, y });
                
                // 創建或更新套索路徑 SVG
                if (state.lassoPath.length === 1) {
                    createLassoPathSVG();
                }
                updateLassoPathSVG();
            }
        }

        function onMouseMove(e) {
            // 如果正在空白鍵拖拉畫布，跳過
            if (isSpacePressed || isPanning) return;
            
            // 圖層拖拉模式
            if (layerDragMode && draggingLayerIndex >= 0) {
                doLayerDrag(e);
                return;
            }
            
            const rect = canvasContainer.getBoundingClientRect();
            const x = (e.clientX - rect.left) / state.displayScale;
            const y = (e.clientY - rect.top) / state.displayScale;
            
            // 繪圖模式
            if (state.isDrawing) {
                if (state.mode === 'brush') {
                    drawBrushLine(state.lastPoint.x, state.lastPoint.y, x, y);
                    state.lastPoint = { x, y };
                } else if (state.mode === 'airbrush') {
                    state.lastPoint = { x, y };
                    drawAirbrush(x, y);
                } else if (state.mode === 'highlighter') {
                    drawHighlighterLine(state.lastPoint.x, state.lastPoint.y, x, y);
                    state.lastPoint = { x, y };
                } else if (state.mode === 'pencil') {
                    drawPencilLine(state.lastPoint.x, state.lastPoint.y, x, y);
                    state.lastPoint = { x, y };
                } else if (state.mode === 'mosaic') {
                    applyMosaic(x, y);
                    state.lastPoint = { x, y };
                } else if (state.mode === 'blur') {
                    applyBlur(x, y);
                    state.lastPoint = { x, y };
                } else if (state.mode === 'clone') {
                    doCloneStamp(e);
                } else if (state.mode === 'eraser') {
                    doEraser(x, y);
                    state.lastPoint = { x, y };
                }
                return;
            }
            
            // 套索模式 - 顯示預覽線到游標
            if (state.mode === 'lasso' && state.lassoPath.length > 0) {
                updateLassoPathSVG(x, y);
                return;
            }
            
            if (!state.isSelecting) return;
            
            const sx = Math.min(state.selStart.x, x);
            const sy = Math.min(state.selStart.y, y);
            const sw = Math.abs(x - state.selStart.x);
            const sh = Math.abs(y - state.selStart.y);
            
            // selectRect 在 canvasContainer 內，不需要乘以 displayScale
            selectRect.style.left = sx + 'px';
            selectRect.style.top = sy + 'px';
            selectRect.style.width = sw + 'px';
            selectRect.style.height = sh + 'px';
        }

        async function onMouseUp(e) {
            // 如果正在空白鍵拖拉畫布，跳過
            if (isPanning) return;
            
            // 圖層拖拉模式
            if (layerDragMode && draggingLayerIndex >= 0) {
                endLayerDrag();
                return;
            }
            
            // 繪圖模式結束
            if (state.isDrawing) {
                // 克隆圖章特殊處理
                if (state.mode === 'clone') {
                    endCloneStamp();
                    return;
                }
                // 清理噴槍的 interval
                if (state.airbrushInterval) {
                    clearInterval(state.airbrushInterval);
                    state.airbrushInterval = null;
                }
                state.isDrawing = false;
                state.lastPoint = null;
                updateUndoButton();
                return;
            }
            
            // 箭頭模式結束
            if (state.mode === 'arrow' && state.arrowStart) {
                const rect = canvasContainer.getBoundingClientRect();
                const endX = (e.clientX - rect.left) / state.displayScale;
                const endY = (e.clientY - rect.top) / state.displayScale;
                
                const dist = Math.sqrt(Math.pow(endX - state.arrowStart.x, 2) + Math.pow(endY - state.arrowStart.y, 2));
                if (dist > 10) {
                    drawArrow(state.arrowStart.x, state.arrowStart.y, endX, endY, state.arrowColor, state.arrowWidth, state.arrowStyle);
                    // 更新 state.image
                    const newImg = new Image();
                    newImg.src = canvas.toDataURL();
                    state.image = newImg;
                    updateUndoButton();
                }
                state.arrowStart = null;
                state.isSelecting = false;
                return;
            }
            
            // 漸層填充模式 - 獨立處理
            if (state.mode === 'gradient' && state.gradientStart) {
                const rect = canvasContainer.getBoundingClientRect();
                const endX = (e.clientX - rect.left) / state.displayScale;
                const endY = (e.clientY - rect.top) / state.displayScale;
                
                applyGradientFill(state.gradientStart.x, state.gradientStart.y, endX, endY);
                state.gradientStart = null;
                state.isSelecting = false;
                state.selStart = null;
                selectRect.style.display = 'none';
                selectRect.style.background = 'transparent'; // 重置背景
                updateUndoButton();
                return;
            }
            
            if (!state.isSelecting) return;
            
            state.isSelecting = false;
            selectRect.style.display = 'none';
            selectRect.style.background = 'transparent'; // 重置背景（漸層模式會設置背景）
            
            const rect = canvasContainer.getBoundingClientRect();
            const endX = (e.clientX - rect.left) / state.displayScale;
            const endY = (e.clientY - rect.top) / state.displayScale;
            
            const x = Math.round(Math.min(state.selStart.x, endX));
            const y = Math.round(Math.min(state.selStart.y, endY));
            const w = Math.round(Math.abs(endX - state.selStart.x));
            const h = Math.round(Math.abs(endY - state.selStart.y));
            
            if (w > 5 && h > 5) {
                // 記錄框選區域（用於顏色替換等功能）
                state.selectBox = { x, y, w, h };
                
                // 如果有框選完成回調，執行它並返回
                if (state.onSelectComplete) {
                    state.onSelectComplete(x, y, w, h);
                    return;
                }
                
                // 形狀模式
                if (state.mode === 'shape') {
                    drawShape(state.selStart.x, state.selStart.y, endX, endY);
                    updateUndoButton();
                    return;
                }
                
                // 圖像選取模式
                if (state.mode === 'imageSelect') {
                    processImageSelect(x, y, w, h);
                    return;
                }
                
                // 框選模式 - OCR 處理
                await processRegion(x, y, w, h);
            }
            
            if (state.mode !== 'brush' && state.mode !== 'mosaic' && state.mode !== 'blur') {
                setMode('select');
            }
        }
        
        // 清除當前選取的區域
        function eraseActiveRegion() {
            if (!state.activeRegion) return;
            
            const r = state.activeRegion;
            
            // 確保座標在有效範圍內
            const x = Math.max(0, Math.min(r.x, canvas.width - 1));
            const y = Math.max(0, Math.min(r.y, canvas.height - 1));
            const w = Math.min(r.w, canvas.width - x);
            const h = Math.min(r.h, canvas.height - y);
            const pad = r.padding || 5;
            
            if (w <= 0 || h <= 0) return;
            
            saveHistory('清除區域');
            
            // 用背景色清除（含邊距）
            const coverX = Math.max(0, x - pad);
            const coverY = Math.max(0, y - pad);
            const coverW = Math.min(w + pad * 2, canvas.width - coverX);
            const coverH = Math.min(h + pad * 2, canvas.height - coverY);
            
            ctx.fillStyle = r.bgColor;
            ctx.fillRect(coverX, coverY, coverW, coverH);
            
            // 清除選取預覽
            clearSelectionPreview();
            
            // 從區塊列表中移除
            const idx = state.regions.indexOf(r);
            if (idx !== -1) state.regions.splice(idx, 1);
            
            state.activeRegion = null;
            
            updateUndoButton();
            renderRegions();
            updatePanel();
            toast('已清除區域', 'success');
        }
        
        // 智能背景替換 - 只替換背景色，保留封閉線條內的物件顏色
        async function smartBackgroundReplace() {
            if (!state.activeRegion) return;
            
            const r = state.activeRegion;
            const pad = r.padding || 5;
            
            // 計算區域範圍（含邊距）
            const x = Math.max(0, Math.floor(r.x - pad));
            const y = Math.max(0, Math.floor(r.y - pad));
            const w = Math.min(Math.ceil(r.w + pad * 2), canvas.width - x);
            const h = Math.min(Math.ceil(r.h + pad * 2), canvas.height - y);
            
            if (w <= 0 || h <= 0) return;
            
            showLoading('分析背景區域...');
            
            await new Promise(resolve => setTimeout(resolve, 10));
            
            try {
                // 獲取區域圖像數據
                const imageData = ctx.getImageData(x, y, w, h);
                const data = imageData.data;
                
                // 解析目標背景色
                const targetBgColor = r.bgColor || '#ffffff';
                const targetR = parseInt(targetBgColor.slice(1, 3), 16);
                const targetG = parseInt(targetBgColor.slice(3, 5), 16);
                const targetB = parseInt(targetBgColor.slice(5, 7), 16);
                
                // 從邊緣採樣原始背景色
                const edgeColors = [];
                
                // 上邊緣
                for (let i = 0; i < w; i += 3) {
                    const idx = i * 4;
                    edgeColors.push({ r: data[idx], g: data[idx + 1], b: data[idx + 2] });
                }
                // 下邊緣
                for (let i = 0; i < w; i += 3) {
                    const idx = ((h - 1) * w + i) * 4;
                    edgeColors.push({ r: data[idx], g: data[idx + 1], b: data[idx + 2] });
                }
                // 左邊緣
                for (let j = 0; j < h; j += 3) {
                    const idx = (j * w) * 4;
                    edgeColors.push({ r: data[idx], g: data[idx + 1], b: data[idx + 2] });
                }
                // 右邊緣
                for (let j = 0; j < h; j += 3) {
                    const idx = (j * w + w - 1) * 4;
                    edgeColors.push({ r: data[idx], g: data[idx + 1], b: data[idx + 2] });
                }
                
                // 找出最常見的邊緣顏色作為原始背景色
                const colorCounts = {};
                edgeColors.forEach(c => {
                    // 量化顏色以減少變化
                    const key = `${Math.round(c.r / 8) * 8},${Math.round(c.g / 8) * 8},${Math.round(c.b / 8) * 8}`;
                    colorCounts[key] = (colorCounts[key] || 0) + 1;
                });
                
                let mostCommonColor = { r: 255, g: 255, b: 255 };
                let maxCount = 0;
                for (const key in colorCounts) {
                    if (colorCounts[key] > maxCount) {
                        maxCount = colorCounts[key];
                        const parts = key.split(',').map(Number);
                        mostCommonColor = { r: parts[0], g: parts[1], b: parts[2] };
                    }
                }
                
                // 顏色容差
                const tolerance = 50;
                
                // 使用洪水填充從邊緣開始標記背景區域
                const visited = new Uint8Array(w * h);
                const isBackground = new Uint8Array(w * h);
                const stack = [];
                
                // 檢查像素是否為背景色（與原始背景色相似）
                function isBgColor(idx) {
                    const pr = data[idx];
                    const pg = data[idx + 1];
                    const pb = data[idx + 2];
                    const diff = Math.abs(pr - mostCommonColor.r) + 
                                 Math.abs(pg - mostCommonColor.g) + 
                                 Math.abs(pb - mostCommonColor.b);
                    return diff < tolerance;
                }
                
                // 從四個邊緣開始洪水填充
                // 上邊緣
                for (let i = 0; i < w; i++) {
                    if (isBgColor(i * 4)) stack.push({ x: i, y: 0 });
                }
                // 下邊緣
                for (let i = 0; i < w; i++) {
                    if (isBgColor(((h - 1) * w + i) * 4)) stack.push({ x: i, y: h - 1 });
                }
                // 左邊緣
                for (let j = 0; j < h; j++) {
                    if (isBgColor((j * w) * 4)) stack.push({ x: 0, y: j });
                }
                // 右邊緣
                for (let j = 0; j < h; j++) {
                    if (isBgColor((j * w + w - 1) * 4)) stack.push({ x: w - 1, y: j });
                }
                
                // 執行洪水填充
                while (stack.length > 0) {
                    const { x: px, y: py } = stack.pop();
                    const pidx = py * w + px;
                    
                    if (px < 0 || px >= w || py < 0 || py >= h) continue;
                    if (visited[pidx]) continue;
                    
                    visited[pidx] = 1;
                    
                    const dataIdx = pidx * 4;
                    if (!isBgColor(dataIdx)) continue;
                    
                    isBackground[pidx] = 1;
                    
                    // 4-連通鄰居
                    stack.push({ x: px + 1, y: py });
                    stack.push({ x: px - 1, y: py });
                    stack.push({ x: px, y: py + 1 });
                    stack.push({ x: px, y: py - 1 });
                }
                
                saveHistory('智能背景替換');
                
                // 只替換背景區域的顏色
                let replacedCount = 0;
                for (let i = 0; i < w * h; i++) {
                    if (isBackground[i]) {
                        const idx = i * 4;
                        data[idx] = targetR;
                        data[idx + 1] = targetG;
                        data[idx + 2] = targetB;
                        replacedCount++;
                    }
                }
                
                // 寫回畫布
                ctx.putImageData(imageData, x, y);
                
                hideLoading();
                
                // 清除選取預覽
                clearSelectionPreview();
                
                updateUndoButton();
                renderRegions();
                updatePanel();
                
                const percentage = Math.round((replacedCount / (w * h)) * 100);
                toast(`已替換 ${percentage}% 的背景區域，保留了封閉區域內的顏色`, 'success');
                
            } catch (e) {
                hideLoading();
                toast('背景替換失敗: ' + e.message, 'error');
            }
        }
        
        // 取色器
        function pickColor(x, y) {
            const px = Math.round(x);
            const py = Math.round(y);
            
            if (px < 0 || py < 0 || px >= canvas.width || py >= canvas.height) return;
            
            const pixel = ctx.getImageData(px, py, 1, 1).data;
            const hex = '#' + [pixel[0], pixel[1], pixel[2]].map(v => v.toString(16).padStart(2, '0')).join('');
            
            // 如果是圖像區塊的背景色取色
            if (state.activeImageRegion && state.eyedropperTarget === 'imageBgColor') {
                state.activeImageRegion.bgColor = hex;
                
                // 重新填充原位置的背景色
                refillImageRegionOriginalArea(state.activeImageRegion);
                
                // 如果已經啟用透明背景，重新處理
                if (state.activeImageRegion.transparentBg) {
                    processImageTransparentBg(state.activeImageRegion);
                }
                
                renderImageRegions();
                updateImagePanel();
                toast(`已取色：${hex}，原位置已更新`, 'success');
                state.eyedropperTarget = null;
                setMode('select');
                return;
            }
            
            // 如果有活動區塊，更新其顏色
            if (state.activeRegion && state.eyedropperTarget) {
                state.activeRegion[state.eyedropperTarget] = hex;
                updatePanel();
                toast(`已取色：${hex}`, 'success');
            } else {
                // 複製到剪貼簿
                navigator.clipboard.writeText(hex).then(() => {
                    toast(`顏色 ${hex} 已複製`, 'success');
                }).catch(() => {
                    toast(`顏色：${hex}`, 'success');
                });
            }
            
            state.eyedropperTarget = null;
            setMode('select');
        }
        
        // 魔術棒選取 - 選取相似顏色區域
        async function magicWandSelect(startX, startY) {
            if (startX < 0 || startY < 0 || startX >= canvas.width || startY >= canvas.height) return;
            
            showLoading('分析區域...');
            
            // 使用 setTimeout 讓 UI 更新
            await new Promise(resolve => setTimeout(resolve, 10));
            
            try {
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                const width = canvas.width;
                const height = canvas.height;
                const tolerance = state.magicWandTolerance;
                
                // 取得起始點顏色
                const startIdx = (startY * width + startX) * 4;
                const targetR = data[startIdx];
                const targetG = data[startIdx + 1];
                const targetB = data[startIdx + 2];
                
                // 用於記錄已訪問的像素
                const visited = new Uint8Array(width * height);
                
                // 保存選取的像素座標列表
                const selectedPixels = [];
                
                // 邊界框
                let minX = startX, maxX = startX;
                let minY = startY, maxY = startY;
                
                // Flood fill 使用堆疊（避免遞迴過深）
                const stack = [[startX, startY]];
                
                while (stack.length > 0) {
                    const [x, y] = stack.pop();
                    
                    if (x < 0 || x >= width || y < 0 || y >= height) continue;
                    
                    const idx = y * width + x;
                    if (visited[idx]) continue;
                    
                    visited[idx] = 1;
                    
                    const pixelIdx = idx * 4;
                    const r = data[pixelIdx];
                    const g = data[pixelIdx + 1];
                    const b = data[pixelIdx + 2];
                    
                    // 檢查顏色是否相似
                    const diff = Math.abs(r - targetR) + Math.abs(g - targetG) + Math.abs(b - targetB);
                    
                    if (diff <= tolerance * 3) {
                        // 保存選取的像素座標
                        selectedPixels.push({ x, y });
                        
                        // 更新邊界框
                        if (x < minX) minX = x;
                        if (x > maxX) maxX = x;
                        if (y < minY) minY = y;
                        if (y > maxY) maxY = y;
                        
                        // 添加相鄰像素（8方向）
                        stack.push([x + 1, y]);
                        stack.push([x - 1, y]);
                        stack.push([x, y + 1]);
                        stack.push([x, y - 1]);
                        stack.push([x + 1, y + 1]);
                        stack.push([x - 1, y - 1]);
                        stack.push([x + 1, y - 1]);
                        stack.push([x - 1, y + 1]);
                    }
                }
                
                // 計算選取區域
                const w = maxX - minX + 1;
                const h = maxY - minY + 1;
                
                if (selectedPixels.length < 10) {
                    hideLoading();
                    toast('選取區域太小', 'error');
                    setMode('select');
                    return;
                }
                
                // 計算背景色（使用點擊位置的顏色）
                const bgColor = '#' + [targetR, targetG, targetB].map(v => v.toString(16).padStart(2, '0')).join('');
                
                // 創建區域
                const region = {
                    id: Date.now(),
                    x: minX, y: minY, w, h,
                    originalText: '',
                    text: '',
                    fontSize: Math.max(12, Math.round(h * 0.7)),
                    fontFamily: 'Inter',
                    fontWeight: '700',
                    scaleY: 1.0, // 維持原比例
                    color: '#000000', // 預設黑色
                    bgColor: bgColor,
                    padding: 0,
                    textAlign: 'left',
                    lineHeight: 1.2,
                    letterSpacing: 0,
                    strokeColor: '#000000',
                    strokeWidth: 0,
                    shadowColor: '#000000',
                    shadowBlur: 0,
                    shadowOffsetX: 0,
                    shadowOffsetY: 0,
                    rotation: 0,
                    // 漸層文字
                    gradientEnabled: false,
                    gradientColor1: '#ff0000',
                    gradientColor2: '#0000ff',
                    gradientDirection: 'horizontal',
                    // 曲線文字
                    curveEnabled: false,
                    curveRadius: 100,
                    curveStartAngle: 0,
                    edited: false,
                    // 保存選取的像素座標列表（用於精確清除）
                    selectedPixels: selectedPixels,
                    layerIndex: activeLayerIndex // 記錄所屬圖層
                };
                
                state.regions.push(region);
                state.activeRegion = region;
                
                // 在圖片上顯示選取預覽（半透明遮罩）
                showSelectionPreview(selectedPixels);
                
                renderRegions();
                updatePanel();
                hideLoading();
                
                toast(`已選取 ${selectedPixels.length} 個像素`, 'success');
                
            } catch (e) {
                // console.error(e);
                hideLoading();
                toast('選取失敗', 'error');
            }
            
            setMode('select');
        }
        
        // 顯示選取預覽 - 繪製實際輪廓
        function showSelectionPreview(pixels) {
            // 創建臨時 canvas 顯示選取範圍
            const previewCanvas = document.createElement('canvas');
            previewCanvas.width = canvas.width;
            previewCanvas.height = canvas.height;
            previewCanvas.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                pointer-events: none;
                z-index: 5;
            `;
            previewCanvas.id = 'selection-preview';
            
            // 移除舊的預覽
            const oldPreview = document.getElementById('selection-preview');
            if (oldPreview) oldPreview.remove();
            
            const previewCtx = previewCanvas.getContext('2d');
            
            // 建立像素集合（用於快速查找）
            const pixelSet = new Set();
            pixels.forEach(({x, y}) => {
                pixelSet.add(`${x},${y}`);
            });
            
            // 找出邊緣像素（相鄰有未選取像素的選取像素）
            const edgePixels = [];
            pixels.forEach(({x, y}) => {
                // 檢查四個方向是否有未選取的像素
                const hasUnselectedNeighbor = 
                    !pixelSet.has(`${x-1},${y}`) ||
                    !pixelSet.has(`${x+1},${y}`) ||
                    !pixelSet.has(`${x},${y-1}`) ||
                    !pixelSet.has(`${x},${y+1}`);
                
                if (hasUnselectedNeighbor) {
                    edgePixels.push({x, y});
                }
            });
            
            // 繪製半透明填充
            previewCtx.fillStyle = 'rgba(99, 102, 241, 0.2)';
            pixels.forEach(({x, y}) => {
                previewCtx.fillRect(x, y, 1, 1);
            });
            
            // 繪製邊緣輪廓（醒目的顏色）
            previewCtx.fillStyle = 'rgba(239, 68, 68, 0.9)'; // 紅色邊框
            edgePixels.forEach(({x, y}) => {
                previewCtx.fillRect(x, y, 1, 1);
            });
            
            // 添加動態虛線動畫效果（螞蟻線）
            previewCanvas.className = 'marching-ants';
            
            canvasContainer.appendChild(previewCanvas);
        }
        
        // 清除選取預覽
        function clearSelectionPreview() {
            const preview = document.getElementById('selection-preview');
            if (preview) preview.remove();
        }
        
        // 精確清除（使用像素列表）- 掛載到 window 以便 onclick 調用
        window.doEraseWithMask = async function() {
            if (!state.activeRegion) {
                toast('請先選取區域', 'error');
                return;
            }
            
            const r = state.activeRegion;
            const pixels = r.selectedPixels;
            
            if (!pixels || pixels.length === 0) {
                eraseActiveRegion();
                return;
            }
            
            showLoading('清除中...');
            
            await new Promise(resolve => setTimeout(resolve, 50));
            
            try {
                saveHistory('魔術棒選取');
                
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                const width = canvas.width;
                
                // 解析背景色
                const bgR = parseInt(r.bgColor.slice(1, 3), 16);
                const bgG = parseInt(r.bgColor.slice(3, 5), 16);
                const bgB = parseInt(r.bgColor.slice(5, 7), 16);
                
                // 只清除選取的像素
                for (let i = 0; i < pixels.length; i++) {
                    const {x, y} = pixels[i];
                    const idx = (y * width + x) * 4;
                    data[idx] = bgR;
                    data[idx + 1] = bgG;
                    data[idx + 2] = bgB;
                }
                
                ctx.putImageData(imageData, 0, 0);
                
                // 清除預覽
                clearSelectionPreview();
                
                // 從區塊列表中移除
                const idx = state.regions.indexOf(r);
                if (idx !== -1) state.regions.splice(idx, 1);
                
                state.activeRegion = null;
                
                updateUndoButton();
                renderRegions();
                updatePanel();
                hideLoading();
                toast('已精確清除 ' + pixels.length + ' 個像素', 'success');
                
            } catch (e) {
                hideLoading();
                toast('清除失敗', 'error');
            }
        };
        
        // ============ 繪圖工具 ============
        
        // 畫筆 - 繪製點
        function drawBrushPoint(x, y) {
            ctx.save();
            ctx.globalAlpha = state.brushOpacity;
            ctx.fillStyle = state.brushColor;
            ctx.beginPath();
            ctx.arc(x, y, state.brushSize / 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }
        
        // 畫筆 - 繪製線段
        function drawBrushLine(x1, y1, x2, y2) {
            ctx.save();
            ctx.globalAlpha = state.brushOpacity;
            ctx.strokeStyle = state.brushColor;
            ctx.lineWidth = state.brushSize;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
            ctx.restore();
        }
        
        // ============ 噴槍工具 ============
        function drawAirbrush(x, y) {
            ctx.save();
            const density = state.airbrushDensity;
            const size = state.airbrushSize;
            const opacity = state.airbrushOpacity;
            const particleSize = state.airbrushParticleSize || 2;
            
            for (let i = 0; i < density; i++) {
                // 隨機角度和距離（高斯分布效果）
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * size / 2;
                const px = x + Math.cos(angle) * radius;
                const py = y + Math.sin(angle) * radius;
                
                // 根據距離調整透明度（中心較濃）
                const distRatio = radius / (size / 2);
                const alpha = opacity * (1 - distRatio * 0.7);
                
                ctx.globalAlpha = alpha;
                ctx.fillStyle = state.airbrushColor;
                ctx.beginPath();
                // 使用可調整的顆粒大小
                const pSize = particleSize * (0.5 + Math.random());
                ctx.arc(px, py, pSize, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
        }
        
        // ============ 螢光筆工具 ============
        function drawHighlighterLine(x1, y1, x2, y2) {
            ctx.save();
            ctx.globalAlpha = state.highlighterOpacity;
            ctx.strokeStyle = state.highlighterColor;
            ctx.lineWidth = state.highlighterSize;
            ctx.lineCap = 'butt';  // 平頭
            ctx.lineJoin = 'miter';
            // 使用較暗的混合模式讓顏色疊加
            ctx.globalCompositeOperation = 'multiply';
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
            ctx.restore();
        }
        
        // ============ 鉛筆工具 ============
        function drawPencilPoint(x, y) {
            ctx.save();
            ctx.fillStyle = state.pencilColor;
            ctx.globalAlpha = 0.8 + Math.random() * 0.2;  // 輕微變化
            ctx.beginPath();
            ctx.arc(x, y, state.pencilSize / 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }
        
        function drawPencilLine(x1, y1, x2, y2) {
            ctx.save();
            ctx.strokeStyle = state.pencilColor;
            ctx.lineWidth = state.pencilSize;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            const jitter = state.pencilJitter || 0.5;
            
            // 添加抖動效果模擬鉛筆質感
            const dist = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
            const steps = Math.max(1, Math.floor(dist / 2));
            
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            
            for (let i = 1; i <= steps; i++) {
                const t = i / steps;
                const px = x1 + (x2 - x1) * t + (Math.random() - 0.5) * jitter;
                const py = y1 + (y2 - y1) * t + (Math.random() - 0.5) * jitter;
                ctx.lineTo(px, py);
            }
            
            ctx.stroke();
            ctx.restore();
        }
        
        // 形狀工具
        function drawShape(x1, y1, x2, y2) {
            ctx.save();
            ctx.strokeStyle = state.shapeStrokeColor;
            ctx.fillStyle = state.shapeFillColor;
            ctx.lineWidth = state.shapeStrokeWidth;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            const minX = Math.min(x1, x2);
            const minY = Math.min(y1, y2);
            const w = Math.abs(x2 - x1);
            const h = Math.abs(y2 - y1);
            
            switch (state.shapeType) {
                case 'rect':
                    if (state.shapeFill) {
                        ctx.fillRect(minX, minY, w, h);
                    }
                    if (state.shapeStroke) {
                        ctx.strokeRect(minX, minY, w, h);
                    }
                    break;
                    
                case 'circle':
                    const cx = (x1 + x2) / 2;
                    const cy = (y1 + y2) / 2;
                    const rx = w / 2;
                    const ry = h / 2;
                    ctx.beginPath();
                    ctx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2);
                    if (state.shapeFill) ctx.fill();
                    if (state.shapeStroke) ctx.stroke();
                    break;
                    
                case 'line':
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                    break;
                    
                case 'arrow':
                    // 繪製箭頭
                    const angle = Math.atan2(y2 - y1, x2 - x1);
                    const headLen = Math.min(30, Math.sqrt(w*w + h*h) / 3);
                    
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                    
                    // 箭頭頭部
                    ctx.beginPath();
                    ctx.moveTo(x2, y2);
                    ctx.lineTo(x2 - headLen * Math.cos(angle - Math.PI / 6), y2 - headLen * Math.sin(angle - Math.PI / 6));
                    ctx.moveTo(x2, y2);
                    ctx.lineTo(x2 - headLen * Math.cos(angle + Math.PI / 6), y2 - headLen * Math.sin(angle + Math.PI / 6));
                    ctx.stroke();
                    break;
            }
            
            ctx.restore();
        }
        
        // 馬賽克效果
        function applyMosaic(x, y) {
            const size = state.mosaicSize;
            const brushRadius = state.brushSize;
            
            // 計算影響範圍
            const startX = Math.max(0, Math.floor((x - brushRadius) / size) * size);
            const startY = Math.max(0, Math.floor((y - brushRadius) / size) * size);
            const endX = Math.min(canvas.width, Math.ceil((x + brushRadius) / size) * size);
            const endY = Math.min(canvas.height, Math.ceil((y + brushRadius) / size) * size);
            
            for (let bx = startX; bx < endX; bx += size) {
                for (let by = startY; by < endY; by += size) {
                    // 檢查是否在筆刷範圍內
                    const cx = bx + size / 2;
                    const cy = by + size / 2;
                    const dist = Math.sqrt((cx - x) ** 2 + (cy - y) ** 2);
                    if (dist > brushRadius) continue;
                    
                    // 取得該區塊的平均顏色
                    const blockW = Math.min(size, canvas.width - bx);
                    const blockH = Math.min(size, canvas.height - by);
                    const imageData = ctx.getImageData(bx, by, blockW, blockH);
                    const data = imageData.data;
                    
                    let r = 0, g = 0, b = 0, count = 0;
                    for (let i = 0; i < data.length; i += 4) {
                        r += data[i];
                        g += data[i + 1];
                        b += data[i + 2];
                        count++;
                    }
                    
                    r = Math.round(r / count);
                    g = Math.round(g / count);
                    b = Math.round(b / count);
                    
                    // 填充區塊
                    ctx.fillStyle = `rgb(${r},${g},${b})`;
                    ctx.fillRect(bx, by, blockW, blockH);
                }
            }
        }
        
        // 模糊效果
        function applyBlur(x, y) {
            const radius = state.blurRadius;
            const brushRadius = state.brushSize;
            
            // 計算影響範圍
            const startX = Math.max(0, Math.round(x - brushRadius));
            const startY = Math.max(0, Math.round(y - brushRadius));
            const endX = Math.min(canvas.width, Math.round(x + brushRadius));
            const endY = Math.min(canvas.height, Math.round(y + brushRadius));
            const w = endX - startX;
            const h = endY - startY;
            
            if (w <= 0 || h <= 0) return;
            
            // 取得區域數據
            const imageData = ctx.getImageData(startX, startY, w, h);
            const data = imageData.data;
            const tempData = new Uint8ClampedArray(data);
            
            // 簡單的盒狀模糊
            for (let py = 0; py < h; py++) {
                for (let px = 0; px < w; px++) {
                    // 檢查是否在筆刷範圍內
                    const dist = Math.sqrt((startX + px - x) ** 2 + (startY + py - y) ** 2);
                    if (dist > brushRadius) continue;
                    
                    let r = 0, g = 0, b = 0, count = 0;
                    
                    for (let ky = -radius; ky <= radius; ky++) {
                        for (let kx = -radius; kx <= radius; kx++) {
                            const nx = px + kx;
                            const ny = py + ky;
                            if (nx >= 0 && nx < w && ny >= 0 && ny < h) {
                                const idx = (ny * w + nx) * 4;
                                r += tempData[idx];
                                g += tempData[idx + 1];
                                b += tempData[idx + 2];
                                count++;
                            }
                        }
                    }
                    
                    const idx = (py * w + px) * 4;
                    data[idx] = Math.round(r / count);
                    data[idx + 1] = Math.round(g / count);
                    data[idx + 2] = Math.round(b / count);
                }
            }
            
            ctx.putImageData(imageData, startX, startY);
        }
        
        // ============ 文字增強 ============
        
        // 創建漸層
        function createTextGradient(x, y, w, h) {
            let gradient;
            switch (state.gradientDirection) {
                case 'horizontal':
                    gradient = ctx.createLinearGradient(x, y, x + w, y);
                    break;
                case 'vertical':
                    gradient = ctx.createLinearGradient(x, y, x, y + h);
                    break;
                case 'diagonal':
                    gradient = ctx.createLinearGradient(x, y, x + w, y + h);
                    break;
                default:
                    gradient = ctx.createLinearGradient(x, y, x + w, y);
            }
            gradient.addColorStop(0, state.gradientColor1);
            gradient.addColorStop(1, state.gradientColor2);
            return gradient;
        }
        
        // 套用樣式範本
        function applyStylePreset(preset) {
            if (!state.activeRegion) {
                toast('請先選取區域', 'error');
                return;
            }
            
            const r = state.activeRegion;
            if (preset.fontSize) r.fontSize = preset.fontSize;
            if (preset.fontWeight) r.fontWeight = preset.fontWeight;
            if (preset.color) r.color = preset.color;
            if (preset.bgColor) r.bgColor = preset.bgColor;
            if (preset.strokeWidth !== undefined) r.strokeWidth = preset.strokeWidth;
            if (preset.strokeColor) r.strokeColor = preset.strokeColor;
            
            updatePanel();
            toast(`已套用「${preset.name}」樣式`, 'success');
        }
        
        // 繪製曲線文字
        function drawCurvedText(text, centerX, centerY, radius, startAngle) {
            ctx.save();
            
            const angleStep = (text.length > 1) ? (Math.PI / (text.length * 2)) : 0;
            let currentAngle = startAngle - (angleStep * (text.length - 1) / 2);
            
            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                const x = centerX + radius * Math.cos(currentAngle);
                const y = centerY + radius * Math.sin(currentAngle);
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(currentAngle + Math.PI / 2);
                ctx.fillText(char, 0, 0);
                ctx.restore();
                
                currentAngle += angleStep;
            }
            
            ctx.restore();
        }
        
        // 清除所有區塊
        function clearAllRegions() {
            if (state.regions.length === 0) {
                toast('沒有區塊可清除', 'error');
                return;
            }
            
            if (!confirm('確定要清除所有區塊嗎？')) return;
            
            state.regions = [];
            state.activeRegion = null;
            state.selectedRegions = [];
            renderRegions();
            updatePanel();
            toast('已清除所有區塊', 'success');
        }

        // ========== 套索選取功能 ==========
        
        // 創建套索路徑 SVG
        function createLassoPathSVG() {
            let svg = document.getElementById('lasso-svg');
            if (!svg) {
                svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.id = 'lasso-svg';
                svg.style.cssText = `
                    position: absolute;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    pointer-events: none;
                    z-index: 20;
                `;
                canvasContainer.appendChild(svg);
            }
            svg.innerHTML = '';
        }
        
        // 更新套索路徑 SVG（cursorX, cursorY 為游標位置，用於預覽）
        function updateLassoPathSVG(cursorX, cursorY) {
            const svg = document.getElementById('lasso-svg');
            if (!svg || state.lassoPath.length < 1) return;
            
            let pathD = `M ${state.lassoPath[0].x} ${state.lassoPath[0].y}`;
            for (let i = 1; i < state.lassoPath.length; i++) {
                pathD += ` L ${state.lassoPath[i].x} ${state.lassoPath[i].y}`;
            }
            
            // 如果有游標位置，添加預覽線
            let previewLine = '';
            if (cursorX !== undefined && cursorY !== undefined) {
                const lastPoint = state.lassoPath[state.lassoPath.length - 1];
                previewLine = `<line x1="${lastPoint.x}" y1="${lastPoint.y}" x2="${cursorX}" y2="${cursorY}" 
                    stroke="#f59e0b" stroke-width="1" stroke-dasharray="5,5" opacity="0.7"/>`;
                
                // 如果有3個以上的點，也顯示回到起點的預覽線
                if (state.lassoPath.length >= 3) {
                    const firstPoint = state.lassoPath[0];
                    previewLine += `<line x1="${cursorX}" y1="${cursorY}" x2="${firstPoint.x}" y2="${firstPoint.y}" 
                        stroke="#22c55e" stroke-width="1" stroke-dasharray="5,5" opacity="0.5"/>`;
                }
            }
            
            // 繪製所有點
            let points = '';
            state.lassoPath.forEach((p, idx) => {
                const isFirst = idx === 0;
                const canClose = isFirst && state.lassoPath.length >= 3;
                points += `<circle cx="${p.x}" cy="${p.y}" r="${canClose ? 8 : 5}" 
                    fill="${isFirst ? '#22c55e' : '#f59e0b'}" 
                    stroke="#fff" stroke-width="2"
                    ${canClose ? 'style="cursor:pointer;"' : ''}/>`;
            });
            
            // 閉合區域預覽（半透明填充）
            let fillPath = '';
            if (state.lassoPath.length >= 3) {
                fillPath = `<path d="${pathD} Z" fill="rgba(245, 158, 11, 0.15)" stroke="none"/>`;
            }
            
            svg.innerHTML = `
                ${fillPath}
                <path d="${pathD}" fill="none" stroke="#f59e0b" stroke-width="2"/>
                ${previewLine}
                ${points}
                ${state.lassoPath.length >= 3 ? `<text x="${state.lassoPath[0].x}" y="${state.lassoPath[0].y - 15}" 
                    fill="#22c55e" font-size="12" text-anchor="middle">點擊或按 Enter</text>` : ''}
            `;
        }
        
        // 清除套索路徑
        function clearLassoPath() {
            const svg = document.getElementById('lasso-svg');
            if (svg) svg.innerHTML = '';
            state.lassoPath = [];
            state.isLassoDrawing = false;
        }
        
        // 從套索路徑外側取樣背景色
        function sampleBackgroundColorAroundPath(path, minX, minY, maxX, maxY) {
            const sampleColors = [];
            const margin = 10; // 往外取樣的距離
            
            // 方法1：從路徑的每個點往外延伸取樣
            for (let i = 0; i < path.length; i++) {
                const p = path[i];
                const prevP = path[(i - 1 + path.length) % path.length];
                const nextP = path[(i + 1) % path.length];
                
                // 計算該點的外向法線方向
                const dx1 = p.x - prevP.x;
                const dy1 = p.y - prevP.y;
                const dx2 = nextP.x - p.x;
                const dy2 = nextP.y - p.y;
                
                // 平均方向的垂直向量（指向外側）
                const avgDx = (dx1 + dx2) / 2;
                const avgDy = (dy1 + dy2) / 2;
                
                // 垂直向量（順時針旋轉90度 = 外側）
                let nx = avgDy;
                let ny = -avgDx;
                
                // 標準化
                const len = Math.sqrt(nx * nx + ny * ny);
                if (len > 0) {
                    nx = nx / len * margin;
                    ny = ny / len * margin;
                }
                
                // 外側取樣點
                const sampleX = Math.round(p.x + nx);
                const sampleY = Math.round(p.y + ny);
                
                // 確保在畫布範圍內
                if (sampleX >= 0 && sampleX < canvas.width && sampleY >= 0 && sampleY < canvas.height) {
                    const pixel = ctx.getImageData(sampleX, sampleY, 1, 1).data;
                    sampleColors.push({ r: pixel[0], g: pixel[1], b: pixel[2] });
                }
                
                // 也從內側取樣（取反方向），然後判斷哪邊是背景
                const innerX = Math.round(p.x - nx);
                const innerY = Math.round(p.y - ny);
                if (innerX >= 0 && innerX < canvas.width && innerY >= 0 && innerY < canvas.height) {
                    const pixel = ctx.getImageData(innerX, innerY, 1, 1).data;
                    sampleColors.push({ r: pixel[0], g: pixel[1], b: pixel[2] });
                }
            }
            
            // 方法2：從邊界框外圍取樣
            const expandedMinX = Math.max(0, minX - margin);
            const expandedMinY = Math.max(0, minY - margin);
            const expandedMaxX = Math.min(canvas.width - 1, maxX + margin);
            const expandedMaxY = Math.min(canvas.height - 1, maxY + margin);
            
            // 上邊
            for (let x = expandedMinX; x <= expandedMaxX; x += 5) {
                if (expandedMinY >= 0 && expandedMinY < minY) {
                    const pixel = ctx.getImageData(x, expandedMinY, 1, 1).data;
                    sampleColors.push({ r: pixel[0], g: pixel[1], b: pixel[2] });
                }
            }
            // 下邊
            for (let x = expandedMinX; x <= expandedMaxX; x += 5) {
                if (expandedMaxY < canvas.height && expandedMaxY > maxY) {
                    const pixel = ctx.getImageData(x, expandedMaxY, 1, 1).data;
                    sampleColors.push({ r: pixel[0], g: pixel[1], b: pixel[2] });
                }
            }
            // 左邊
            for (let y = expandedMinY; y <= expandedMaxY; y += 5) {
                if (expandedMinX >= 0 && expandedMinX < minX) {
                    const pixel = ctx.getImageData(expandedMinX, y, 1, 1).data;
                    sampleColors.push({ r: pixel[0], g: pixel[1], b: pixel[2] });
                }
            }
            // 右邊
            for (let y = expandedMinY; y <= expandedMaxY; y += 5) {
                if (expandedMaxX < canvas.width && expandedMaxX > maxX) {
                    const pixel = ctx.getImageData(expandedMaxX, y, 1, 1).data;
                    sampleColors.push({ r: pixel[0], g: pixel[1], b: pixel[2] });
                }
            }
            
            // 找出最常見的顏色
            if (sampleColors.length === 0) {
                return '#f5f5dc'; // 預設米色
            }
            
            const counts = {};
            sampleColors.forEach(c => {
                // 量化顏色以便分組
                const key = `${Math.round(c.r/8)*8},${Math.round(c.g/8)*8},${Math.round(c.b/8)*8}`;
                counts[key] = (counts[key] || 0) + 1;
            });
            
            let maxKey = Object.keys(counts)[0];
            let maxCount = 0;
            for (const key in counts) {
                if (counts[key] > maxCount) {
                    maxCount = counts[key];
                    maxKey = key;
                }
            }
            
            const [r, g, b] = maxKey.split(',').map(Number);
            return rgbToHex(r, g, b);
        }
        
        // 處理套索選取
        function processLassoSelect() {
            if (state.lassoPath.length < 3) return;
            
            // 保存當前狀態
            const currentPath = state.lassoPath.slice();
            
            // 使用 setTimeout 隔離可能的錯誤
            setTimeout(function() {
                try {
                    // 計算邊界框
                    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                    currentPath.forEach(p => {
                        minX = Math.min(minX, p.x);
                        minY = Math.min(minY, p.y);
                        maxX = Math.max(maxX, p.x);
                        maxY = Math.max(maxY, p.y);
                    });
                    
                    minX = Math.max(0, Math.floor(minX));
                    minY = Math.max(0, Math.floor(minY));
                    maxX = Math.min(canvas.width, Math.ceil(maxX));
                    maxY = Math.min(canvas.height, Math.ceil(maxY));
                    
                    const w = maxX - minX;
                    const h = maxY - minY;
                    
                    if (w < 5 || h < 5) return;
                    
                    const bgColor = sampleBackgroundColorAroundPath(currentPath, minX, minY, maxX, maxY);
                    const imageData = ctx.getImageData(minX, minY, w, h);
                    
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = w;
                    tempCanvas.height = h;
                    const tempCtx = tempCanvas.getContext('2d');
                    
                    const relativePath = currentPath.map(p => ({
                        x: p.x - minX,
                        y: p.y - minY
                    }));
                    
                    tempCtx.save();
                    tempCtx.beginPath();
                    tempCtx.moveTo(relativePath[0].x, relativePath[0].y);
                    for (let i = 1; i < relativePath.length; i++) {
                        tempCtx.lineTo(relativePath[i].x, relativePath[i].y);
                    }
                    tempCtx.closePath();
                    tempCtx.clip();
                    tempCtx.drawImage(canvas, minX, minY, w, h, 0, 0, w, h);
                    tempCtx.restore();
                    
                    saveHistory('套索選取');
                    
                    ctx.save();
                    ctx.beginPath();
                    ctx.moveTo(currentPath[0].x, currentPath[0].y);
                    for (let i = 1; i < currentPath.length; i++) {
                        ctx.lineTo(currentPath[i].x, currentPath[i].y);
                    }
                    ctx.closePath();
                    ctx.fillStyle = bgColor;
                    ctx.fill();
                    ctx.restore();
                    
                    const imageRegion = {
                        id: Date.now(),
                        type: 'lasso',
                        x: minX,
                        y: minY,
                        w: w,
                        h: h,
                        originalW: w,
                        originalH: h,
                        originalX: minX,
                        originalY: minY,
                        imageData: tempCanvas.toDataURL('image/png'),
                        originalImageData: tempCanvas.toDataURL('image/png'),
                        bgColor: bgColor,
                        transparentBg: true,
                        tolerance: 30,
                        isFloating: true,
                        rotation: 0,
                        scale: 1,
                        lassoPath: relativePath,
                        originalLassoPath: currentPath.slice(),
                        layerIndex: activeLayerIndex // 記錄所屬圖層
                    };
                    
                    state.imageRegions = state.imageRegions || [];
                    state.imageRegions.push(imageRegion);
                    state.activeImageRegion = imageRegion;
                    state.activeRegion = null;
                    
                    processImageTransparentBgSync(imageRegion);
                    
                    renderImageRegions();
                    renderRegions();
                    updateImagePanel();
                    updateUndoButton();
                    
                    setMode('select');
                    toast('已選取不規則區域（背景已透明化）', 'success');
                } catch(e) {
                    // 靜默忽略錯誤
                }
            }, 0);
        }

        // ========== 圖像選取功能 ==========
        
        // 從矩形區域外側取樣背景色
        function sampleBackgroundColorAroundRect(x, y, w, h) {
            const sampleColors = [];
            const margin = 10; // 往外取樣的距離
            
            // 從四周取樣
            const minX = Math.max(0, x - margin);
            const minY = Math.max(0, y - margin);
            const maxX = Math.min(canvas.width - 1, x + w + margin);
            const maxY = Math.min(canvas.height - 1, y + h + margin);
            
            // 上邊（在選取區域上方）
            if (y - margin >= 0) {
                for (let px = minX; px <= maxX; px += 5) {
                    const pixel = ctx.getImageData(px, Math.max(0, y - margin), 1, 1).data;
                    sampleColors.push({ r: pixel[0], g: pixel[1], b: pixel[2] });
                }
            }
            
            // 下邊（在選取區域下方）
            if (y + h + margin < canvas.height) {
                for (let px = minX; px <= maxX; px += 5) {
                    const pixel = ctx.getImageData(px, Math.min(canvas.height - 1, y + h + margin), 1, 1).data;
                    sampleColors.push({ r: pixel[0], g: pixel[1], b: pixel[2] });
                }
            }
            
            // 左邊（在選取區域左方）
            if (x - margin >= 0) {
                for (let py = minY; py <= maxY; py += 5) {
                    const pixel = ctx.getImageData(Math.max(0, x - margin), py, 1, 1).data;
                    sampleColors.push({ r: pixel[0], g: pixel[1], b: pixel[2] });
                }
            }
            
            // 右邊（在選取區域右方）
            if (x + w + margin < canvas.width) {
                for (let py = minY; py <= maxY; py += 5) {
                    const pixel = ctx.getImageData(Math.min(canvas.width - 1, x + w + margin), py, 1, 1).data;
                    sampleColors.push({ r: pixel[0], g: pixel[1], b: pixel[2] });
                }
            }
            
            // 如果沒有取到顏色，使用預設
            if (sampleColors.length === 0) {
                return '#f5f5dc'; // 預設米色
            }
            
            // 找出最常見的顏色
            const counts = {};
            sampleColors.forEach(c => {
                const key = `${Math.round(c.r/8)*8},${Math.round(c.g/8)*8},${Math.round(c.b/8)*8}`;
                counts[key] = (counts[key] || 0) + 1;
            });
            
            let maxKey = Object.keys(counts)[0];
            let maxCount = 0;
            for (const key in counts) {
                if (counts[key] > maxCount) {
                    maxCount = counts[key];
                    maxKey = key;
                }
            }
            
            const [r, g, b] = maxKey.split(',').map(Number);
            return rgbToHex(r, g, b);
        }
        
        // 處理圖像選取
        function processImageSelect(x, y, w, h) {
            // 使用 setTimeout 隔離可能的錯誤
            setTimeout(function() {
                try {
                    // 提取選取區域的圖像
                    const imageData = ctx.getImageData(x, y, w, h);
                    
                    // 創建臨時 canvas 來存儲選取的圖像
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = w;
                    tempCanvas.height = h;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.putImageData(imageData, 0, 0);
                    
                    // 從矩形區域外側取樣背景色
                    const bgColor = sampleBackgroundColorAroundRect(x, y, w, h);
                    
                    // 創建圖像選取物件
                    const imageRegion = {
                        id: Date.now(),
                        type: 'image',
                        x: x,
                        y: y,
                        w: w,
                        h: h,
                        originalW: w,
                        originalH: h,
                        originalX: x,
                        originalY: y,
                        imageData: tempCanvas.toDataURL('image/png'),
                        originalImageData: tempCanvas.toDataURL('image/png'),
                        bgColor: bgColor,
                        transparentBg: true,
                        tolerance: 30,
                        isFloating: true,
                        rotation: 0,
                        scale: 1,
                        layerIndex: activeLayerIndex // 記錄所屬圖層
                    };
                    
                    // 保存歷史
                    saveHistory('圖像選取');
                    
                    // 用背景色清除原位置
                    ctx.fillStyle = bgColor;
                    ctx.fillRect(x, y, w, h);
                    
                    // 添加到區塊列表
                    state.imageRegions = state.imageRegions || [];
                    state.imageRegions.push(imageRegion);
                    state.activeImageRegion = imageRegion;
                    state.activeRegion = null;
                    
                    // 自動處理透明背景
                    processImageTransparentBgSync(imageRegion);
                    
                    // 渲染浮動圖像
                    renderImageRegions();
                    renderRegions();
                    updateImagePanel();
                    updateUndoButton();
                    
                    setMode('select');
                    toast('已選取圖像區塊（背景已透明化）', 'success');
                } catch(e) {
                    // 靜默忽略錯誤
                }
            }, 0);
        }
        
        // 圖表雙擊追蹤
        let chartLastClickTime = 0;
        let chartLastClickId = null;
        
        // 渲染所有浮動圖像
        function renderImageRegions() {
            console.log('renderImageRegions called, imageRegions:', state.imageRegions ? state.imageRegions.length : 0);
            
            let layer = document.getElementById('image-regions-layer');
            if (!layer) {
                layer = document.createElement('div');
                layer.id = 'image-regions-layer';
                layer.style.cssText = `
                    position: absolute;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    pointer-events: none;
                    z-index: 15;
                `;
                canvasContainer.appendChild(layer);
                console.log('Created image-regions-layer');
            }
            
            layer.innerHTML = '';
            
            if (!state.imageRegions || state.imageRegions.length === 0) {
                console.log('No image regions to render');
                return;
            }
            
            // 過濾只顯示可見圖層的物件
            const visibleRegions = state.imageRegions.filter(region => {
                const visible = isLayerVisible(region.layerIndex);
                console.log('Region', region.id, 'layerIndex:', region.layerIndex, 'visible:', visible);
                return visible;
            });
            
            console.log('Visible regions count:', visibleRegions.length);
            
            visibleRegions.forEach(region => {
                const isActive = state.activeImageRegion === region;
                const isLasso = region.type === 'lasso' && region.lassoPath;
                
                const div = document.createElement('div');
                div.className = 'image-region' + (isActive ? ' active' : '') + (isLasso ? ' lasso' : '');
                div.style.cssText = `
                    position: absolute;
                    left: ${region.x}px;
                    top: ${region.y}px;
                    width: ${region.w}px;
                    height: ${region.h}px;
                    cursor: move;
                    pointer-events: auto;
                    border: ${isLasso ? 'none' : `2px ${isActive ? 'solid' : 'dashed'} ${isActive ? '#f59e0b' : '#f59e0b80'}`};
                    box-sizing: border-box;
                    transform: rotate(${region.rotation || 0}deg);
                    transform-origin: center center;
                `;
                
                // 如果是套索選取，使用 SVG 來顯示不規則形狀
                if (isLasso) {
                    const scaleX = region.w / region.originalW;
                    const scaleY = region.h / region.originalH;
                    
                    // 創建 SVG
                    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    svg.setAttribute('width', region.w);
                    svg.setAttribute('height', region.h);
                    svg.style.cssText = `
                        position: absolute;
                        left: 0;
                        top: 0;
                        pointer-events: none;
                        overflow: visible;
                    `;
                    
                    // 創建 clipPath
                    const clipPathId = 'clip-' + region.id;
                    const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                    const clipPath = document.createElementNS('http://www.w3.org/2000/svg', 'clipPath');
                    clipPath.setAttribute('id', clipPathId);
                    
                    const pathElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    let pathD = `M ${region.lassoPath[0].x * scaleX} ${region.lassoPath[0].y * scaleY}`;
                    for (let i = 1; i < region.lassoPath.length; i++) {
                        pathD += ` L ${region.lassoPath[i].x * scaleX} ${region.lassoPath[i].y * scaleY}`;
                    }
                    pathD += ' Z';
                    pathElement.setAttribute('d', pathD);
                    clipPath.appendChild(pathElement);
                    defs.appendChild(clipPath);
                    svg.appendChild(defs);
                    
                    // 圖像元素
                    const image = document.createElementNS('http://www.w3.org/2000/svg', 'image');
                    image.setAttribute('href', region.imageData);
                    image.setAttribute('width', region.w);
                    image.setAttribute('height', region.h);
                    image.setAttribute('clip-path', `url(#${clipPathId})`);
                    svg.appendChild(image);
                    
                    // 邊框路徑（始終顯示，活動時實線，非活動時虛線）
                    const borderPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    borderPath.setAttribute('d', pathD);
                    borderPath.setAttribute('fill', 'none');
                    borderPath.setAttribute('stroke', isActive ? '#f59e0b' : '#f59e0b80');
                    borderPath.setAttribute('stroke-width', '2');
                    borderPath.setAttribute('stroke-dasharray', isActive ? 'none' : '5,5');
                    svg.appendChild(borderPath);
                    
                    div.appendChild(svg);
                } else {
                    // 普通矩形圖像
                    const img = document.createElement('img');
                    img.src = region.imageData;
                    img.style.cssText = `
                        width: 100%;
                        height: 100%;
                        pointer-events: none;
                        display: block;
                    `;
                    div.appendChild(img);
                    
                    // 如果是浮水印，添加標籤和透明度顯示
                    if (region.isWatermark) {
                        const label = document.createElement('div');
                        label.style.cssText = `
                            position: absolute;
                            top: -22px;
                            left: 0;
                            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
                            color: white;
                            padding: 3px 8px;
                            border-radius: 4px;
                            font-size: 10px;
                            white-space: nowrap;
                            z-index: 5;
                            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
                        `;
                        label.textContent = '💧 浮水印 ' + Math.round((region.opacity || 1) * 100) + '%';
                        div.appendChild(label);
                    }
                    
                    // 如果是印章，添加標籤
                    if (region.isStamp) {
                        const label = document.createElement('div');
                        label.style.cssText = `
                            position: absolute;
                            top: -22px;
                            left: 0;
                            background: linear-gradient(135deg, #dc2626, #f59e0b);
                            color: white;
                            padding: 3px 8px;
                            border-radius: 4px;
                            font-size: 10px;
                            white-space: nowrap;
                            z-index: 5;
                            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
                        `;
                        label.textContent = '🔏 印章';
                        div.appendChild(label);
                    }
                }
                
                // 如果是活動區域，添加縮放控制點
                if (isActive) {
                    // 四角縮放控制點
                    ['nw', 'ne', 'sw', 'se'].forEach(corner => {
                        const handle = document.createElement('div');
                        handle.className = 'image-resize-handle';
                        handle.dataset.corner = corner;
                        
                        const positions = {
                            'nw': 'top: -5px; left: -5px; cursor: nw-resize;',
                            'ne': 'top: -5px; right: -5px; cursor: ne-resize;',
                            'sw': 'bottom: -5px; left: -5px; cursor: sw-resize;',
                            'se': 'bottom: -5px; right: -5px; cursor: se-resize;'
                        };
                        
                        handle.style.cssText = `
                            position: absolute;
                            ${positions[corner]}
                            width: 10px;
                            height: 10px;
                            background: #f59e0b;
                            border: 2px solid #fff;
                            border-radius: 2px;
                            z-index: 10;
                        `;
                        
                        handle.onmousedown = (e) => startImageResize(e, region, corner);
                        div.appendChild(handle);
                    });
                    
                    // 邊緣縮放控制點（上、下、左、右）
                    ['n', 's', 'e', 'w'].forEach(edge => {
                        const handle = document.createElement('div');
                        handle.className = 'image-resize-handle edge';
                        handle.dataset.edge = edge;
                        
                        const edgePositions = {
                            'n': 'top: -4px; left: 50%; transform: translateX(-50%); cursor: n-resize; width: 30px; height: 8px;',
                            's': 'bottom: -4px; left: 50%; transform: translateX(-50%); cursor: s-resize; width: 30px; height: 8px;',
                            'e': 'right: -4px; top: 50%; transform: translateY(-50%); cursor: e-resize; width: 8px; height: 30px;',
                            'w': 'left: -4px; top: 50%; transform: translateY(-50%); cursor: w-resize; width: 8px; height: 30px;'
                        };
                        
                        handle.style.cssText = `
                            position: absolute;
                            ${edgePositions[edge]}
                            background: #f59e0b;
                            border: 2px solid #fff;
                            border-radius: 4px;
                            z-index: 10;
                        `;
                        
                        handle.onmousedown = (e) => startImageEdgeResize(e, region, edge);
                        div.appendChild(handle);
                    });
                    
                    // 縮放提示標籤
                    const scaleLabel = document.createElement('div');
                    scaleLabel.className = 'image-scale-label';
                    scaleLabel.innerHTML = `${Math.round((region.scale || 1) * 100)}%`;
                    scaleLabel.style.cssText = `
                        position: absolute;
                        bottom: -24px;
                        left: 50%;
                        transform: translateX(-50%);
                        background: #f59e0b;
                        color: #000;
                        padding: 2px 8px;
                        border-radius: 4px;
                        font-size: 11px;
                        font-weight: 600;
                        white-space: nowrap;
                        z-index: 10;
                    `;
                    div.appendChild(scaleLabel);
                    
                    // 旋轉控制點
                    const rotateHandle = document.createElement('div');
                    rotateHandle.className = 'image-rotate-handle';
                    rotateHandle.innerHTML = '↻';
                    rotateHandle.style.cssText = `
                        position: absolute;
                        top: -30px;
                        left: 50%;
                        transform: translateX(-50%);
                        width: 20px;
                        height: 20px;
                        background: #f59e0b;
                        border: 2px solid #fff;
                        border-radius: 50%;
                        cursor: grab;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 10px;
                        color: #fff;
                        z-index: 10;
                    `;
                    rotateHandle.onmousedown = (e) => startImageRotate(e, region);
                    div.appendChild(rotateHandle);
                    
                    // 連接線
                    const rotateLine = document.createElement('div');
                    rotateLine.style.cssText = `
                        position: absolute;
                        top: -28px;
                        left: 50%;
                        width: 2px;
                        height: 28px;
                        background: #f59e0b;
                        transform: translateX(-50%);
                    `;
                    div.appendChild(rotateLine);
                }
                
                // 拖動事件 + 雙擊檢測
                div.onmousedown = (e) => {
                    if (e.target.classList.contains('image-resize-handle') || 
                        e.target.classList.contains('image-rotate-handle') ||
                        e.target.classList.contains('chart-edit-btn')) return;
                    
                    // 雙擊檢測（針對圖表）
                    if (region.isChart) {
                        const now = Date.now();
                        if (chartLastClickId === region.id && now - chartLastClickTime < 400) {
                            // 雙擊 - 編輯圖表
                            e.preventDefault();
                            e.stopPropagation();
                            chartLastClickTime = 0;
                            chartLastClickId = null;
                            editChartObject(region);
                            return;
                        }
                        chartLastClickTime = now;
                        chartLastClickId = region.id;
                    }
                    
                    startImageDrag(e, region);
                };
                
                // 滾輪縮放圖像
                div.onwheel = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // 選取此區域
                    state.activeImageRegion = region;
                    
                    const delta = e.deltaY > 0 ? -0.05 : 0.05;
                    const currentScale = region.scale || 1;
                    const newScale = Math.max(0.1, Math.min(5, currentScale + delta));
                    
                    // 計算縮放中心（滑鼠位置）
                    const rect = div.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    const ratioX = mouseX / region.w;
                    const ratioY = mouseY / region.h;
                    
                    // 更新縮放
                    region.scale = newScale;
                    const newW = Math.round(region.originalW * newScale);
                    const newH = Math.round(region.originalH * newScale);
                    
                    // 調整位置以保持滑鼠指向的點不變
                    const deltaW = newW - region.w;
                    const deltaH = newH - region.h;
                    region.x = Math.round(region.x - deltaW * ratioX);
                    region.y = Math.round(region.y - deltaH * ratioY);
                    
                    region.w = newW;
                    region.h = newH;
                    
                    renderImageRegions();
                    updateImagePanel();
                };
                
                // 如果是圖表，添加編輯按鈕
                if (region.isChart) {
                    const editBtn = document.createElement('button');
                    editBtn.className = 'chart-edit-btn';
                    editBtn.innerHTML = '✏️';
                    editBtn.title = '雙擊或點此編輯圖表';
                    editBtn.style.cssText = `
                        position: absolute;
                        top: -12px;
                        left: 50%;
                        transform: translateX(-50%);
                        width: 28px;
                        height: 28px;
                        border-radius: 50%;
                        background: #4a90d9;
                        color: white;
                        border: 2px solid white;
                        cursor: pointer;
                        font-size: 14px;
                        display: ${isActive ? 'flex' : 'none'};
                        align-items: center;
                        justify-content: center;
                        z-index: 20;
                        box-shadow: 0 2px 5px rgba(0,0,0,0.3);
                    `;
                    editBtn.onmousedown = (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                    };
                    editBtn.onclick = (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        editChartObject(region);
                    };
                    div.appendChild(editBtn);
                    
                    // 滑鼠懸停時顯示編輯按鈕
                    div.onmouseenter = () => {
                        editBtn.style.display = 'flex';
                    };
                    div.onmouseleave = () => {
                        if (!isActive) {
                            editBtn.style.display = 'none';
                        }
                    };
                }
                
                layer.appendChild(div);
            });
        }
        
        // 開始拖動圖像
        function startImageDrag(e, region) {
            e.preventDefault();
            e.stopPropagation();
            
            state.activeImageRegion = region;
            // 清除文字區塊選取
            state.activeRegion = null;
            state.isImageDragging = true;
            
            const rect = canvasContainer.getBoundingClientRect();
            state.imageDragOffset = {
                x: (e.clientX - rect.left) / state.displayScale - region.x,
                y: (e.clientY - rect.top) / state.displayScale - region.y
            };
            
            document.addEventListener('mousemove', onImageDrag);
            document.addEventListener('mouseup', onImageDragEnd);
            
            renderRegions();
            renderImageRegions();
            updateImagePanel();
        }
        
        function onImageDrag(e) {
            if (!state.isImageDragging || !state.activeImageRegion) return;
            
            const rect = canvasContainer.getBoundingClientRect();
            const x = (e.clientX - rect.left) / state.displayScale - state.imageDragOffset.x;
            const y = (e.clientY - rect.top) / state.displayScale - state.imageDragOffset.y;
            
            state.activeImageRegion.x = Math.round(Math.max(0, Math.min(canvas.width - state.activeImageRegion.w, x)));
            state.activeImageRegion.y = Math.round(Math.max(0, Math.min(canvas.height - state.activeImageRegion.h, y)));
            
            renderImageRegions();
        }
        
        function onImageDragEnd() {
            state.isImageDragging = false;
            document.removeEventListener('mousemove', onImageDrag);
            document.removeEventListener('mouseup', onImageDragEnd);
            renderImageRegions();
        }
        
        // 開始縮放圖像
        function startImageResize(e, region, corner) {
            e.preventDefault();
            e.stopPropagation();
            
            state.isImageResizing = true;
            state.imageResizeCorner = corner;
            state.imageResizeStart = {
                x: region.x,
                y: region.y,
                w: region.w,
                h: region.h,
                mouseX: e.clientX,
                mouseY: e.clientY
            };
            
            document.addEventListener('mousemove', onImageResize);
            document.addEventListener('mouseup', onImageResizeEnd);
        }
        
        function onImageResize(e) {
            if (!state.isImageResizing || !state.activeImageRegion) return;
            
            const region = state.activeImageRegion;
            const start = state.imageResizeStart;
            const corner = state.imageResizeCorner;
            
            const dx = (e.clientX - start.mouseX) / state.displayScale;
            const dy = (e.clientY - start.mouseY) / state.displayScale;
            
            // 保持長寬比
            const aspectRatio = start.w / start.h;
            
            let newW, newH, newX, newY;
            
            if (corner === 'se') {
                newW = Math.max(20, start.w + dx);
                newH = newW / aspectRatio;
                newX = start.x;
                newY = start.y;
            } else if (corner === 'sw') {
                newW = Math.max(20, start.w - dx);
                newH = newW / aspectRatio;
                newX = start.x + (start.w - newW);
                newY = start.y;
            } else if (corner === 'ne') {
                newW = Math.max(20, start.w + dx);
                newH = newW / aspectRatio;
                newX = start.x;
                newY = start.y + (start.h - newH);
            } else if (corner === 'nw') {
                newW = Math.max(20, start.w - dx);
                newH = newW / aspectRatio;
                newX = start.x + (start.w - newW);
                newY = start.y + (start.h - newH);
            }
            
            region.w = Math.round(newW);
            region.h = Math.round(newH);
            region.x = Math.round(newX);
            region.y = Math.round(newY);
            region.scale = region.w / region.originalW;
            
            renderImageRegions();
            updateImagePanel();
        }
        
        function onImageResizeEnd() {
            state.isImageResizing = false;
            state.isImageEdgeResizing = false;
            document.removeEventListener('mousemove', onImageResize);
            document.removeEventListener('mousemove', onImageEdgeResize);
            document.removeEventListener('mouseup', onImageResizeEnd);
        }
        
        // 開始邊緣調整大小（單邊拉伸）
        function startImageEdgeResize(e, region, edge) {
            e.preventDefault();
            e.stopPropagation();
            
            state.isImageEdgeResizing = true;
            state.imageResizeEdge = edge;
            state.imageResizeStart = {
                x: region.x,
                y: region.y,
                w: region.w,
                h: region.h,
                mouseX: e.clientX,
                mouseY: e.clientY,
                originalW: region.originalW,
                originalH: region.originalH
            };
            
            document.addEventListener('mousemove', onImageEdgeResize);
            document.addEventListener('mouseup', onImageResizeEnd);
        }
        
        function onImageEdgeResize(e) {
            if (!state.isImageEdgeResizing || !state.activeImageRegion) return;
            
            const region = state.activeImageRegion;
            const start = state.imageResizeStart;
            const edge = state.imageResizeEdge;
            
            const dx = (e.clientX - start.mouseX) / state.displayScale;
            const dy = (e.clientY - start.mouseY) / state.displayScale;
            
            // 按住 Shift 保持比例
            const keepRatio = e.shiftKey;
            const aspectRatio = start.w / start.h;
            
            let newW = start.w, newH = start.h, newX = start.x, newY = start.y;
            
            switch (edge) {
                case 'e': // 右邊
                    newW = Math.max(20, start.w + dx);
                    if (keepRatio) newH = newW / aspectRatio;
                    break;
                case 'w': // 左邊
                    newW = Math.max(20, start.w - dx);
                    newX = start.x + (start.w - newW);
                    if (keepRatio) newH = newW / aspectRatio;
                    break;
                case 's': // 下邊
                    newH = Math.max(20, start.h + dy);
                    if (keepRatio) newW = newH * aspectRatio;
                    break;
                case 'n': // 上邊
                    newH = Math.max(20, start.h - dy);
                    newY = start.y + (start.h - newH);
                    if (keepRatio) newW = newH * aspectRatio;
                    break;
            }
            
            region.w = Math.round(newW);
            region.h = Math.round(newH);
            region.x = Math.round(newX);
            region.y = Math.round(newY);
            region.scale = region.w / region.originalW;
            region.scaleY = region.h / region.originalH;
            
            renderImageRegions();
            updateImagePanel();
        }
        
        // 開始旋轉圖像
        function startImageRotate(e, region) {
            e.preventDefault();
            e.stopPropagation();
            
            state.isImageRotating = true;
            
            const rect = canvasContainer.getBoundingClientRect();
            state.imageRotateCenter = {
                x: rect.left + (region.x + region.w / 2) * state.displayScale,
                y: rect.top + (region.y + region.h / 2) * state.displayScale
            };
            
            document.addEventListener('mousemove', onImageRotate);
            document.addEventListener('mouseup', onImageRotateEnd);
        }
        
        function onImageRotate(e) {
            if (!state.isImageRotating || !state.activeImageRegion) return;
            
            const center = state.imageRotateCenter;
            const dx = e.clientX - center.x;
            const dy = e.clientY - center.y;
            
            let angle = Math.atan2(dy, dx) * 180 / Math.PI + 90;
            
            // 標準化到 -180 ~ 180
            while (angle > 180) angle -= 360;
            while (angle < -180) angle += 360;
            
            // 捕捉到特定角度
            if (Math.abs(angle % 15) < 5) {
                angle = Math.round(angle / 15) * 15;
            }
            
            state.activeImageRegion.rotation = Math.round(angle);
            
            renderImageRegions();
            updateImagePanel();
        }
        
        function onImageRotateEnd() {
            state.isImageRotating = false;
            document.removeEventListener('mousemove', onImageRotate);
            document.removeEventListener('mouseup', onImageRotateEnd);
        }
        
        // 更新圖像選取面板
        function updateImagePanel() {
            const panel = document.getElementById('panel-content');
            if (!panel) return;
            
            const r = state.activeImageRegion;
            if (!r) {
                // 如果沒有活動圖像區塊，調用普通 updatePanel
                updatePanel();
                return;
            }
            
            const isLasso = r.type === 'lasso';
            const typeIcon = isLasso ? '✂️' : '🖼️';
            const typeName = isLasso ? '套索選取' : '圖像區塊';
            
            panel.innerHTML = `
                <div class="panel-header">
                    <span>${typeIcon} ${typeName}</span>
                    <span class="region-id">#${r.id}</span>
                </div>
                
                <div class="section">
                    <div class="section-title">📐 位置與大小</div>
                    <div class="prop-row">
                        <span class="prop-label">X</span>
                        <input type="number" class="prop-input" value="${r.x}" onchange="updateImageRegionProp('x', +this.value)">
                    </div>
                    <div class="prop-row">
                        <span class="prop-label">Y</span>
                        <input type="number" class="prop-input" value="${r.y}" onchange="updateImageRegionProp('y', +this.value)">
                    </div>
                    <div class="prop-row">
                        <span class="prop-label">寬度</span>
                        <input type="number" class="prop-input" value="${r.w}" onchange="updateImageRegionSize('w', +this.value)">
                    </div>
                    <div class="prop-row">
                        <span class="prop-label">高度</span>
                        <input type="number" class="prop-input" value="${r.h}" onchange="updateImageRegionSize('h', +this.value)">
                    </div>
                    
                    <div class="section-title" style="margin-top:12px;">🔍 縮放控制</div>
                    <div class="prop-row" style="gap:4px;">
                        <button class="btn btn-outline" style="padding:4px 8px;font-size:14px;" onclick="scaleImageRegionBy(0.5)" title="縮小到50%">½</button>
                        <button class="btn btn-outline" style="padding:4px 8px;font-size:14px;" onclick="scaleImageRegionBy(0.75)" title="縮小到75%">¾</button>
                        <button class="btn btn-outline" style="padding:4px 8px;font-size:14px;background:#333;" onclick="scaleImageRegionBy(1)" title="原始大小">1:1</button>
                        <button class="btn btn-outline" style="padding:4px 8px;font-size:14px;" onclick="scaleImageRegionBy(1.5)" title="放大到150%">1.5x</button>
                        <button class="btn btn-outline" style="padding:4px 8px;font-size:14px;" onclick="scaleImageRegionBy(2)" title="放大到200%">2x</button>
                    </div>
                    <div class="prop-row" style="margin-top:8px;">
                        <button class="btn btn-outline" style="padding:6px 12px;" onclick="stepImageRegionScale(-0.1)" title="縮小 10%">➖</button>
                        <input type="range" class="prop-range" style="flex:1;" value="${Math.round((r.scale || 1) * 100)}" min="10" max="300" 
                            oninput="setImageRegionScale(this.value / 100)">
                        <button class="btn btn-outline" style="padding:6px 12px;" onclick="stepImageRegionScale(0.1)" title="放大 10%">➕</button>
                    </div>
                    <div style="text-align:center;color:#888;font-size:12px;margin-top:4px;">
                        目前縮放: <span style="color:#f59e0b;font-weight:600;">${Math.round((r.scale || 1) * 100)}%</span>
                        （原始: ${r.originalW}×${r.originalH}）
                    </div>
                    
                    <div class="prop-row" style="margin-top:10px;">
                        <span class="prop-label">旋轉</span>
                        <button class="btn btn-outline" style="padding:4px 8px;" onclick="rotateImageRegionBy(-90)" title="逆時針90°">↺</button>
                        <input type="range" class="prop-range" style="flex:1;" value="${r.rotation || 0}" min="-180" max="180" 
                            oninput="updateImageRegionProp('rotation', +this.value)">
                        <button class="btn btn-outline" style="padding:4px 8px;" onclick="rotateImageRegionBy(90)" title="順時針90°">↻</button>
                    </div>
                    <div style="text-align:center;color:#888;font-size:11px;">${r.rotation || 0}°</div>
                </div>
                
                ${r.isWatermark ? `
                <div class="section" style="background:#1a1a2e;border:1px solid #3b82f6;border-radius:8px;padding:10px;">
                    <div class="section-title" style="color:#3b82f6;">💧 浮水印設定</div>
                    <div class="prop-row">
                        <span class="prop-label">透明度</span>
                        <input type="range" class="prop-range" style="flex:1;" value="${Math.round((r.opacity || 1) * 100)}" min="10" max="100" 
                            oninput="updateWatermarkOpacity(this.value / 100)">
                        <span style="margin-left:8px;color:#888;width:40px;">${Math.round((r.opacity || 1) * 100)}%</span>
                    </div>
                    <div style="font-size:10px;color:#3b82f6;margin-top:8px;text-align:center;">
                        💡 調整完成後點擊「固定到圖片」永久套用
                    </div>
                </div>
                ` : `
                <div class="section" style="background:#1a2a1a;border:1px solid #22c55e;border-radius:8px;padding:10px;">
                    <div class="section-title" style="color:#22c55e;">🎭 背景處理</div>
                    <div class="prop-row">
                        <label style="display:flex;align-items:center;gap:8px;cursor:pointer;">
                            <input type="checkbox" ${r.transparentBg ? 'checked' : ''} 
                                onchange="toggleImageTransparentBg(this.checked)">
                            <span class="prop-label" style="margin:0;">去除背景色</span>
                        </label>
                    </div>
                    <div class="prop-row">
                        <span class="prop-label">填充背景色</span>
                        <div class="color-row">
                            <input type="color" class="color-input" value="${r.bgColor}" 
                                onchange="updateImageBgColor(this.value)">
                            <span class="color-hex">${r.bgColor}</span>
                            <button class="btn btn-outline" style="padding:2px 6px;font-size:10px;" 
                                onclick="startImageEyedropper()" title="從圖片吸取背景色">💧</button>
                        </div>
                    </div>
                    <div class="prop-row">
                        <span class="prop-label">容差</span>
                        <input type="range" class="prop-range" value="${r.tolerance || 30}" min="0" max="100" 
                            oninput="updateImageTolerance(+this.value)">
                        <span style="margin-left:8px;color:#888;">${r.tolerance || 30}</span>
                    </div>
                    <div style="margin-top:10px;padding-top:10px;border-top:1px solid #333;">
                        <button class="btn ${r.smartTransparent ? 'btn-primary' : 'btn-outline'}" style="width:100%;font-size:12px;" 
                            onclick="applySmartTransparent(state.activeImageRegion)">
                            🧠 智能去背（保留封閉區域）
                        </button>
                        <div style="font-size:10px;color:#888;margin-top:6px;text-align:center;">
                            只移除邊緣連通的背景，保留線條內的顏色
                        </div>
                    </div>
                    <div style="font-size:10px;color:#22c55e;margin-top:8px;text-align:center;">
                        💡 用取色器 💧 吸取正確的背景色
                    </div>
                </div>
                `}
                
                <div class="btn-group" style="margin-top:12px;">
                    <button class="btn btn-primary" onclick="commitImageRegion()">📌 固定到圖片</button>
                    <button class="btn btn-outline" onclick="cancelImageRegion()">✕ 取消</button>
                </div>
                
                <button class="btn btn-danger" style="width:100%;margin-top:8px;" onclick="deleteImageRegion()">🗑️ 刪除此區塊</button>
            `;
        }
        
        // 更新圖像區塊屬性
        function updateImageRegionProp(prop, value) {
            if (!state.activeImageRegion) return;
            state.activeImageRegion[prop] = value;
            renderImageRegions();
            updateImagePanel();
        }
        
        // 啟動圖像區塊背景取色器
        function startImageEyedropper() {
            if (!state.activeImageRegion) return;
            state.eyedropperTarget = 'imageBgColor';
            setMode('eyedropper');
            toast('點擊圖片吸取背景色', 'info');
        }
        
        // 更新浮水印透明度
        function updateWatermarkOpacity(opacity) {
            if (!state.activeImageRegion || !state.activeImageRegion.isWatermark) return;
            
            const r = state.activeImageRegion;
            r.opacity = Math.max(0.1, Math.min(1, opacity));
            
            // 重新生成帶透明度的圖像數據
            const img = new Image();
            img.onload = () => {
                const wmCanvas = document.createElement('canvas');
                wmCanvas.width = r.originalW;
                wmCanvas.height = r.originalH;
                const wmCtx = wmCanvas.getContext('2d');
                
                wmCtx.globalAlpha = r.opacity;
                wmCtx.drawImage(img, 0, 0, r.originalW, r.originalH);
                
                r.imageData = wmCanvas.toDataURL('image/png');
                
                renderImageRegions();
                updateImagePanel();
            };
            img.src = r.originalImageData;
        }
        
        // 更新圖像區塊背景色並重新填充原位置
        function updateImageBgColor(color) {
            if (!state.activeImageRegion) return;
            
            const r = state.activeImageRegion;
            r.bgColor = color;
            
            // 重新填充原位置
            refillImageRegionOriginalArea(r);
            
            // 如果啟用了透明背景，重新處理
            if (r.transparentBg) {
                processImageTransparentBg(r);
            }
            
            renderImageRegions();
            updateImagePanel();
        }
        
        // 重新填充圖像區塊原位置的背景色
        function refillImageRegionOriginalArea(r) {
            if (!r) return;
            
            // 使用新的背景色填充原位置
            if (r.type === 'lasso' && r.originalLassoPath) {
                // 套索區域：填充原始路徑
                ctx.save();
                ctx.beginPath();
                ctx.moveTo(r.originalLassoPath[0].x, r.originalLassoPath[0].y);
                for (let i = 1; i < r.originalLassoPath.length; i++) {
                    ctx.lineTo(r.originalLassoPath[i].x, r.originalLassoPath[i].y);
                }
                ctx.closePath();
                ctx.fillStyle = r.bgColor;
                ctx.fill();
                ctx.restore();
            } else {
                // 矩形區域：填充原始位置
                ctx.fillStyle = r.bgColor;
                ctx.fillRect(r.originalX, r.originalY, r.originalW, r.originalH);
            }
        }
        
        // 更新圖像區塊大小（保持比例）
        function updateImageRegionSize(prop, value) {
            if (!state.activeImageRegion) return;
            
            const r = state.activeImageRegion;
            const ratio = r.originalW / r.originalH;
            
            if (prop === 'w') {
                r.w = Math.max(20, value);
                r.h = Math.round(r.w / ratio);
            } else {
                r.h = Math.max(20, value);
                r.w = Math.round(r.h * ratio);
            }
            
            r.scale = r.w / r.originalW;
            
            renderImageRegions();
            updateImagePanel();
        }
        
        // 設置圖像區塊縮放
        function setImageRegionScale(scale) {
            if (!state.activeImageRegion) return;
            
            const r = state.activeImageRegion;
            r.scale = Math.max(0.1, Math.min(3, scale));
            r.w = Math.round(r.originalW * r.scale);
            r.h = Math.round(r.originalH * r.scale);
            
            renderImageRegions();
            updateImagePanel();
        }
        
        // 設定圖像區塊縮放到指定倍數
        function scaleImageRegionBy(targetScale) {
            if (!state.activeImageRegion) return;
            setImageRegionScale(targetScale);
            toast(`縮放至 ${Math.round(targetScale * 100)}%`, 'info');
        }
        
        // 步進縮放（增加或減少）
        function stepImageRegionScale(delta) {
            if (!state.activeImageRegion) return;
            const currentScale = state.activeImageRegion.scale || 1;
            const newScale = Math.max(0.1, Math.min(3, currentScale + delta));
            setImageRegionScale(newScale);
        }
        
        // 旋轉圖像區塊指定角度
        function rotateImageRegionBy(degrees) {
            if (!state.activeImageRegion) return;
            const r = state.activeImageRegion;
            r.rotation = ((r.rotation || 0) + degrees) % 360;
            if (r.rotation > 180) r.rotation -= 360;
            if (r.rotation < -180) r.rotation += 360;
            renderImageRegions();
            updateImagePanel();
            toast(`旋轉至 ${r.rotation}°`, 'info');
        }
        
        // 切換透明背景
        function toggleImageTransparentBg(enabled) {
            if (!state.activeImageRegion) return;
            
            const r = state.activeImageRegion;
            r.transparentBg = enabled;
            
            if (enabled) {
                // 處理透明背景
                processImageTransparentBg(r);
            } else {
                // 還原原始圖像
                if (r.originalImageData) {
                    r.imageData = r.originalImageData;
                    r.processedTransparent = false;
                }
            }
            
            renderImageRegions();
            updateImagePanel();
        }
        
        // 更新背景去除容差
        function updateImageTolerance(value) {
            if (!state.activeImageRegion) return;
            
            const r = state.activeImageRegion;
            r.tolerance = value;
            
            if (r.transparentBg) {
                processImageTransparentBg(r);
            }
            
            renderImageRegions();
            updateImagePanel();
        }
        
        // 處理圖像透明背景
        function processImageTransparentBg(r) {
            // 創建臨時 canvas 載入圖像
            const img = new Image();
            img.onload = () => {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = r.originalW;
                tempCanvas.height = r.originalH;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(img, 0, 0);
                
                const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                const data = imageData.data;
                
                // 解析背景色
                const bgR = parseInt(r.bgColor.slice(1, 3), 16);
                const bgG = parseInt(r.bgColor.slice(3, 5), 16);
                const bgB = parseInt(r.bgColor.slice(5, 7), 16);
                
                const tolerance = r.tolerance || 30;
                
                // 智能去背模式
                if (r.smartTransparent) {
                    processSmartTransparent(data, tempCanvas.width, tempCanvas.height, bgR, bgG, bgB, tolerance);
                } else {
                    // 將背景色設為透明
                    for (let i = 0; i < data.length; i += 4) {
                        const pR = data[i];
                        const pG = data[i + 1];
                        const pB = data[i + 2];
                        
                        const diff = Math.abs(pR - bgR) + Math.abs(pG - bgG) + Math.abs(pB - bgB);
                        
                        if (diff < tolerance * 3) {
                            data[i + 3] = 0; // 設為透明
                        }
                    }
                }
                
                tempCtx.putImageData(imageData, 0, 0);
                r.imageData = tempCanvas.toDataURL('image/png');
                r.processedTransparent = true;
                
                renderImageRegions();
            };
            
            // 如果已經處理過，使用原始數據
            if (!r.originalImageData) {
                r.originalImageData = r.imageData;
            }
            img.src = r.originalImageData;
        }
        
        // 同步版本的透明背景處理（選取時立即執行）
        function processImageTransparentBgSync(r) {
            if (!r || !r.originalImageData) return;
            
            try {
                // 創建臨時 canvas
                const img = new Image();
                img.src = r.originalImageData;
                
                // 使用 onload 確保圖像載入
                img.onload = () => {
                    try {
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = r.originalW;
                        tempCanvas.height = r.originalH;
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCtx.drawImage(img, 0, 0);
                        
                        const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                        const data = imageData.data;
                        
                        // 解析背景色
                        const bgR = parseInt(r.bgColor.slice(1, 3), 16);
                        const bgG = parseInt(r.bgColor.slice(3, 5), 16);
                        const bgB = parseInt(r.bgColor.slice(5, 7), 16);
                        
                        const tolerance = r.tolerance || 30;
                        
                        // 智能去背模式：只移除從邊緣連通的背景
                        if (r.smartTransparent) {
                            processSmartTransparent(data, tempCanvas.width, tempCanvas.height, bgR, bgG, bgB, tolerance);
                        } else {
                            // 將背景色設為透明（原本的方式）
                            for (let i = 0; i < data.length; i += 4) {
                                const pR = data[i];
                                const pG = data[i + 1];
                                const pB = data[i + 2];
                                
                                const diff = Math.abs(pR - bgR) + Math.abs(pG - bgG) + Math.abs(pB - bgB);
                                
                                if (diff < tolerance * 3) {
                                    data[i + 3] = 0; // 設為透明
                                }
                            }
                        }
                        
                        tempCtx.putImageData(imageData, 0, 0);
                        r.imageData = tempCanvas.toDataURL('image/png');
                        r.processedTransparent = true;
                        
                        // 重新渲染
                        renderImageRegions();
                    } catch(e) {
                        // 靜默忽略
                    }
                };
            } catch(e) {
                // 靜默忽略
            }
        }
        
        // 智能去背：使用 flood fill 從邊緣開始，只移除連通的背景
        function processSmartTransparent(data, width, height, bgR, bgG, bgB, tolerance) {
            const visited = new Uint8Array(width * height);
            const toRemove = new Uint8Array(width * height);
            const queue = [];
            
            // 檢查像素是否與背景色相似
            function isSimilarToBg(idx) {
                const pR = data[idx];
                const pG = data[idx + 1];
                const pB = data[idx + 2];
                const diff = Math.abs(pR - bgR) + Math.abs(pG - bgG) + Math.abs(pB - bgB);
                return diff < tolerance * 3;
            }
            
            // 從邊緣開始的種子點
            // 上邊緣
            for (let x = 0; x < width; x++) {
                const pixelIdx = x;
                const dataIdx = pixelIdx * 4;
                if (!visited[pixelIdx] && isSimilarToBg(dataIdx)) {
                    queue.push(pixelIdx);
                    visited[pixelIdx] = 1;
                }
            }
            // 下邊緣
            for (let x = 0; x < width; x++) {
                const pixelIdx = (height - 1) * width + x;
                const dataIdx = pixelIdx * 4;
                if (!visited[pixelIdx] && isSimilarToBg(dataIdx)) {
                    queue.push(pixelIdx);
                    visited[pixelIdx] = 1;
                }
            }
            // 左邊緣
            for (let y = 0; y < height; y++) {
                const pixelIdx = y * width;
                const dataIdx = pixelIdx * 4;
                if (!visited[pixelIdx] && isSimilarToBg(dataIdx)) {
                    queue.push(pixelIdx);
                    visited[pixelIdx] = 1;
                }
            }
            // 右邊緣
            for (let y = 0; y < height; y++) {
                const pixelIdx = y * width + (width - 1);
                const dataIdx = pixelIdx * 4;
                if (!visited[pixelIdx] && isSimilarToBg(dataIdx)) {
                    queue.push(pixelIdx);
                    visited[pixelIdx] = 1;
                }
            }
            
            // BFS flood fill
            while (queue.length > 0) {
                const pixelIdx = queue.shift();
                toRemove[pixelIdx] = 1;
                
                const x = pixelIdx % width;
                const y = Math.floor(pixelIdx / width);
                
                // 檢查 4 鄰域
                const neighbors = [
                    { nx: x - 1, ny: y },
                    { nx: x + 1, ny: y },
                    { nx: x, ny: y - 1 },
                    { nx: x, ny: y + 1 }
                ];
                
                for (const { nx, ny } of neighbors) {
                    if (nx < 0 || nx >= width || ny < 0 || ny >= height) continue;
                    
                    const neighborIdx = ny * width + nx;
                    if (visited[neighborIdx]) continue;
                    
                    visited[neighborIdx] = 1;
                    const dataIdx = neighborIdx * 4;
                    
                    if (isSimilarToBg(dataIdx)) {
                        queue.push(neighborIdx);
                    }
                }
            }
            
            // 將標記的像素設為透明
            for (let i = 0; i < toRemove.length; i++) {
                if (toRemove[i]) {
                    data[i * 4 + 3] = 0;
                }
            }
        }
        
        // 對圖像區塊應用智能去背
        function applySmartTransparent(r) {
            if (!r || !r.originalImageData) return;
            
            r.smartTransparent = true;
            r.transparentBg = true;
            
            const img = new Image();
            img.onload = () => {
                try {
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = r.originalW;
                    tempCanvas.height = r.originalH;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.drawImage(img, 0, 0);
                    
                    const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                    const data = imageData.data;
                    
                    // 自動偵測背景色（如果是預設白色的話）
                    let bgR, bgG, bgB;
                    if (r.bgColor === '#ffffff' || r.bgColor === '#FFFFFF') {
                        const detected = detectEdgeBackgroundColor(data, tempCanvas.width, tempCanvas.height);
                        bgR = detected.r;
                        bgG = detected.g;
                        bgB = detected.b;
                        r.bgColor = `#${bgR.toString(16).padStart(2,'0')}${bgG.toString(16).padStart(2,'0')}${bgB.toString(16).padStart(2,'0')}`;
                    } else {
                        bgR = parseInt(r.bgColor.slice(1, 3), 16);
                        bgG = parseInt(r.bgColor.slice(3, 5), 16);
                        bgB = parseInt(r.bgColor.slice(5, 7), 16);
                    }
                    
                    const tolerance = r.tolerance || 30;
                    
                    processSmartTransparent(data, tempCanvas.width, tempCanvas.height, bgR, bgG, bgB, tolerance);
                    
                    tempCtx.putImageData(imageData, 0, 0);
                    r.imageData = tempCanvas.toDataURL('image/png');
                    r.processedTransparent = true;
                    
                    // 更新原位置的背景色
                    refillImageRegionOriginalArea(r);
                    
                    renderImageRegions();
                    updateImagePanel();
                    toast(`已套用智能去背（背景色: ${r.bgColor}）`, 'success');
                } catch(e) {
                    toast('智能去背失敗', 'error');
                }
            };
            img.src = r.originalImageData;
        }
        
        // 對 OCR 文字區塊應用智能去背（創建浮動時）
        function createSmartFloatingRegion(r) {
            const pad = r.padding || 5;
            
            // 保存歷史
            saveHistory('智能去背浮動');
            
            // 獲取原始區域的圖像數據
            const coverX = Math.max(0, Math.floor(r.x - pad));
            const coverY = Math.max(0, Math.floor(r.y - pad));
            const coverW = Math.ceil(r.w + pad * 2);
            const coverH = Math.ceil(r.h + pad * 2);
            
            const regionData = ctx.getImageData(coverX, coverY, coverW, coverH);
            const data = regionData.data;
            
            // 自動偵測邊緣背景色（從四個角落取樣）
            const detectedBgColor = detectEdgeBackgroundColor(data, coverW, coverH);
            const bgR = detectedBgColor.r;
            const bgG = detectedBgColor.g;
            const bgB = detectedBgColor.b;
            const bgHex = `#${bgR.toString(16).padStart(2,'0')}${bgG.toString(16).padStart(2,'0')}${bgB.toString(16).padStart(2,'0')}`;
            
            // 更新區塊的背景色
            r.bgColor = bgHex;
            
            const tolerance = r.tolerance || 30;
            
            // 使用智能去背
            processSmartTransparent(data, coverW, coverH, bgR, bgG, bgB, tolerance);
            
            // 創建透明背景的圖像
            const offCanvas = document.createElement('canvas');
            offCanvas.width = coverW;
            offCanvas.height = coverH;
            const offCtx = offCanvas.getContext('2d');
            offCtx.putImageData(regionData, 0, 0);
            
            // 用偵測到的背景色清除原區域
            ctx.fillStyle = bgHex;
            ctx.fillRect(coverX, coverY, coverW, coverH);
            
            // 保存浮動圖像數據
            r.floatingImage = offCanvas.toDataURL('image/png');
            r.isFloating = true;
            r.edited = true;
            r.smartTransparent = true;
            
            // 保持選中狀態以便移動
            state.activeRegion = r;
            
            renderRegions();
            updatePanel();
            updateUndoButton();
            toast(`已建立智能去背浮動區塊（背景色: ${bgHex}）`, 'success');
        }
        
        // 偵測邊緣背景色（從邊緣像素取樣）
        function detectEdgeBackgroundColor(data, width, height) {
            const samples = [];
            
            // 從四個邊緣取樣
            const samplePoints = [];
            
            // 上邊緣
            for (let x = 0; x < width; x += Math.max(1, Math.floor(width / 10))) {
                samplePoints.push({ x, y: 0 });
            }
            // 下邊緣
            for (let x = 0; x < width; x += Math.max(1, Math.floor(width / 10))) {
                samplePoints.push({ x, y: height - 1 });
            }
            // 左邊緣
            for (let y = 0; y < height; y += Math.max(1, Math.floor(height / 10))) {
                samplePoints.push({ x: 0, y });
            }
            // 右邊緣
            for (let y = 0; y < height; y += Math.max(1, Math.floor(height / 10))) {
                samplePoints.push({ x: width - 1, y });
            }
            // 四個角落（權重較高）
            const corners = [
                { x: 0, y: 0 },
                { x: width - 1, y: 0 },
                { x: 0, y: height - 1 },
                { x: width - 1, y: height - 1 }
            ];
            corners.forEach(c => {
                for (let i = 0; i < 3; i++) samplePoints.push(c); // 角落權重 x3
            });
            
            // 取樣顏色
            for (const { x, y } of samplePoints) {
                const idx = (y * width + x) * 4;
                if (idx >= 0 && idx < data.length - 3) {
                    samples.push({
                        r: data[idx],
                        g: data[idx + 1],
                        b: data[idx + 2]
                    });
                }
            }
            
            if (samples.length === 0) {
                return { r: 255, g: 255, b: 255 }; // 預設白色
            }
            
            // 找出最常見的顏色（使用顏色分組）
            const colorGroups = {};
            const groupTolerance = 20;
            
            for (const sample of samples) {
                // 將顏色量化到分組
                const keyR = Math.round(sample.r / groupTolerance) * groupTolerance;
                const keyG = Math.round(sample.g / groupTolerance) * groupTolerance;
                const keyB = Math.round(sample.b / groupTolerance) * groupTolerance;
                const key = `${keyR},${keyG},${keyB}`;
                
                if (!colorGroups[key]) {
                    colorGroups[key] = { count: 0, totalR: 0, totalG: 0, totalB: 0 };
                }
                colorGroups[key].count++;
                colorGroups[key].totalR += sample.r;
                colorGroups[key].totalG += sample.g;
                colorGroups[key].totalB += sample.b;
            }
            
            // 找出最大的分組
            let maxGroup = null;
            let maxCount = 0;
            for (const key in colorGroups) {
                if (colorGroups[key].count > maxCount) {
                    maxCount = colorGroups[key].count;
                    maxGroup = colorGroups[key];
                }
            }
            
            if (maxGroup) {
                return {
                    r: Math.round(maxGroup.totalR / maxGroup.count),
                    g: Math.round(maxGroup.totalG / maxGroup.count),
                    b: Math.round(maxGroup.totalB / maxGroup.count)
                };
            }
            
            return { r: 255, g: 255, b: 255 };
        }
        
        // 確認圖像區塊
        function commitImageRegion() {
            if (!state.activeImageRegion) return;
            
            const r = state.activeImageRegion;
            const isLasso = r.type === 'lasso' && r.lassoPath;
            const isWatermark = r.isWatermark;
            
            saveHistory(isWatermark ? '固定浮水印' : '固定圖像區塊');
            
            // 繪製到主畫布
            const img = new Image();
            img.onload = () => {
                ctx.save();
                
                // 如果是浮水印，設置透明度
                if (isWatermark && r.opacity) {
                    ctx.globalAlpha = r.opacity;
                }
                
                // 旋轉繪製
                const centerX = r.x + r.w / 2;
                const centerY = r.y + r.h / 2;
                
                ctx.translate(centerX, centerY);
                ctx.rotate((r.rotation || 0) * Math.PI / 180);
                
                if (isLasso) {
                    // 套索區域：使用剪裁路徑
                    const scaleX = r.w / r.originalW;
                    const scaleY = r.h / r.originalH;
                    
                    ctx.beginPath();
                    ctx.moveTo(
                        r.lassoPath[0].x * scaleX - r.w / 2,
                        r.lassoPath[0].y * scaleY - r.h / 2
                    );
                    for (let i = 1; i < r.lassoPath.length; i++) {
                        ctx.lineTo(
                            r.lassoPath[i].x * scaleX - r.w / 2,
                            r.lassoPath[i].y * scaleY - r.h / 2
                        );
                    }
                    ctx.closePath();
                    ctx.clip();
                }
                
                // 對於浮水印，使用原始圖像數據（不帶預乘透明度）
                if (isWatermark) {
                    const wmImg = new Image();
                    wmImg.onload = () => {
                        ctx.drawImage(wmImg, -r.w / 2, -r.h / 2, r.w, r.h);
                        ctx.restore();
                        
                        // 移除此圖像區塊
                        finishCommit(r);
                    };
                    wmImg.src = r.originalImageData;
                } else {
                    ctx.drawImage(img, -r.w / 2, -r.h / 2, r.w, r.h);
                    ctx.restore();
                    
                    // 移除此圖像區塊
                    finishCommit(r);
                }
            };
            img.src = r.imageData;
            
            function finishCommit(region) {
                const idx = state.imageRegions.indexOf(region);
                if (idx > -1) state.imageRegions.splice(idx, 1);
                
                state.activeImageRegion = null;
                
                // 更新多頁 PDF 數據
                if (state.pdfPages.length > 0) {
                    state.pdfPages[state.currentPdfPage].editedData = canvas.toDataURL('image/jpeg', 0.92);
                }
                
                renderImageRegions();
                updatePanel();
                updateUndoButton();
                
                toast(region.isWatermark ? '浮水印已固定到圖片' : '圖像已固定到畫布', 'success');
            }
        }
        
        // 取消圖像區塊
        function cancelImageRegion() {
            if (!state.activeImageRegion) return;
            
            // 還原原位置
            undoLast();
            
            // 移除此圖像區塊
            const idx = state.imageRegions.indexOf(state.activeImageRegion);
            if (idx > -1) state.imageRegions.splice(idx, 1);
            
            state.activeImageRegion = null;
            
            renderImageRegions();
            updatePanel();
            
            toast('已取消圖像選取', 'info');
        }
        
        // 刪除圖像區塊
        function deleteImageRegion() {
            if (!state.activeImageRegion) return;
            
            const idx = state.imageRegions.indexOf(state.activeImageRegion);
            if (idx > -1) state.imageRegions.splice(idx, 1);
            
            state.activeImageRegion = null;
            
            renderImageRegions();
            updatePanel();
            
            toast('已刪除圖像區塊', 'success');
        }

        async function processRegion(x, y, w, h) {
            showLoading('載入 OCR 引擎...');
            
            // 延遲載入 Tesseract
            const loaded = await loadTesseract();
            if (!loaded) {
                hideLoading();
                createManualTextRegion(x, y, w, h);
                toast('📝 已建立文字區塊，請在右側輸入文字', 'warning');
                return;
            }
            
            showLoading('辨識文字中...');
            
            try {
                // 提取區域
                const regionData = ctx.getImageData(x, y, w, h);
                const colors = analyzeColors(regionData);
                
                // 分析文字實際高度（從像素分析，非框選高度）
                const textInfo = analyzeTextHeight(regionData, colors.bgColor);
                // 字體大小 = 實際文字像素高度 × 0.85（CSS font-size 與渲染高度的換算）
                const fontSize = Math.max(12, Math.round(textInfo.textHeight * 0.85));
                
                // OCR
                const regionCanvas = document.createElement('canvas');
                regionCanvas.width = w;
                regionCanvas.height = h;
                regionCanvas.getContext('2d').putImageData(regionData, 0, 0);
                
                setProgress(10);
                
                let result;
                try {
                    // OCR 辨識，5 秒超時
                    const ocrPromise = Tesseract.recognize(regionCanvas.toDataURL(), 'chi_tra+eng', {
                        logger: m => {
                            if (m.status === 'recognizing text') {
                                setProgress(10 + Math.round(m.progress * 80));
                            }
                        }
                    });
                    
                    const timeoutPromise = new Promise((_, reject) => {
                        setTimeout(() => reject(new Error('OCR 超時')), 5000);
                    });
                    
                    result = await Promise.race([ocrPromise, timeoutPromise]);
                } catch (ocrError) {
                    hideLoading();
                    createManualTextRegion(x, y, w, h);
                    toast('📝 已建立文字區塊，請在右側輸入文字', 'warning');
                    return;
                }
                
                // 清理 OCR 結果：移除中文字之間的空白
                const rawText = result.data.text.trim();
                const text = cleanOcrText(rawText);
                
                // 嘗試按字組分割（若同行有大間距或分隔符號）
                const ocrLines = result.data.lines || [];
                let wordGroups = [];
                ocrLines.forEach(l => {
                    if (l.text.trim() && l.confidence > 30) {
                        const groups = splitLineIntoWordGroups(l);
                        // 將 bbox 從全圖座標偏移到框選座標
                        groups.forEach(g => {
                            wordGroups.push(g);
                        });
                    }
                });
                
                // 如果有多個字組，各自建立區塊
                if (wordGroups.length > 1) {
                    let addedCount = 0;
                    wordGroups.forEach((group, gi) => {
                        const region = createRegionFromWordGroup(group, gi);
                        if (region) {
                            state.regions.push(region);
                            if (gi === 0) state.activeRegion = region;
                            addedCount++;
                        }
                    });
                    renderRegions();
                    updatePanel();
                    hideLoading();
                    toast(`已識別 ${addedCount} 個文字區塊`, 'success');
                    return;
                }
                
                // 只有一組（或無法分割），沿用原邏輯建立單一區塊
                // 分析文字樣式（字體、粗細）
                const textStyle = analyzeTextStyle(regionData, text, colors.bgColor);
                
                // 創建區域
                const region = {
                    id: Date.now(),
                    x, y, w, h,
                    originalText: text,
                    text: text,
                    fontSize,
                    fontFamily: textStyle.fontFamily,
                    fontWeight: textStyle.fontWeight,
                    scaleY: 1.0,
                    color: colors.textColor,
                    bgColor: colors.bgColor,
                    transparentBg: true,
                    padding: 5,
                    textAlign: 'left',
                    lineHeight: 1.2,
                    letterSpacing: 0,
                    strokeColor: '#000000',
                    strokeWidth: 0,
                    shadowColor: '#000000',
                    shadowBlur: 0,
                    shadowOffsetX: 0,
                    shadowOffsetY: 0,
                    rotation: 0,
                    gradientEnabled: false,
                    gradientColor1: '#ff0000',
                    gradientColor2: '#0000ff',
                    gradientDirection: 'horizontal',
                    curveEnabled: false,
                    curveRadius: 100,
                    curveStartAngle: 0,
                    edited: false,
                    layerIndex: activeLayerIndex
                };
                
                state.regions.push(region);
                state.activeRegion = region;
                
                renderRegions();
                updatePanel();
                hideLoading();
                
                toast('已識別文字區域', 'success');
                
            } catch (e) {
                // console.error(e);
                hideLoading();
                toast('識別失敗', 'error');
            }
        }

        async function detectAll() {
            if (!state.image) {
                toast('請先載入圖片', 'error');
                return;
            }
            
            showLoading('載入 OCR 引擎...');
            
            // 延遲載入 Tesseract
            const loaded = await loadTesseract();
            if (!loaded) {
                hideLoading();
                toast('OCR 不可用，請使用框選模式手動輸入', 'warning');
                return;
            }
            
            showLoading('全圖偵測中...');
            
            try {
                let result;
                try {
                    // OCR 辨識，添加 20 秒超時保護（全圖需要更長時間）
                    const ocrPromise = Tesseract.recognize(canvas.toDataURL(), 'chi_tra+eng', {
                        logger: m => {
                            if (m.status === 'recognizing text') {
                                setProgress(Math.round(m.progress * 100));
                            }
                        }
                    });
                    
                    const timeoutPromise = new Promise((_, reject) => {
                        setTimeout(() => reject(new Error('OCR 超時')), 20000);
                    });
                    
                    result = await Promise.race([ocrPromise, timeoutPromise]);
                } catch (ocrError) {
                    hideLoading();
                    toast('OCR 失敗，請使用框選模式手動輸入', 'warning');
                    return;
                }
                
                const lines = result.data.lines.filter(l => l.text.trim() && l.confidence > 35);
                let addedGroupCount = 0;
                
                lines.forEach((line, i) => {
                    // 使用字組分割：同一行中間距過大或有分隔符號則拆分
                    const wordGroups = splitLineIntoWordGroups(line);
                    
                    wordGroups.forEach((group, gi) => {
                        const region = createRegionFromWordGroup(group, i * 100 + gi);
                        if (region) {
                            state.regions.push(region);
                            addedGroupCount++;
                        }
                    });
                });
                
                renderRegions();
                updatePanel();
                hideLoading();
                toast(`偵測到 ${addedGroupCount} 個文字區塊（${lines.length} 行）`, 'success');
                
            } catch (e) {
                // console.error(e);
                hideLoading();
                toast('偵測失敗', 'error');
            }
        }

        function renderRegions() {
            regionsLayer.innerHTML = '';
            
            // 過濾只顯示可見圖層的物件
            state.regions.filter(region => isLayerVisible(region.layerIndex)).forEach(region => {
                const isMultiSelected = state.selectedRegions.includes(region);
                const isMagicWand = region.selectedPixels && region.selectedPixels.length > 0;
                const isFloating = region.isFloating;
                
                const div = document.createElement('div');
                div.className = 'edit-region' + 
                    (region === state.activeRegion ? ' active' : '') + 
                    (region.edited ? ' edited' : '') +
                    (isMultiSelected ? ' multi-selected' : '') +
                    (isMagicWand ? ' magic-wand' : '') +
                    (isFloating ? ' floating' : '');
                div.style.cssText = `
                    left: ${region.x}px;
                    top: ${region.y}px;
                    width: ${region.w}px;
                    height: ${region.h}px;
                    cursor: ${region.edited || isFloating ? 'move' : 'pointer'};
                    ${isMagicWand ? 'border-style: dashed; background: transparent;' : ''}
                    ${isFloating ? 'border-color: #22c55e; border-width: 2px; background: transparent;' : ''}
                `;
                
                // 如果是浮動文字，顯示圖像
                if (isFloating && region.floatingImage) {
                    const pad = region.padding || 5;
                    const img = document.createElement('img');
                    img.src = region.floatingImage;
                    img.style.cssText = `
                        position: absolute;
                        left: -${pad}px;
                        top: -${pad}px;
                        width: ${region.w + pad * 2}px;
                        height: ${region.h + pad * 2}px;
                        pointer-events: none;
                    `;
                    div.appendChild(img);
                }
                
                // 點擊選取
                div.onclick = (e) => {
                    if (state.isDragging) return;
                    e.stopPropagation();
                    selectRegion(region);
                    
                    // 如果是魔術棒區域，重新顯示選取預覽
                    if (region.selectedPixels && region.selectedPixels.length > 0) {
                        showSelectionPreview(region.selectedPixels);
                    }
                };
                
                // 右鍵多選
                div.oncontextmenu = (e) => {
                    toggleMultiSelect(e, region);
                };
                
                // 拖動功能（已編輯區塊或浮動文字）
                if (region.edited || isFloating) {
                    div.onmousedown = (e) => {
                        if (e.button !== 0) return; // 只回應左鍵
                        e.stopPropagation();
                        startDrag(e, region);
                    };
                }
                
                regionsLayer.appendChild(div);
            });
            
            // 如果當前選取的是魔術棒區域，顯示選取預覽
            if (state.activeRegion && state.activeRegion.selectedPixels && state.activeRegion.selectedPixels.length > 0) {
                showSelectionPreview(state.activeRegion.selectedPixels);
            }
        }
        
        function startDrag(e, region) {
            state.isDragging = true;
            state.dragRegion = region;
            state.dragStartPos = { x: region.x, y: region.y };
            
            const rect = canvasContainer.getBoundingClientRect();
            const mouseX = (e.clientX - rect.left) / state.displayScale;
            const mouseY = (e.clientY - rect.top) / state.displayScale;
            
            state.dragOffset = {
                x: mouseX - region.x,
                y: mouseY - region.y
            };
            
            // 保存拖動前的整個 canvas 狀態（用於恢復原位置）
            state.dragOriginalImage = ctx.getImageData(0, 0, canvas.width, canvas.height);
            
            document.addEventListener('mousemove', onDragMove);
            document.addEventListener('mouseup', onDragEnd);
        }
        
        function onDragMove(e) {
            if (!state.isDragging || !state.dragRegion) return;
            
            const rect = canvasContainer.getBoundingClientRect();
            const mouseX = (e.clientX - rect.left) / state.displayScale;
            const mouseY = (e.clientY - rect.top) / state.displayScale;
            
            const newX = Math.max(0, Math.min(canvas.width - state.dragRegion.w, mouseX - state.dragOffset.x));
            const newY = Math.max(0, Math.min(canvas.height - state.dragRegion.h, mouseY - state.dragOffset.y));
            
            state.dragRegion.x = Math.round(newX);
            state.dragRegion.y = Math.round(newY);
            
            renderRegions();
        }
        
        function onDragEnd(e) {
            if (!state.isDragging || !state.dragRegion) {
                state.isDragging = false;
                return;
            }
            
            const region = state.dragRegion;
            const startPos = state.dragStartPos;
            const pad = region.padding || 5;
            
            // 檢查是否有移動
            const moved = Math.abs(region.x - startPos.x) > 2 || Math.abs(region.y - startPos.y) > 2;
            
            // 浮動文字移動（只更新位置，不重繪畫布）
            if (region.isFloating) {
                if (moved) {
                    toast('已移動浮動文字', 'info');
                }
                document.removeEventListener('mousemove', onDragMove);
                document.removeEventListener('mouseup', onDragEnd);
                
                state.isDragging = false;
                state.dragRegion = null;
                state.dragOffset = null;
                state.dragStartPos = null;
                state.dragOriginalImage = null;
                
                selectRegion(region);
                return;
            }
            
            // 一般區域移動
            if (moved && state.dragOriginalImage) {
                // 保存歷史
                saveHistory('移動區域');
                
                // 1. 恢復原始圖像
                ctx.putImageData(state.dragOriginalImage, 0, 0);
                
                // 2. 計算清除範圍（考慮描邊、陰影等效果）
                const strokeW = region.strokeWidth || 0;
                const shadowBlur = region.shadowBlur || 0;
                const shadowOffsetX = Math.abs(region.shadowOffsetX || 0);
                const shadowOffsetY = Math.abs(region.shadowOffsetY || 0);
                const extraPad = Math.max(20, strokeW + shadowBlur + Math.max(shadowOffsetX, shadowOffsetY) + 10);
                
                // 用背景色清除原位置
                const oldCoverX = Math.max(0, startPos.x - pad - extraPad);
                const oldCoverY = Math.max(0, startPos.y - pad - extraPad);
                const oldCoverW = Math.min(region.w + (pad + extraPad) * 2, canvas.width - oldCoverX);
                const oldCoverH = Math.min(region.h + (pad + extraPad) * 2, canvas.height - oldCoverY);
                ctx.fillStyle = region.bgColor;
                ctx.fillRect(oldCoverX, oldCoverY, oldCoverW, oldCoverH);
                
                // 3. 在新位置繪製背景
                const newCoverX = Math.max(0, region.x - pad);
                const newCoverY = Math.max(0, region.y - pad);
                const newCoverW = Math.min(region.w + pad * 2, canvas.width - newCoverX);
                const newCoverH = Math.min(region.h + pad * 2, canvas.height - newCoverY);
                ctx.fillStyle = region.bgColor;
                ctx.fillRect(newCoverX, newCoverY, newCoverW, newCoverH);
                
                // 4. 繪製文字（帶縮放）
                drawTextWithScale(region);
                
                updateUndoButton();
                toast('已移動區塊', 'success');
            }
            
            document.removeEventListener('mousemove', onDragMove);
            document.removeEventListener('mouseup', onDragEnd);
            
            state.isDragging = false;
            state.dragRegion = null;
            state.dragOffset = null;
            state.dragStartPos = null;
            state.dragOriginalImage = null;
            
            selectRegion(region);
        }

        function selectRegion(region) {
            state.activeRegion = region;
            // 清除圖像區塊選取
            state.activeImageRegion = null;
            renderRegions();
            renderImageRegions();
            updatePanel();
            
            // 自動捲動導航列表到選中項目
            setTimeout(() => {
                const navList = document.getElementById('region-nav-list');
                if (navList) {
                    const visibleRegions = state.regions.filter(rr => isLayerVisible(rr.layerIndex));
                    const idx = visibleRegions.indexOf(region);
                    if (idx >= 0) {
                        const item = navList.children[idx];
                        if (item) item.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
                    }
                }
            }, 50);
        }
        
        // 導航到上一個/下一個區塊
        function navigateRegion(dir) {
            const visibleRegions = state.regions.filter(rr => isLayerVisible(rr.layerIndex));
            if (visibleRegions.length < 2) return;
            const currentIdx = visibleRegions.indexOf(state.activeRegion);
            const newIdx = currentIdx + dir;
            if (newIdx >= 0 && newIdx < visibleRegions.length) {
                selectRegion(visibleRegions[newIdx]);
            }
        }
        
        // 將目前區塊的樣式套用到所有區塊
        function batchApplyCurrentStyle() {
            if (!state.activeRegion) return;
            const src = state.activeRegion;
            const styleProps = ['fontFamily', 'fontSize', 'fontWeight', 'color', 'bgColor', 'direction', 
                'lineHeight', 'letterSpacing', 'scaleY', 'textAlign', 'strokeWidth', 'strokeColor',
                'shadowBlur', 'shadowColor', 'shadowOffsetX', 'shadowOffsetY', 'padding', 'transparentBg'];
            const visibleRegions = state.regions.filter(rr => isLayerVisible(rr.layerIndex) && rr !== src);
            if (visibleRegions.length === 0) return;
            
            if (!confirm(`確定將目前樣式套用到其他 ${visibleRegions.length} 個區塊？`)) return;
            
            visibleRegions.forEach(r => {
                styleProps.forEach(p => {
                    if (src[p] !== undefined) r[p] = src[p];
                });
            });
            renderRegions();
            updatePanel();
            toast(`已套用樣式到 ${visibleRegions.length} 個區塊`, 'success');
        }
        
        // 一次確認所有未確認的區塊
        function commitAllRegions() {
            const pendingRegions = state.regions.filter(r => 
                !r.edited && r.text && r.text.trim() && !r.isFloating && !r.transparentBg && isLayerVisible(r.layerIndex)
            );
            if (pendingRegions.length === 0) {
                toast('沒有需要確認的區塊', 'info');
                return;
            }
            if (!confirm(`確定一次確認 ${pendingRegions.length} 個區塊的修改？`)) return;
            
            saveHistory('批次確認文字');
            
            pendingRegions.forEach(r => {
                commitRegionSilent(r);
            });
            state.activeRegion = null;
            renderRegions();
            updatePanel();
            updateUndoButton();
            toast(`已確認 ${pendingRegions.length} 個區塊`, 'success');
        }
        
        // 靜默確認區塊（不觸發 UI 更新）
        function commitRegionSilent(r) {
            if (!r || !r.text || r.edited) return;
            if (r.transparentBg || r.isFloating) return; // 跳過浮動/透明
            
            const pad = r.padding || 5;
            const coverX = Math.max(0, r.x - pad);
            const coverY = Math.max(0, r.y - pad);
            
            // 背景填充
            ctx.fillStyle = r.bgColor;
            ctx.fillRect(coverX, coverY, r.w + pad * 2, r.h + pad * 2);
            
            // 繪製文字
            drawTextWithScale(r);
            
            r.edited = true;
        }

        function updatePanel() {
            const panel = document.getElementById('panel-content');
            
            // 優先顯示圖像區塊面板
            if (state.activeImageRegion) {
                updateImagePanel();
                return;
            }
            
            if (state.activeRegion) {
                const r = state.activeRegion;
                const activeIdx = state.regions.indexOf(r);
                const totalRegions = state.regions.filter(rr => isLayerVisible(rr.layerIndex)).length;
                
                // 生成字型選項
                const fontOptions = FONT_OPTIONS.map(f => 
                    `<option value="${f.value}" ${r.fontFamily === f.value ? 'selected' : ''}>${f.label}</option>`
                ).join('');
                
                const hasMask = r.selectedPixels && r.selectedPixels.length > 0;
                
                // 生成區塊導航列表（僅在有多個區塊時顯示）
                let regionNavHtml = '';
                if (totalRegions > 1) {
                    const visibleRegions = state.regions.filter(rr => isLayerVisible(rr.layerIndex));
                    const visibleIdx = visibleRegions.indexOf(r);
                    const prevIdx = visibleIdx > 0 ? state.regions.indexOf(visibleRegions[visibleIdx - 1]) : -1;
                    const nextIdx = visibleIdx < visibleRegions.length - 1 ? state.regions.indexOf(visibleRegions[visibleIdx + 1]) : -1;
                    
                    regionNavHtml = `
                    <div class="section" style="background:#111;border:1px solid #333;border-radius:8px;padding:8px;margin-bottom:8px;">
                        <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:6px;">
                            <span style="font-size:11px;color:#8b8bf6;">📋 全部區塊 (${visibleIdx + 1}/${totalRegions})</span>
                            <div style="display:flex;gap:4px;">
                                <button class="btn btn-outline" style="padding:2px 8px;font-size:11px;" 
                                    onclick="navigateRegion(-1)" ${prevIdx < 0 ? 'disabled' : ''}>◀ 上一個</button>
                                <button class="btn btn-outline" style="padding:2px 8px;font-size:11px;" 
                                    onclick="navigateRegion(1)" ${nextIdx < 0 ? 'disabled' : ''}>下一個 ▶</button>
                            </div>
                        </div>
                        <div id="region-nav-list" style="max-height:120px;overflow-y:auto;border:1px solid #222;border-radius:4px;">
                            ${visibleRegions.map((rr, vi) => {
                                const ri = state.regions.indexOf(rr);
                                const isActive = rr === r;
                                const txt = stripColorTags(rr.text || '').substring(0, 25) || '(空白)';
                                return `<div onclick="selectRegion(state.regions[${ri}])" 
                                    style="display:flex;align-items:center;gap:6px;padding:4px 6px;cursor:pointer;
                                    background:${isActive ? '#1a1a3a' : 'transparent'};
                                    border-left:3px solid ${isActive ? '#6366f1' : 'transparent'};
                                    ${vi < visibleRegions.length - 1 ? 'border-bottom:1px solid #222;' : ''}"
                                    onmouseenter="this.style.background='${isActive ? '#1a1a3a' : '#1a1a1a'}'"
                                    onmouseleave="this.style.background='${isActive ? '#1a1a3a' : 'transparent'}'">
                                    <span style="font-size:10px;color:${rr.edited ? '#22c55e' : '#666'};min-width:14px;">${rr.edited ? '✓' : '○'}</span>
                                    <span style="font-size:11px;color:${isActive ? '#fff' : '#aaa'};flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;${isActive ? 'font-weight:bold;' : ''}">${txt}</span>
                                    <span style="font-size:9px;color:#555;">${vi + 1}</span>
                                </div>`;
                            }).join('')}
                        </div>
                        <div style="display:flex;gap:4px;margin-top:6px;">
                            <button class="btn btn-outline" style="flex:1;font-size:10px;padding:3px;" 
                                onclick="batchApplyCurrentStyle()" title="將目前區塊的樣式套用到所有區塊">
                                🎨 套用樣式到全部
                            </button>
                            <button class="btn btn-outline" style="flex:1;font-size:10px;padding:3px;" 
                                onclick="commitAllRegions()" title="一次確認所有已編輯的區塊">
                                ✓ 全部確認
                            </button>
                        </div>
                    </div>`;
                }
                
                panel.innerHTML = regionNavHtml + `
                    <div class="section" style="background:#1a1a1a;border-radius:8px;padding:12px;">
                        <div class="section-title" style="margin-bottom:8px;">⚡ 快速操作 ${hasMask ? '<span style="color:#22c55e;font-size:10px;">🪄 魔術棒選取</span>' : ''}</div>
                        <div class="prop-row" style="margin-bottom:8px;">
                            <span class="prop-label">清除用背景色</span>
                            <div class="color-row">
                                <input type="color" class="color-input" value="${r.bgColor}" 
                                    onchange="updateRegionProp('bgColor', this.value)">
                                <span class="color-hex">${r.bgColor}</span>
                                <button class="btn btn-outline" style="padding:2px 6px;font-size:10px;" onclick="startEyedropper('bgColor')" title="從圖片吸取背景色">💧</button>
                            </div>
                        </div>
                        <div style="display:flex;gap:8px;flex-wrap:wrap;">
                            ${hasMask ? 
                                `<button class="btn btn-danger" style="flex:1;" onclick="window.doEraseWithMask()">🪄 精確清除</button>` : 
                                `<button class="btn btn-danger" style="flex:1;" onclick="eraseActiveRegion()">🧹 清除區域</button>`
                            }
                            <button class="btn btn-outline" style="flex:1;" onclick="cancelRegion()">✕ 取消</button>
                        </div>
                        ${hasMask ? `
                        <div style="margin-top:8px;">
                            <button class="btn btn-outline" style="width:100%;font-size:11px;" onclick="eraseActiveRegion()">🧹 矩形清除（備用）</button>
                        </div>
                        <div style="font-size:10px;color:#22c55e;margin-top:6px;text-align:center;">
                            已選取 ${r.selectedPixels.length} 個像素
                        </div>
                        ` : ''}
                        <div style="margin-top:8px;padding:8px;background:#0a2a0a;border:1px solid #22c55e;border-radius:6px;">
                            <div style="font-size:11px;color:#22c55e;margin-bottom:6px;">🎯 智能背景替換</div>
                            <div class="prop-row" style="margin-bottom:6px;">
                                <span class="prop-label" style="font-size:11px;">容差</span>
                                <div style="display:flex;align-items:center;gap:6px;">
                                    <input type="range" id="smart-replace-tolerance" min="10" max="150" value="${r.smartTolerance || 50}" 
                                        style="flex:1;height:4px;" 
                                        oninput="this.nextElementSibling.textContent=this.value;state.activeRegion.smartTolerance=+this.value">
                                    <span style="font-size:10px;min-width:25px;">${r.smartTolerance || 50}</span>
                                </div>
                            </div>
                            <button class="btn btn-outline" style="width:100%;font-size:11px;background:#1a3a1a;border-color:#22c55e;" 
                                onclick="smartBackgroundReplace()" title="只替換背景色，保留線條內物件顏色">
                                ✨ 執行智能替換（保留物件）
                            </button>
                            <div style="font-size:9px;color:#666;margin-top:4px;">
                                容差越大，替換範圍越廣
                            </div>
                        </div>
                        <div style="font-size:10px;color:#888;margin-top:8px;text-align:center;">
                            💡 先用吸管 💧 吸取正確背景色，再按清除
                        </div>
                    </div>
                    
                    <div class="section">
                        <div class="section-title">📝 編輯文字</div>
                        <textarea class="edit-textarea" id="edit-text" 
                            oninput="updateRegionText(this.value)">${r.text}</textarea>
                        <div style="margin-top:4px;font-size:10px;color:#666;">
                            💡 多色語法: {color:#ff0000}紅色{/color}普通{color:#00ff00}綠色{/color}
                        </div>
                    </div>
                    
                    <div class="section">
                        <div class="section-title">🔤 字型設定</div>
                        <div class="prop-row">
                            <span class="prop-label">字型</span>
                            <select class="prop-select" id="edit-fontFamily" style="width:150px;"
                                onchange="updateRegionProp('fontFamily', this.value)">
                                ${fontOptions}
                            </select>
                        </div>
                        <div class="prop-row">
                            <span class="prop-label">大小</span>
                            <input type="number" class="prop-input" value="${r.fontSize}" min="8" max="200" 
                                onchange="updateRegionProp('fontSize', +this.value)">
                        </div>
                        <div class="prop-row">
                            <span class="prop-label">粗細</span>
                            <select class="prop-select" onchange="updateRegionProp('fontWeight', this.value)">
                                <option value="300" ${r.fontWeight==='300'?'selected':''}>Light</option>
                                <option value="400" ${r.fontWeight==='400'?'selected':''}>Regular</option>
                                <option value="500" ${r.fontWeight==='500'?'selected':''}>Medium</option>
                                <option value="600" ${r.fontWeight==='600'?'selected':''}>SemiBold</option>
                                <option value="700" ${r.fontWeight==='700'?'selected':''}>Bold</option>
                                <option value="800" ${r.fontWeight==='800'?'selected':''}>ExtraBold</option>
                                <option value="900" ${r.fontWeight==='900'?'selected':''}>Black</option>
                            </select>
                        </div>
                        <div class="prop-row">
                            <span class="prop-label">圓角</span>
                            <div style="display:flex;gap:4px;flex-wrap:wrap;">
                                <button class="btn btn-outline ${['jf-openhuninn','Kosugi Maru','M PLUS Rounded 1c','Nunito','Quicksand','Comfortaa','Arial Rounded MT Bold'].includes(r.fontFamily)?'active':''}" 
                                    style="padding:4px 8px;font-size:11px;" 
                                    onclick="toggleRoundedFont()" 
                                    title="切換圓角字體">
                                    ⭕ ${['jf-openhuninn','Kosugi Maru','M PLUS Rounded 1c','Nunito','Quicksand','Comfortaa','Arial Rounded MT Bold'].includes(r.fontFamily)?'已啟用':'未啟用'}
                                </button>
                            </div>
                        </div>
                        <div class="prop-row">
                            <span class="prop-label">字高比例</span>
                            <input type="number" class="prop-input" value="${r.scaleY || 1.2}" min="0.5" max="2" step="0.1"
                                onchange="updateRegionProp('scaleY', +this.value)">
                        </div>
                    </div>
                    
                    <div class="section">
                        <div class="section-title">📐 排版設定</div>
                        <div class="prop-row">
                            <span class="prop-label">排列方向</span>
                            <select class="prop-select" onchange="updateRegionProp('direction', this.value)">
                                <option value="horizontal" ${!r.direction || r.direction === 'horizontal' ? 'selected' : ''}>橫書 →</option>
                                <option value="vertical" ${r.direction === 'vertical' ? 'selected' : ''}>直書 ↓</option>
                            </select>
                        </div>
                        <div class="prop-row" style="${r.direction === 'vertical' ? '' : 'display:none;'}">
                            <label style="display:flex;align-items:center;gap:8px;cursor:pointer;">
                                <input type="checkbox" ${r.verticalPunctFix !== false ? 'checked' : ''} 
                                    onchange="updateRegionProp('verticalPunctFix', this.checked)">
                                <span class="prop-label" style="margin:0;">直式標點修正</span>
                            </label>
                        </div>
                        <div class="prop-row">
                            <span class="prop-label">對齊</span>
                            <div style="display:flex;gap:4px;">
                                <button class="btn btn-outline ${r.textAlign==='left'?'active':''}" style="padding:4px 8px;" onclick="updateRegionProp('textAlign','left')">◀</button>
                                <button class="btn btn-outline ${r.textAlign==='center'?'active':''}" style="padding:4px 8px;" onclick="updateRegionProp('textAlign','center')">▬</button>
                                <button class="btn btn-outline ${r.textAlign==='right'?'active':''}" style="padding:4px 8px;" onclick="updateRegionProp('textAlign','right')">▶</button>
                            </div>
                        </div>
                        <div class="prop-row">
                            <span class="prop-label">行距</span>
                            <input type="number" class="prop-input" value="${r.lineHeight || 1.2}" min="0.5" max="3" step="0.1"
                                onchange="updateRegionProp('lineHeight', +this.value)">
                        </div>
                        <div class="prop-row">
                            <span class="prop-label">字間距</span>
                            <input type="number" class="prop-input" value="${r.letterSpacing || 0}" min="-10" max="50" step="1"
                                onchange="updateRegionProp('letterSpacing', +this.value)">
                        </div>
                        <div class="prop-row">
                            <span class="prop-label">旋轉角度</span>
                            <input type="number" class="prop-input" value="${r.rotation || 0}" min="-180" max="180" step="1"
                                onchange="updateRegionProp('rotation', +this.value)">
                        </div>
                    </div>
                    
                    <div class="section">
                        <div class="section-title">🔄 文字變形</div>
                        <div class="prop-row">
                            <span class="prop-label">變形效果</span>
                            <select class="prop-select" onchange="updateRegionProp('transform', this.value)">
                                <option value="none" ${!r.transform || r.transform === 'none' ? 'selected' : ''}>無變形</option>
                                <option value="arc" ${r.transform === 'arc' ? 'selected' : ''}>弧形 ⌒</option>
                                <option value="arc-down" ${r.transform === 'arc-down' ? 'selected' : ''}>下弧形 ⌓</option>
                                <option value="wave" ${r.transform === 'wave' ? 'selected' : ''}>波浪 〰</option>
                                <option value="bulge" ${r.transform === 'bulge' ? 'selected' : ''}>膨脹 ◯</option>
                                <option value="pinch" ${r.transform === 'pinch' ? 'selected' : ''}>收縮 ◇</option>
                                <option value="flag" ${r.transform === 'flag' ? 'selected' : ''}>旗幟 🏴</option>
                                <option value="fish" ${r.transform === 'fish' ? 'selected' : ''}>魚形 🐟</option>
                            </select>
                        </div>
                        <div class="prop-row">
                            <span class="prop-label">變形強度</span>
                            <div style="display:flex;align-items:center;gap:8px;">
                                <input type="range" style="flex:1;" min="0" max="100" value="${r.transformAmount || 50}" 
                                    oninput="updateRegionProp('transformAmount', +this.value);this.nextElementSibling.textContent=this.value+'%'">
                                <span style="font-size:11px;min-width:35px;">${r.transformAmount || 50}%</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="section">
                        <div class="section-title">🎨 顏色設定</div>
                        <div class="prop-row">
                            <span class="prop-label">文字</span>
                            <div class="color-row">
                                <input type="color" class="color-input" value="${r.color}" 
                                    onchange="updateRegionProp('color', this.value)">
                                <span class="color-hex">${r.color}</span>
                                <button class="btn btn-outline" style="padding:2px 6px;font-size:10px;" onclick="startEyedropper('color')">💧</button>
                            </div>
                        </div>
                        <div class="prop-row">
                            <span class="prop-label">背景</span>
                            <div class="color-row">
                                <input type="color" class="color-input" value="${r.bgColor}" 
                                    onchange="updateRegionProp('bgColor', this.value)">
                                <span class="color-hex">${r.bgColor}</span>
                                <button class="btn btn-outline" style="padding:2px 6px;font-size:10px;" onclick="startEyedropper('bgColor')">💧</button>
                            </div>
                        </div>
                        <div class="prop-row">
                            <span class="prop-label">覆蓋邊距</span>
                            <input type="number" class="prop-input" value="${r.padding || 5}" min="0" max="50"
                                onchange="updateRegionProp('padding', +this.value)">
                        </div>
                    </div>
                    
                    <div class="section">
                        <div class="section-title">✨ 效果設定</div>
                        <div class="prop-row">
                            <span class="prop-label">描邊寬度</span>
                            <input type="number" class="prop-input" value="${r.strokeWidth || 0}" min="0" max="10" step="0.5"
                                onchange="updateRegionProp('strokeWidth', +this.value)">
                        </div>
                        <div class="prop-row">
                            <span class="prop-label">描邊顏色</span>
                            <div class="color-row">
                                <input type="color" class="color-input" value="${r.strokeColor || '#000000'}" 
                                    onchange="updateRegionProp('strokeColor', this.value)">
                                <span class="color-hex">${r.strokeColor || '#000000'}</span>
                            </div>
                        </div>
                        <div class="prop-row">
                            <span class="prop-label">陰影模糊</span>
                            <input type="number" class="prop-input" value="${r.shadowBlur || 0}" min="0" max="20"
                                onchange="updateRegionProp('shadowBlur', +this.value)">
                        </div>
                        <div class="prop-row">
                            <span class="prop-label">陰影顏色</span>
                            <div class="color-row">
                                <input type="color" class="color-input" value="${r.shadowColor || '#000000'}" 
                                    onchange="updateRegionProp('shadowColor', this.value)">
                                <span class="color-hex">${r.shadowColor || '#000000'}</span>
                            </div>
                        </div>
                        <div class="prop-row">
                            <span class="prop-label">陰影偏移</span>
                            <div style="display:flex;gap:4px;">
                                <input type="number" class="prop-input" style="width:50px;" value="${r.shadowOffsetX || 0}" min="-20" max="20"
                                    onchange="updateRegionProp('shadowOffsetX', +this.value)" placeholder="X">
                                <input type="number" class="prop-input" style="width:50px;" value="${r.shadowOffsetY || 0}" min="-20" max="20"
                                    onchange="updateRegionProp('shadowOffsetY', +this.value)" placeholder="Y">
                            </div>
                        </div>
                    </div>
                    
                    <div class="section">
                        <div class="section-title">🌈 漸層文字</div>
                        <div class="prop-row">
                            <span class="prop-label">啟用漸層</span>
                            <input type="checkbox" ${r.gradientEnabled?'checked':''} 
                                onchange="updateRegionProp('gradientEnabled', this.checked)">
                        </div>
                        <div class="prop-row">
                            <span class="prop-label">顏色1</span>
                            <input type="color" class="color-input" value="${r.gradientColor1 || '#ff0000'}" 
                                onchange="updateRegionProp('gradientColor1', this.value)">
                        </div>
                        <div class="prop-row">
                            <span class="prop-label">顏色2</span>
                            <input type="color" class="color-input" value="${r.gradientColor2 || '#0000ff'}" 
                                onchange="updateRegionProp('gradientColor2', this.value)">
                        </div>
                        <div class="prop-row">
                            <span class="prop-label">方向</span>
                            <select class="prop-select" onchange="updateRegionProp('gradientDirection', this.value)">
                                <option value="horizontal" ${(r.gradientDirection||'horizontal')==='horizontal'?'selected':''}>水平 →</option>
                                <option value="vertical" ${r.gradientDirection==='vertical'?'selected':''}>垂直 ↓</option>
                                <option value="diagonal" ${r.gradientDirection==='diagonal'?'selected':''}>對角 ↘</option>
                            </select>
                        </div>
                    </div>
                    
                    <div class="section">
                        <div class="section-title">📋 樣式範本</div>
                        <div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;">
                            ${state.stylePresets.map((p, i) => `
                                <button class="btn btn-outline" style="font-size:11px;padding:6px;" 
                                    onclick="applyStylePreset(state.stylePresets[${i}])">${p.name}</button>
                            `).join('')}
                        </div>
                    </div>
                    
                    <div class="section">
                        <div class="section-title">📚 文字範本庫</div>
                        <div style="display:flex;gap:4px;margin-bottom:6px;">
                            <button class="btn btn-primary" style="flex:1;font-size:11px;padding:6px;" 
                                onclick="saveTextTemplate()">💾 儲存為範本</button>
                            <button class="btn btn-outline" style="flex:1;font-size:11px;padding:6px;" 
                                onclick="openTextTemplateLibrary()">📂 範本庫</button>
                        </div>
                        ${state.textTemplates.length > 0 ? `
                        <div style="max-height:120px;overflow-y:auto;border:1px solid #333;border-radius:6px;padding:4px;">
                            ${state.textTemplates.slice(0, 6).map((t, i) => `
                                <div style="display:flex;align-items:center;gap:4px;padding:4px;border-bottom:1px solid #222;cursor:pointer;" 
                                    onclick="applyTextTemplate(${i})" title="${t.text.substring(0,30)}">
                                    <span style="font-size:11px;flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;color:#ccc;">
                                        <span style="color:${t.color};font-size:13px;">■</span> ${t.name || t.text.substring(0,15)}
                                    </span>
                                    <button class="btn btn-outline" style="padding:2px 4px;font-size:9px;" 
                                        onclick="event.stopPropagation();deleteTextTemplate(${i})">✕</button>
                                </div>
                            `).join('')}
                        </div>` : '<div style="font-size:10px;color:#666;text-align:center;padding:8px;">尚無範本，點擊「儲存為範本」新增</div>'}
                    </div>
                    
                    <div class="section">
                        <div class="section-title">↩️ 曲線 / 路徑文字</div>
                        <div class="prop-row">
                            <span class="prop-label">路徑模式</span>
                            <select class="prop-select" onchange="updateRegionProp('curveMode', this.value); if(this.value!=='none') updateRegionProp('curveEnabled', true); else updateRegionProp('curveEnabled', false); updatePanel();">
                                <option value="none" ${!r.curveEnabled ? 'selected' : ''}>無</option>
                                <option value="arc" ${r.curveEnabled && (!r.curveMode || r.curveMode === 'arc') ? 'selected' : ''}>🌀 圓弧</option>
                                <option value="bezier" ${r.curveEnabled && r.curveMode === 'bezier' ? 'selected' : ''}>〰️ 貝茲曲線</option>
                            </select>
                        </div>
                        ${r.curveEnabled && (!r.curveMode || r.curveMode === 'arc') ? `
                        <div class="prop-row">
                            <span class="prop-label">曲線半徑</span>
                            <input type="number" class="prop-input" value="${r.curveRadius || 100}" min="50" max="500"
                                onchange="updateRegionProp('curveRadius', +this.value)">
                        </div>
                        <div class="prop-row">
                            <span class="prop-label">起始角度</span>
                            <input type="number" class="prop-input" value="${r.curveStartAngle || 0}" min="-180" max="180" step="5"
                                onchange="updateRegionProp('curveStartAngle', +this.value)">
                        </div>` : ''}
                        ${r.curveEnabled && r.curveMode === 'bezier' ? `
                        <div style="padding:6px;background:#1a1a2e;border-radius:6px;margin-top:4px;">
                            <div style="font-size:10px;color:#8b8bf6;margin-bottom:6px;">🎯 控制點（相對於區域左上角 %）</div>
                            <div class="prop-row">
                                <span class="prop-label">起點 P0</span>
                                <input type="number" class="prop-input" style="width:50px;" value="${r.bezierP0x ?? 0}" min="0" max="100" step="5"
                                    onchange="updateRegionProp('bezierP0x', +this.value)"> %,
                                <input type="number" class="prop-input" style="width:50px;" value="${r.bezierP0y ?? 80}" min="0" max="100" step="5"
                                    onchange="updateRegionProp('bezierP0y', +this.value)"> %
                            </div>
                            <div class="prop-row">
                                <span class="prop-label">控制 P1</span>
                                <input type="number" class="prop-input" style="width:50px;" value="${r.bezierP1x ?? 25}" min="-50" max="150" step="5"
                                    onchange="updateRegionProp('bezierP1x', +this.value)"> %,
                                <input type="number" class="prop-input" style="width:50px;" value="${r.bezierP1y ?? 0}" min="-50" max="150" step="5"
                                    onchange="updateRegionProp('bezierP1y', +this.value)"> %
                            </div>
                            <div class="prop-row">
                                <span class="prop-label">控制 P2</span>
                                <input type="number" class="prop-input" style="width:50px;" value="${r.bezierP2x ?? 75}" min="-50" max="150" step="5"
                                    onchange="updateRegionProp('bezierP2x', +this.value)"> %,
                                <input type="number" class="prop-input" style="width:50px;" value="${r.bezierP2y ?? 0}" min="-50" max="150" step="5"
                                    onchange="updateRegionProp('bezierP2y', +this.value)"> %
                            </div>
                            <div class="prop-row">
                                <span class="prop-label">終點 P3</span>
                                <input type="number" class="prop-input" style="width:50px;" value="${r.bezierP3x ?? 100}" min="0" max="100" step="5"
                                    onchange="updateRegionProp('bezierP3x', +this.value)"> %,
                                <input type="number" class="prop-input" style="width:50px;" value="${r.bezierP3y ?? 80}" min="0" max="100" step="5"
                                    onchange="updateRegionProp('bezierP3y', +this.value)"> %
                            </div>
                            <div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;margin-top:6px;">
                                <button class="btn btn-outline" style="font-size:10px;padding:4px;" onclick="applyBezierPreset('wave')">〰️ 波浪</button>
                                <button class="btn btn-outline" style="font-size:10px;padding:4px;" onclick="applyBezierPreset('arch')">⌒ 拱形</button>
                                <button class="btn btn-outline" style="font-size:10px;padding:4px;" onclick="applyBezierPreset('s')">S 曲線</button>
                                <button class="btn btn-outline" style="font-size:10px;padding:4px;" onclick="applyBezierPreset('dip')">V 下凹</button>
                            </div>
                        </div>` : ''}
                    </div>
                    
                    <div class="section">
                        <div class="section-title">📍 位置調整</div>
                        <div style="display:flex;flex-direction:column;align-items:center;gap:4px;">
                            <button class="btn btn-outline" style="width:36px;padding:4px;" onclick="nudgeRegion(0, -1)">▲</button>
                            <div style="display:flex;gap:4px;">
                                <button class="btn btn-outline" style="width:36px;padding:4px;" onclick="nudgeRegion(-1, 0)">◀</button>
                                <button class="btn btn-outline" style="width:36px;padding:4px;" onclick="nudgeRegion(0, 1)">▼</button>
                                <button class="btn btn-outline" style="width:36px;padding:4px;" onclick="nudgeRegion(1, 0)">▶</button>
                            </div>
                        </div>
                        <div style="display:flex;gap:6px;margin-top:8px;">
                            <div style="flex:1;">
                                <div style="font-size:10px;color:#666;margin-bottom:2px;">X</div>
                                <input type="number" class="prop-input" style="width:100%;" value="${Math.round(r.x)}" onchange="updateRegionPos('x', +this.value)">
                            </div>
                            <div style="flex:1;">
                                <div style="font-size:10px;color:#666;margin-bottom:2px;">Y</div>
                                <input type="number" class="prop-input" style="width:100%;" value="${Math.round(r.y)}" onchange="updateRegionPos('y', +this.value)">
                            </div>
                            <div style="flex:1;">
                                <div style="font-size:10px;color:#666;margin-bottom:2px;">寬</div>
                                <input type="number" class="prop-input" style="width:100%;" value="${Math.round(r.w)}" onchange="updateRegionSize('w', +this.value)">
                            </div>
                            <div style="flex:1;">
                                <div style="font-size:10px;color:#666;margin-bottom:2px;">高</div>
                                <input type="number" class="prop-input" style="width:100%;" value="${Math.round(r.h)}" onchange="updateRegionSize('h', +this.value)">
                            </div>
                        </div>
                    </div>
                    
                    <div class="section">
                        <div class="section-title">👁️ 預覽</div>
                        <div class="preview-box" style="background:${r.transparentBg ? 'repeating-conic-gradient(#808080 0% 25%, #fff 0% 50%) 50% / 10px 10px' : r.bgColor};">
                            <span id="preview-text" style="font-family:'${r.fontFamily}','Noto Sans TC',sans-serif;font-size:${Math.min(r.fontSize, 18)}px;font-weight:${r.fontWeight};color:${r.color};transform:scaleY(${r.scaleY || 1.2});">
                                ${r.text.substring(0, 20)}${r.text.length > 20 ? '...' : ''}
                            </span>
                        </div>
                    </div>
                    
                    <div class="section" style="background:#1a2a1a;border:1px solid #22c55e;border-radius:8px;padding:10px;">
                        <div class="section-title" style="color:#22c55e;">🎭 繪製模式</div>
                        <div class="prop-row">
                            <label style="display:flex;align-items:center;gap:8px;cursor:pointer;">
                                <input type="checkbox" ${r.transparentBg ? 'checked' : ''} 
                                    onchange="updateRegionProp('transparentBg', this.checked)" ${r.isFloating ? 'disabled' : ''}>
                                <span class="prop-label" style="margin:0;">透明背景（僅繪製文字）</span>
                            </label>
                        </div>
                        <div style="font-size:10px;color:#888;margin-top:6px;">
                            ${r.transparentBg ? '✅ 啟用：確認後可自由移動，不覆蓋背景' : '⬜ 停用：使用背景色填充整個區域'}
                        </div>
                        ${!r.isFloating ? `
                        <div style="margin-top:10px;padding-top:10px;border-top:1px solid #333;">
                            <button class="btn btn-outline" style="width:100%;font-size:12px;" 
                                onclick="createSmartFloatingRegion(state.activeRegion)">
                                🧠 智能去背拖動
                            </button>
                            <div style="font-size:10px;color:#888;margin-top:6px;text-align:center;">
                                保留封閉線條內的顏色，只將背景變透明
                            </div>
                        </div>
                        ` : ''}
                    </div>
                    
                    ${r.isFloating ? `
                    <div class="section">
                        <div class="section-title">📝 編輯文字</div>
                        <textarea class="edit-textarea" id="edit-text" 
                            oninput="updateFloatingText(this.value)">${r.text}</textarea>
                    </div>
                    
                    <div class="section">
                        <div class="section-title">🔤 字型設定（即時更新）</div>
                        <div class="prop-row">
                            <span class="prop-label">字型</span>
                            <select class="prop-select" style="width:150px;"
                                onchange="updateRegionProp('fontFamily', this.value)">
                                ${FONT_OPTIONS.map(f => 
                                    `<option value="${f.value}" ${r.fontFamily === f.value ? 'selected' : ''}>${f.label}</option>`
                                ).join('')}
                            </select>
                        </div>
                        <div class="prop-row">
                            <span class="prop-label">大小</span>
                            <input type="number" class="prop-input" value="${r.fontSize}" min="8" max="200" 
                                onchange="updateRegionProp('fontSize', +this.value)">
                        </div>
                        <div class="prop-row">
                            <span class="prop-label">粗細</span>
                            <select class="prop-select" onchange="updateRegionProp('fontWeight', this.value)">
                                <option value="normal" ${r.fontWeight === 'normal' ? 'selected' : ''}>正常</option>
                                <option value="bold" ${r.fontWeight === 'bold' ? 'selected' : ''}>粗體</option>
                                <option value="100" ${r.fontWeight === '100' ? 'selected' : ''}>極細 100</option>
                                <option value="300" ${r.fontWeight === '300' ? 'selected' : ''}>細 300</option>
                                <option value="500" ${r.fontWeight === '500' ? 'selected' : ''}>中等 500</option>
                                <option value="700" ${r.fontWeight === '700' ? 'selected' : ''}>粗 700</option>
                                <option value="900" ${r.fontWeight === '900' ? 'selected' : ''}>極粗 900</option>
                            </select>
                        </div>
                        <div class="prop-row">
                            <span class="prop-label">圓角</span>
                            <button class="btn btn-outline ${['jf-openhuninn','Kosugi Maru','M PLUS Rounded 1c','Nunito','Quicksand','Comfortaa','Arial Rounded MT Bold'].includes(r.fontFamily)?'active':''}" 
                                style="padding:4px 10px;font-size:11px;" 
                                onclick="toggleRoundedFont()" 
                                title="切換圓角字體">
                                ⭕ ${['jf-openhuninn','Kosugi Maru','M PLUS Rounded 1c','Nunito','Quicksand','Comfortaa','Arial Rounded MT Bold'].includes(r.fontFamily)?'已啟用':'未啟用'}
                            </button>
                        </div>
                        <div class="prop-row">
                            <span class="prop-label">文字顏色</span>
                            <div class="color-row">
                                <input type="color" class="color-input" value="${r.color}" 
                                    onchange="updateRegionProp('color', this.value)">
                                <span class="color-hex">${r.color}</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="section" style="background:#0a2a0a;border:2px solid #22c55e;border-radius:8px;padding:12px;">
                        <div class="section-title" style="color:#22c55e;font-size:14px;">✨ 浮動文字模式</div>
                        <div style="font-size:12px;color:#aaa;margin-bottom:10px;">
                            ✅ 原文字已清除<br>
                            📍 拖動文字到新位置<br>
                            🔤 可調整字型大小等屬性<br>
                            📌 點「固定到圖片」完成
                        </div>
                        <div style="display:flex;gap:8px;">
                            <button class="btn btn-primary" style="flex:1;" onclick="commitFloatingText()">📌 固定到圖片</button>
                            <button class="btn btn-outline" style="flex:1;" onclick="cancelFloatingText()">✕ 取消還原</button>
                        </div>
                        <div style="display:flex;gap:6px;margin-top:8px;">
                            <button class="btn btn-outline" style="flex:1;font-size:11px;border-color:${state.copiedFontStyle ? '#6366f1' : '#333'};" onclick="copyFontStyleFromRegion()">🔤 複製字體樣式</button>
                            <button class="btn btn-outline" style="flex:1;font-size:11px;border-color:${state.copiedFontStyle ? '#6366f1' : '#333'};" onclick="pasteFontStyleToRegion()" ${state.copiedFontStyle ? '' : 'disabled'}>🔤 貼上字體樣式</button>
                        </div>
                    </div>
                    ` : `
                    <div class="btn-group">
                        <button class="btn btn-primary" onclick="commitRegion()">✓ 確認修改</button>
                        <button class="btn btn-outline" onclick="cancelRegion()">✕ 取消</button>
                    </div>
                    `}
                    
                    ${!r.isFloating ? `
                    <div style="display:flex;gap:6px;margin-top:8px;">
                        <button class="btn btn-outline" style="flex:1;font-size:11px;" onclick="copyStyle()">📋 複製樣式</button>
                        <button class="btn btn-outline" style="flex:1;font-size:11px;" onclick="pasteStyle()" ${state.copiedStyle ? '' : 'disabled'}>📄 貼上樣式</button>
                        <button class="btn btn-outline" style="flex:1;font-size:11px;" onclick="duplicateRegion()">📑 複製區塊</button>
                    </div>
                    <div style="display:flex;gap:6px;margin-top:4px;">
                        <button class="btn btn-outline" style="flex:1;font-size:11px;border-color:${state.copiedFontStyle ? '#6366f1' : '#333'};" onclick="copyFontStyleFromRegion()">🔤 複製字體樣式</button>
                        <button class="btn btn-outline" style="flex:1;font-size:11px;border-color:${state.copiedFontStyle ? '#6366f1' : '#333'};" onclick="pasteFontStyleToRegion()" ${state.copiedFontStyle ? '' : 'disabled'}>🔤 貼上字體樣式</button>
                    </div>
                    ${state.copiedFontStyle ? '<div style="margin-top:4px;padding:4px 8px;background:#1a1a2e;border-radius:4px;font-size:10px;color:#8b8bf6;text-align:center;">📌 已複製: ' + state.copiedFontStyle.fontFamily + ' / ' + state.copiedFontStyle.fontSize + 'px / ' + state.copiedFontStyle.color + '</div>' : ''}
                    ` : ''}
                    
                    ${r.edited && !r.isFloating ? `
                    <button class="btn btn-outline" style="width:100%;margin-top:8px;" onclick="reapplyRegion()">🔄 重新繪製</button>
                    ` : ''}
                    
                    <div style="margin-top:8px;padding:6px;background:#1a1a1a;border-radius:6px;font-size:10px;color:#666;text-align:center;">
                        ⌨️ 方向鍵微調 | Shift+方向鍵 = 10px
                    </div>
                    
                    <button class="btn btn-danger" style="width:100%;margin-top:8px;" onclick="deleteRegion()">🗑️ 刪除此區域</button>
                `;
                
                return;
            }
            
            // 顯示區域列表和匯出選項
            let html = '';
            
            if (state.regions.length > 0) {
                html += `
                    <div class="section">
                        <div class="section-title">文字區域 (${state.regions.length})</div>
                        <div class="region-list">
                `;
                
                state.regions.forEach((r, i) => {
                    const isMultiSelected = state.selectedRegions.includes(r);
                    html += `
                        <div class="region-item ${r === state.activeRegion ? 'active' : ''} ${isMultiSelected ? 'multi-selected' : ''}" 
                            onclick="selectRegion(state.regions[${i}])"
                            oncontextmenu="toggleMultiSelect(event, state.regions[${i}])">
                            <span class="region-item-text">${r.text.substring(0, 20) || '(空白)'}</span>
                            <span class="region-item-badge ${r.edited ? 'edited' : ''}">${r.edited ? '✓' : '○'}</span>
                        </div>
                    `;
                });
                
                html += `
                        </div>
                    </div>
                `;
                
                // 多選操作
                if (state.selectedRegions.length > 1) {
                    html += `
                        <div class="section">
                            <div class="section-title">批次操作 (${state.selectedRegions.length} 個)</div>
                            <div style="display:flex;gap:6px;flex-wrap:wrap;">
                                <button class="btn btn-outline" style="flex:1;font-size:11px;" onclick="batchDelete()">🗑️ 批次刪除</button>
                                <button class="btn btn-outline" style="flex:1;font-size:11px;" onclick="batchApplyStyle()" ${state.copiedStyle ? '' : 'disabled'}>📄 批次套用樣式</button>
                            </div>
                        </div>
                    `;
                }
            }
            
            // 繪圖工具設定（根據當前模式顯示）
            if (['brush', 'airbrush', 'highlighter', 'pencil', 'shape', 'arrow', 'marker', 'mosaic', 'blur'].includes(state.mode)) {
                html += `<div class="section" style="background:#1a1a2e;border:1px solid #6366f1;border-radius:8px;">
                    <div class="section-title">🎨 繪圖工具設定</div>`;
                
                if (state.mode === 'brush') {
                    html += `
                        <div class="prop-row">
                            <span class="prop-label">顏色</span>
                            <input type="color" class="color-input" value="${state.brushColor}" 
                                onchange="state.brushColor=this.value">
                        </div>
                        <div class="prop-row">
                            <span class="prop-label">筆刷大小</span>
                            <input type="range" style="flex:1;" min="1" max="150" value="${state.brushSize}"
                                oninput="state.brushSize=+this.value;this.nextElementSibling.textContent=this.value+'px'">
                            <span style="width:45px;text-align:right;font-size:11px;">${state.brushSize}px</span>
                        </div>
                        <div class="prop-row">
                            <span class="prop-label">透明度</span>
                            <input type="range" style="flex:1;" min="0.05" max="1" step="0.05" value="${state.brushOpacity}"
                                oninput="state.brushOpacity=+this.value;this.nextElementSibling.textContent=Math.round(this.value*100)+'%'">
                            <span style="width:45px;text-align:right;font-size:11px;">${Math.round(state.brushOpacity*100)}%</span>
                        </div>
                    `;
                }
                
                if (state.mode === 'airbrush') {
                    html += `
                        <div class="prop-row">
                            <span class="prop-label">顏色</span>
                            <input type="color" class="color-input" value="${state.airbrushColor}" 
                                onchange="state.airbrushColor=this.value">
                        </div>
                        <div class="prop-row">
                            <span class="prop-label">噴灑範圍</span>
                            <input type="range" style="flex:1;" min="5" max="200" value="${state.airbrushSize}"
                                oninput="state.airbrushSize=+this.value;this.nextElementSibling.textContent=this.value+'px'">
                            <span style="width:45px;text-align:right;font-size:11px;">${state.airbrushSize}px</span>
                        </div>
                        <div class="prop-row">
                            <span class="prop-label">顆粒大小</span>
                            <input type="range" style="flex:1;" min="1" max="10" value="${state.airbrushParticleSize || 2}"
                                oninput="state.airbrushParticleSize=+this.value;this.nextElementSibling.textContent=this.value+'px'">
                            <span style="width:45px;text-align:right;font-size:11px;">${state.airbrushParticleSize || 2}px</span>
                        </div>
                        <div class="prop-row">
                            <span class="prop-label">密度</span>
                            <input type="range" style="flex:1;" min="5" max="150" value="${state.airbrushDensity}"
                                oninput="state.airbrushDensity=+this.value;this.nextElementSibling.textContent=this.value">
                            <span style="width:45px;text-align:right;font-size:11px;">${state.airbrushDensity}</span>
                        </div>
                        <div class="prop-row">
                            <span class="prop-label">透明度</span>
                            <input type="range" style="flex:1;" min="0.05" max="1" step="0.05" value="${state.airbrushOpacity}"
                                oninput="state.airbrushOpacity=+this.value;this.nextElementSibling.textContent=Math.round(this.value*100)+'%'">
                            <span style="width:45px;text-align:right;font-size:11px;">${Math.round(state.airbrushOpacity*100)}%</span>
                        </div>
                        <div style="font-size:11px;color:#888;margin-top:8px;text-align:center;">
                            按住滑鼠持續噴灑顏色
                        </div>
                    `;
                }
                
                if (state.mode === 'highlighter') {
                    html += `
                        <div class="prop-row">
                            <span class="prop-label">顏色</span>
                            <div style="display:flex;gap:4px;flex-wrap:wrap;">
                                <button style="width:24px;height:24px;background:#ffff00;border:2px solid ${state.highlighterColor==='#ffff00'?'#fff':'transparent'};border-radius:4px;cursor:pointer;" onclick="state.highlighterColor='#ffff00';updatePanel()"></button>
                                <button style="width:24px;height:24px;background:#00ff00;border:2px solid ${state.highlighterColor==='#00ff00'?'#fff':'transparent'};border-radius:4px;cursor:pointer;" onclick="state.highlighterColor='#00ff00';updatePanel()"></button>
                                <button style="width:24px;height:24px;background:#ff69b4;border:2px solid ${state.highlighterColor==='#ff69b4'?'#fff':'transparent'};border-radius:4px;cursor:pointer;" onclick="state.highlighterColor='#ff69b4';updatePanel()"></button>
                                <button style="width:24px;height:24px;background:#00ffff;border:2px solid ${state.highlighterColor==='#00ffff'?'#fff':'transparent'};border-radius:4px;cursor:pointer;" onclick="state.highlighterColor='#00ffff';updatePanel()"></button>
                                <button style="width:24px;height:24px;background:#ffa500;border:2px solid ${state.highlighterColor==='#ffa500'?'#fff':'transparent'};border-radius:4px;cursor:pointer;" onclick="state.highlighterColor='#ffa500';updatePanel()"></button>
                                <input type="color" class="color-input" value="${state.highlighterColor}" 
                                    onchange="state.highlighterColor=this.value;updatePanel()" style="width:24px;height:24px;">
                            </div>
                        </div>
                        <div class="prop-row">
                            <span class="prop-label">線條寬度</span>
                            <input type="range" style="flex:1;" min="2" max="100" value="${state.highlighterSize}"
                                oninput="state.highlighterSize=+this.value;this.nextElementSibling.textContent=this.value+'px'">
                            <span style="width:45px;text-align:right;font-size:11px;">${state.highlighterSize}px</span>
                        </div>
                        <div class="prop-row">
                            <span class="prop-label">透明度</span>
                            <input type="range" style="flex:1;" min="0.1" max="0.9" step="0.05" value="${state.highlighterOpacity}"
                                oninput="state.highlighterOpacity=+this.value;this.nextElementSibling.textContent=Math.round(this.value*100)+'%'">
                            <span style="width:45px;text-align:right;font-size:11px;">${Math.round(state.highlighterOpacity*100)}%</span>
                        </div>
                        <div style="font-size:11px;color:#888;margin-top:8px;text-align:center;">
                            適合標記重點文字
                        </div>
                    `;
                }
                
                if (state.mode === 'pencil') {
                    html += `
                        <div class="prop-row">
                            <span class="prop-label">顏色</span>
                            <input type="color" class="color-input" value="${state.pencilColor}" 
                                onchange="state.pencilColor=this.value">
                        </div>
                        <div class="prop-row">
                            <span class="prop-label">線條粗細</span>
                            <input type="range" style="flex:1;" min="1" max="20" value="${state.pencilSize}"
                                oninput="state.pencilSize=+this.value;this.nextElementSibling.textContent=this.value+'px'">
                            <span style="width:45px;text-align:right;font-size:11px;">${state.pencilSize}px</span>
                        </div>
                        <div class="prop-row">
                            <span class="prop-label">抖動效果</span>
                            <input type="range" style="flex:1;" min="0" max="3" step="0.5" value="${state.pencilJitter || 0.5}"
                                oninput="state.pencilJitter=+this.value;this.nextElementSibling.textContent=this.value">
                            <span style="width:45px;text-align:right;font-size:11px;">${state.pencilJitter || 0.5}</span>
                        </div>
                        <div style="font-size:11px;color:#888;margin-top:8px;text-align:center;">
                            模擬鉛筆的細膩筆觸
                        </div>
                    `;
                }
                
                if (state.mode === 'shape') {
                    html += `
                        <div class="prop-row">
                            <span class="prop-label">形狀</span>
                            <select class="prop-select" onchange="state.shapeType=this.value">
                                <option value="rect" ${state.shapeType==='rect'?'selected':''}>矩形</option>
                                <option value="circle" ${state.shapeType==='circle'?'selected':''}>圓形/橢圓</option>
                                <option value="line" ${state.shapeType==='line'?'selected':''}>直線</option>
                                <option value="arrow" ${state.shapeType==='arrow'?'selected':''}>箭頭</option>
                            </select>
                        </div>
                        <div class="prop-row">
                            <span class="prop-label">邊框</span>
                            <input type="checkbox" ${state.shapeStroke?'checked':''} onchange="state.shapeStroke=this.checked">
                            <input type="color" class="color-input" value="${state.shapeStrokeColor}" 
                                onchange="state.shapeStrokeColor=this.value" style="margin-left:8px;">
                        </div>
                        <div class="prop-row">
                            <span class="prop-label">填充</span>
                            <input type="checkbox" ${state.shapeFill?'checked':''} onchange="state.shapeFill=this.checked">
                            <input type="color" class="color-input" value="${state.shapeFillColor}" 
                                onchange="state.shapeFillColor=this.value" style="margin-left:8px;">
                        </div>
                        <div class="prop-row">
                            <span class="prop-label">線寬</span>
                            <input type="range" style="flex:1;" min="1" max="20" value="${state.shapeStrokeWidth}"
                                onchange="state.shapeStrokeWidth=+this.value;this.nextElementSibling.textContent=this.value+'px'">
                            <span style="width:40px;text-align:right;font-size:11px;">${state.shapeStrokeWidth}px</span>
                        </div>
                    `;
                }
                
                if (state.mode === 'arrow') {
                    html += `
                        <div class="prop-row">
                            <span class="prop-label">顏色</span>
                            <input type="color" class="color-input" value="${state.arrowColor}" 
                                onchange="state.arrowColor=this.value">
                        </div>
                        <div class="prop-row">
                            <span class="prop-label">線寬</span>
                            <input type="range" style="flex:1;" min="1" max="15" value="${state.arrowWidth}"
                                onchange="state.arrowWidth=+this.value;this.nextElementSibling.textContent=this.value+'px'">
                            <span style="width:40px;text-align:right;font-size:11px;">${state.arrowWidth}px</span>
                        </div>
                        <div class="prop-row">
                            <span class="prop-label">樣式</span>
                            <select class="prop-select" onchange="state.arrowStyle=this.value">
                                <option value="solid" ${state.arrowStyle==='solid'?'selected':''}>實線</option>
                                <option value="dashed" ${state.arrowStyle==='dashed'?'selected':''}>虛線</option>
                            </select>
                        </div>
                        <div style="font-size:11px;color:#888;margin-top:8px;text-align:center;">
                            拖曳滑鼠繪製箭頭
                        </div>
                    `;
                }
                
                if (state.mode === 'marker') {
                    html += `
                        <div class="prop-row">
                            <span class="prop-label">類型</span>
                        </div>
                        <div class="marker-options">
                            <button class="marker-btn ${state.markerType==='circle'?'active':''}" onclick="state.markerType='circle';updatePanel()">⭕</button>
                            <button class="marker-btn ${state.markerType==='rect'?'active':''}" onclick="state.markerType='rect';updatePanel()">⬜</button>
                            <button class="marker-btn ${state.markerType==='check'?'active':''}" onclick="state.markerType='check';updatePanel()">✓</button>
                            <button class="marker-btn ${state.markerType==='cross'?'active':''}" onclick="state.markerType='cross';updatePanel()">✗</button>
                            <button class="marker-btn ${state.markerType==='number'?'active':''}" onclick="state.markerType='number';updatePanel()">①</button>
                        </div>
                        <div class="prop-row" style="margin-top:8px;">
                            <span class="prop-label">顏色</span>
                            <input type="color" class="color-input" value="${state.markerColor}" 
                                onchange="state.markerColor=this.value">
                        </div>
                        <div class="prop-row">
                            <span class="prop-label">大小</span>
                            <input type="range" style="flex:1;" min="20" max="100" value="${state.markerSize}"
                                onchange="state.markerSize=+this.value;this.nextElementSibling.textContent=this.value+'px'">
                            <span style="width:40px;text-align:right;font-size:11px;">${state.markerSize}px</span>
                        </div>
                        ${state.markerType !== 'check' && state.markerType !== 'cross' ? `
                        <div class="prop-row">
                            <span class="prop-label">填充</span>
                            <input type="checkbox" ${state.markerFilled?'checked':''} onchange="state.markerFilled=this.checked">
                        </div>
                        ` : ''}
                        ${state.markerType === 'number' ? `
                        <div class="prop-row">
                            <span class="prop-label">起始編號</span>
                            <input type="number" class="prop-input" value="${state.markerNumber}" min="1" max="99"
                                onchange="state.markerNumber=+this.value">
                        </div>
                        ` : ''}
                        <div style="font-size:11px;color:#888;margin-top:8px;text-align:center;">
                            點擊圖片放置標記
                        </div>
                    `;
                }
                
                if (state.mode === 'mosaic') {
                    html += `
                        <div class="prop-row">
                            <span class="prop-label">筆刷大小</span>
                            <input type="range" style="flex:1;" min="10" max="100" value="${state.brushSize}"
                                onchange="state.brushSize=+this.value;this.nextElementSibling.textContent=this.value+'px'">
                            <span style="width:40px;text-align:right;font-size:11px;">${state.brushSize}px</span>
                        </div>
                        <div class="prop-row">
                            <span class="prop-label">馬賽克大小</span>
                            <input type="range" style="flex:1;" min="5" max="30" value="${state.mosaicSize}"
                                onchange="state.mosaicSize=+this.value;this.nextElementSibling.textContent=this.value+'px'">
                            <span style="width:40px;text-align:right;font-size:11px;">${state.mosaicSize}px</span>
                        </div>
                    `;
                }
                
                if (state.mode === 'blur') {
                    html += `
                        <div class="prop-row">
                            <span class="prop-label">筆刷大小</span>
                            <input type="range" style="flex:1;" min="10" max="100" value="${state.brushSize}"
                                onchange="state.brushSize=+this.value;this.nextElementSibling.textContent=this.value+'px'">
                            <span style="width:40px;text-align:right;font-size:11px;">${state.brushSize}px</span>
                        </div>
                        <div class="prop-row">
                            <span class="prop-label">模糊程度</span>
                            <input type="range" style="flex:1;" min="1" max="15" value="${state.blurRadius}"
                                onchange="state.blurRadius=+this.value;this.nextElementSibling.textContent=this.value">
                            <span style="width:30px;text-align:right;font-size:11px;">${state.blurRadius}</span>
                        </div>
                    `;
                }
                
                html += `</div>`;
            }
            
            // 魔術棒設定
            html += `
                <div class="section">
                    <div class="section-title">🪄 魔術棒設定</div>
                    <div class="prop-row">
                        <span class="prop-label">顏色容差</span>
                        <input type="range" style="flex:1;" min="1" max="100" value="${state.magicWandTolerance}"
                            onchange="state.magicWandTolerance=+this.value;this.nextElementSibling.textContent=this.value">
                        <span style="width:30px;text-align:right;font-size:11px;">${state.magicWandTolerance}</span>
                    </div>
                    <div style="font-size:10px;color:#666;margin-top:4px;">
                        容差越大，選取範圍越廣
                    </div>
                </div>
            `;
            
            // 匯出選項
            html += `
                <div class="section">
                    <div class="section-title">💾 匯出設定</div>
                    <div class="prop-row">
                        <span class="prop-label">格式</span>
                        <select class="prop-select" onchange="state.exportFormat=this.value">
                            <option value="png" ${state.exportFormat==='png'?'selected':''}>PNG</option>
                            <option value="jpeg" ${state.exportFormat==='jpeg'?'selected':''}>JPEG</option>
                            <option value="webp" ${state.exportFormat==='webp'?'selected':''}>WebP</option>
                        </select>
                    </div>
                    <div class="prop-row">
                        <span class="prop-label">品質</span>
                        <input type="range" style="flex:1;" min="0.1" max="1" step="0.05" value="${state.exportQuality}"
                            onchange="state.exportQuality=+this.value;this.nextElementSibling.textContent=Math.round(this.value*100)+'%'">
                        <span style="width:40px;text-align:right;font-size:11px;">${Math.round(state.exportQuality*100)}%</span>
                    </div>
                </div>
            `;
            
            // 說明
            if (state.regions.length === 0) {
                html += `
                    <div class="info-box">
                        <strong>文字工具：</strong><br>
                        ⛶ 框選 | 🪄 魔術棒 | 💧 取色<br><br>
                        <strong>繪圖工具：</strong><br>
                        🖌️ 畫筆 | ⬜ 形狀 | 🔲 馬賽克 | 💧 模糊<br><br>
                        <strong>提示：</strong>右鍵多選區域
                    </div>
                `;
            } else {
                html += `
                    <div class="info-box">
                        點擊區域編輯 | 右鍵多選
                    </div>
                `;
            }
            
            panel.innerHTML = html;
        }

        function updateRegionText(text) {
            if (state.activeRegion) {
                state.activeRegion.text = text;
                // 更新預覽
                const preview = document.querySelector('#preview-text');
                if (preview) {
                    preview.textContent = text.substring(0, 20) + (text.length > 20 ? '...' : '');
                }
            }
        }
        
        // 啟動取色器
        function startEyedropper(target) {
            state.eyedropperTarget = target;
            setMode('eyedropper');
            toast('點擊圖片吸取顏色', 'info');
        }
        
        // 複製樣式
        // ============ 文字範本庫功能 ============
        
        function saveTextTemplate() {
            if (!state.activeRegion) return;
            const r = state.activeRegion;
            const name = prompt('範本名稱：', r.text.substring(0, 15));
            if (!name) return;
            
            const template = {
                name: name,
                text: r.text,
                fontFamily: r.fontFamily,
                fontSize: r.fontSize,
                fontWeight: r.fontWeight,
                scaleY: r.scaleY,
                color: r.color,
                bgColor: r.bgColor,
                textAlign: r.textAlign,
                lineHeight: r.lineHeight,
                letterSpacing: r.letterSpacing,
                strokeWidth: r.strokeWidth,
                strokeColor: r.strokeColor,
                shadowBlur: r.shadowBlur,
                shadowColor: r.shadowColor,
                shadowOffsetX: r.shadowOffsetX,
                shadowOffsetY: r.shadowOffsetY,
                rotation: r.rotation,
                padding: r.padding,
                direction: r.direction,
                verticalPunctFix: r.verticalPunctFix,
                transparentBg: r.transparentBg,
                gradientEnabled: r.gradientEnabled,
                gradientColor1: r.gradientColor1,
                gradientColor2: r.gradientColor2,
                gradientDirection: r.gradientDirection,
                curveEnabled: r.curveEnabled,
                curveMode: r.curveMode,
                curveRadius: r.curveRadius,
                curveStartAngle: r.curveStartAngle,
                transform: r.transform,
                transformAmount: r.transformAmount,
                createdAt: new Date().toLocaleString()
            };
            
            state.textTemplates.push(template);
            localStorage.setItem('ecf_text_templates', JSON.stringify(state.textTemplates));
            updatePanel();
            toast('✅ 範本已儲存: ' + name, 'success');
        }
        
        function applyTextTemplate(index) {
            if (!state.activeRegion) return;
            const t = state.textTemplates[index];
            if (!t) return;
            
            const keep = ['id', 'x', 'y', 'w', 'h', 'originalText', 'edited', 'layerIndex', 'isFloating'];
            for (const key of Object.keys(t)) {
                if (!keep.includes(key) && key !== 'name' && key !== 'createdAt') {
                    state.activeRegion[key] = t[key];
                }
            }
            updatePanel();
            toast('✅ 已套用範本: ' + t.name, 'success');
        }
        
        function deleteTextTemplate(index) {
            if (!confirm('確定刪除範本「' + state.textTemplates[index].name + '」？')) return;
            state.textTemplates.splice(index, 1);
            localStorage.setItem('ecf_text_templates', JSON.stringify(state.textTemplates));
            updatePanel();
            toast('範本已刪除', 'success');
        }
        
        function openTextTemplateLibrary() {
            const dialog = document.createElement('div');
            dialog.id = 'template-lib-dialog';
            dialog.style.cssText = `position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:#1a1a1a;border:1px solid #444;border-radius:12px;padding:20px;z-index:10001;min-width:550px;max-height:80vh;overflow-y:auto;box-shadow:0 10px 40px rgba(0,0,0,0.5);`;
            
            const templates = state.textTemplates;
            let listHtml = '';
            if (templates.length === 0) {
                listHtml = '<div style="text-align:center;padding:30px;color:#666;">尚無範本<br><span style="font-size:12px;">選取文字區塊後點擊「💾 儲存為範本」新增</span></div>';
            } else {
                templates.forEach((t, i) => {
                    listHtml += `<div style="display:flex;align-items:center;gap:10px;padding:10px;border-bottom:1px solid #333;cursor:pointer;border-radius:6px;transition:background 0.15s;" 
                        onmouseover="this.style.background='#252525'" onmouseout="this.style.background=''" 
                        onclick="applyTextTemplate(${i});document.getElementById('template-lib-dialog').remove();">
                        <div style="min-width:36px;height:36px;background:${t.bgColor || '#333'};border-radius:6px;display:flex;align-items:center;justify-content:center;">
                            <span style="color:${t.color};font-size:${Math.min(t.fontSize || 16, 18)}px;font-weight:${t.fontWeight || '400'};">${t.text.charAt(0) || 'T'}</span>
                        </div>
                        <div style="flex:1;overflow:hidden;">
                            <div style="font-size:13px;color:#fff;font-weight:500;">${t.name}</div>
                            <div style="font-size:11px;color:#888;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${t.text.substring(0,40)} | ${t.fontFamily} ${t.fontSize}px</div>
                        </div>
                        <div style="font-size:10px;color:#666;">${t.createdAt || ''}</div>
                        <button class="btn btn-outline" style="padding:4px 8px;font-size:10px;" 
                            onclick="event.stopPropagation();deleteTextTemplate(${i});document.getElementById('template-lib-dialog').remove();openTextTemplateLibrary();">🗑️</button>
                    </div>`;
                });
            }
            
            dialog.innerHTML = `
                <h3 style="margin:0 0 15px 0;display:flex;justify-content:space-between;align-items:center;">
                    <span>📚 文字範本庫 (${templates.length})</span>
                    <button onclick="document.getElementById('template-lib-dialog').remove()" style="background:none;border:none;color:#fff;font-size:20px;cursor:pointer;">×</button>
                </h3>
                <div style="margin-bottom:12px;display:flex;gap:8px;">
                    <button class="btn btn-outline" style="font-size:11px;" onclick="exportTextTemplates()">📤 匯出範本</button>
                    <button class="btn btn-outline" style="font-size:11px;" onclick="importTextTemplates()">📥 匯入範本</button>
                    <button class="btn btn-danger" style="font-size:11px;margin-left:auto;" onclick="if(confirm('確定清空所有範本？')){state.textTemplates=[];localStorage.setItem('ecf_text_templates','[]');document.getElementById('template-lib-dialog').remove();openTextTemplateLibrary();updatePanel();}">🗑️ 清空</button>
                </div>
                ${listHtml}
                <div style="margin-top:12px;font-size:10px;color:#666;text-align:center;">
                    💡 點擊範本即可套用到目前選取的文字區塊
                </div>`;
            
            document.body.appendChild(dialog);
            makeDraggable(dialog);
        }
        
        function exportTextTemplates() {
            const data = JSON.stringify(state.textTemplates, null, 2);
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'ecf_text_templates.json';
            a.click();
            URL.revokeObjectURL(url);
            toast('範本已匯出', 'success');
        }
        
        function importTextTemplates() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (ev) => {
                    try {
                        const imported = JSON.parse(ev.target.result);
                        if (Array.isArray(imported)) {
                            state.textTemplates = [...state.textTemplates, ...imported];
                            localStorage.setItem('ecf_text_templates', JSON.stringify(state.textTemplates));
                            document.getElementById('template-lib-dialog')?.remove();
                            openTextTemplateLibrary();
                            updatePanel();
                            toast('已匯入 ' + imported.length + ' 個範本', 'success');
                        }
                    } catch (err) {
                        toast('匯入失敗: 格式錯誤', 'error');
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }
        
        // ============ 貝茲曲線預設 ============
        function applyBezierPreset(type) {
            if (!state.activeRegion) return;
            const r = state.activeRegion;
            switch (type) {
                case 'wave':
                    r.bezierP0x = 0; r.bezierP0y = 50;
                    r.bezierP1x = 25; r.bezierP1y = 0;
                    r.bezierP2x = 75; r.bezierP2y = 100;
                    r.bezierP3x = 100; r.bezierP3y = 50;
                    break;
                case 'arch':
                    r.bezierP0x = 0; r.bezierP0y = 90;
                    r.bezierP1x = 25; r.bezierP1y = 10;
                    r.bezierP2x = 75; r.bezierP2y = 10;
                    r.bezierP3x = 100; r.bezierP3y = 90;
                    break;
                case 's':
                    r.bezierP0x = 0; r.bezierP0y = 80;
                    r.bezierP1x = 20; r.bezierP1y = 0;
                    r.bezierP2x = 80; r.bezierP2y = 100;
                    r.bezierP3x = 100; r.bezierP3y = 20;
                    break;
                case 'dip':
                    r.bezierP0x = 0; r.bezierP0y = 20;
                    r.bezierP1x = 30; r.bezierP1y = 100;
                    r.bezierP2x = 70; r.bezierP2y = 100;
                    r.bezierP3x = 100; r.bezierP3y = 20;
                    break;
            }
            updatePanel();
        }
        
        // ============ OCR 後直接編輯功能 ============
        function ocrAndCreateEditable() {
            if (!state.image) { toast('請先載入圖片', 'error'); return; }
            
            const dialog = document.createElement('div');
            dialog.id = 'ocr-edit-dialog';
            dialog.style.cssText = 'position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:#1a1a1a;border:1px solid #444;border-radius:12px;padding:20px;z-index:10001;min-width:450px;box-shadow:0 10px 40px rgba(0,0,0,0.5);';
            
            dialog.innerHTML = `
                <h3 style="margin:0 0 15px 0;display:flex;justify-content:space-between;align-items:center;">
                    <span>🔍 OCR 辨識 → 直接編輯</span>
                    <button onclick="document.getElementById('ocr-edit-dialog').remove()" style="background:none;border:none;color:#fff;font-size:20px;cursor:pointer;">×</button>
                </h3>
                <div style="margin-bottom:12px;">
                    <label style="display:block;margin-bottom:8px;font-size:12px;color:#aaa;">辨識語言</label>
                    <select id="ocr-edit-lang" style="width:100%;padding:8px;background:#2a2a2a;border:1px solid #444;border-radius:6px;color:#fff;">
                        <option value="chi_tra+eng">繁體中文 + 英文</option>
                        <option value="chi_sim+eng">簡體中文 + 英文</option>
                        <option value="eng">僅英文</option>
                        <option value="jpn+eng">日文 + 英文</option>
                        <option value="kor+eng">韓文 + 英文</option>
                    </select>
                </div>
                <div style="margin-bottom:12px;">
                    <label style="display:flex;align-items:center;gap:8px;cursor:pointer;font-size:12px;color:#ccc;">
                        <input type="checkbox" id="ocr-edit-transparent" checked> 使用透明背景（可自由移動文字）
                    </label>
                </div>
                <div style="margin-bottom:12px;">
                    <label style="display:flex;align-items:center;gap:8px;cursor:pointer;font-size:12px;color:#ccc;">
                        <input type="number" id="ocr-edit-confidence" value="40" min="0" max="100" style="width:60px;padding:4px;background:#2a2a2a;border:1px solid #444;border-radius:4px;color:#fff;"> 
                        最低信心度 %（低於此值的行會忽略）
                    </label>
                </div>
                <div style="margin-bottom:12px;">
                    <label style="display:block;font-size:12px;color:#ccc;margin-bottom:6px;">
                        字組分割靈敏度: <span id="ocr-gap-label">中</span>
                    </label>
                    <input type="range" id="ocr-edit-gap" min="1" max="5" value="3" style="width:100%;" 
                        oninput="document.getElementById('ocr-gap-label').textContent=['極高','高','中','低','極低'][+this.value-1]">
                    <div style="display:flex;justify-content:space-between;font-size:10px;color:#666;">
                        <span>分更多組</span><span>分更少組</span>
                    </div>
                </div>
                <div style="background:#2a2a2a;padding:10px;border-radius:6px;margin-bottom:12px;">
                    <div style="font-size:11px;color:#888;">💡 辨識整張圖片中的文字，每行自動建立可編輯區塊</div>
                    <div style="font-size:11px;color:#888;margin-top:4px;">📌 辨識後可在右側面板直接修改每個文字區塊</div>
                </div>
                <div id="ocr-edit-progress" style="display:none;margin-bottom:12px;">
                    <div style="font-size:12px;color:#6366f1;margin-bottom:4px;">辨識中...</div>
                    <div style="background:#333;border-radius:4px;overflow:hidden;height:6px;">
                        <div id="ocr-edit-progress-bar" style="height:100%;background:#6366f1;width:0%;transition:width 0.3s;"></div>
                    </div>
                </div>
                <div style="display:flex;gap:10px;justify-content:flex-end;">
                    <button onclick="document.getElementById('ocr-edit-dialog').remove()" class="btn btn-outline">取消</button>
                    <button onclick="performOcrToEdit()" class="btn btn-primary" id="ocr-edit-btn">🔍 開始辨識</button>
                </div>`;
            
            document.body.appendChild(dialog);
            makeDraggable(dialog);
        }
        
        async function performOcrToEdit() {
            const lang = document.getElementById('ocr-edit-lang').value;
            const transparentBg = document.getElementById('ocr-edit-transparent').checked;
            const minConfidence = parseInt(document.getElementById('ocr-edit-confidence').value) || 40;
            const gapSensitivity = parseInt(document.getElementById('ocr-edit-gap')?.value) || 3;
            
            document.getElementById('ocr-edit-progress').style.display = 'block';
            document.getElementById('ocr-edit-btn').disabled = true;
            document.getElementById('ocr-edit-btn').textContent = '辨識中...';
            
            const loaded = await loadTesseract();
            if (!loaded) {
                document.getElementById('ocr-edit-dialog')?.remove();
                toast('OCR 引擎載入失敗', 'error');
                return;
            }
            
            try {
                const result = await Tesseract.recognize(canvas.toDataURL(), lang, {
                    logger: m => {
                        if (m.status === 'recognizing text') {
                            const bar = document.getElementById('ocr-edit-progress-bar');
                            if (bar) bar.style.width = Math.round(m.progress * 100) + '%';
                        }
                    }
                });
                
                const lines = result.data.lines.filter(l => l.text.trim() && l.confidence > minConfidence);
                let addedCount = 0;
                
                lines.forEach((line, i) => {
                    // 使用字組分割：同一行中間距過大或有分隔符號則拆分
                    const wordGroups = splitLineIntoWordGroups(line, gapSensitivity);
                    
                    wordGroups.forEach((group, gi) => {
                        const region = createRegionFromWordGroup(group, i * 100 + gi, {
                            transparentBg: transparentBg
                        });
                        if (region) {
                            state.regions.push(region);
                            addedCount++;
                        }
                    });
                });
                
                document.getElementById('ocr-edit-dialog')?.remove();
                
                if (addedCount > 0) {
                    state.activeRegion = state.regions[state.regions.length - 1];
                    renderRegions();
                    updatePanel();
                    toast('✅ 已辨識 ' + addedCount + ' 個文字區塊，可在右側直接編輯', 'success');
                } else {
                    toast('未偵測到文字區塊', 'warning');
                }
                
            } catch (e) {
                console.error('OCR error:', e);
                document.getElementById('ocr-edit-dialog')?.remove();
                toast('OCR 辨識失敗: ' + e.message, 'error');
            }
        }

        // ============ 複製字體樣式（跨系統共用）============
        
        function copyFontStyleFromRegion() {
            if (!state.activeRegion) return;
            const r = state.activeRegion;
            state.copiedFontStyle = {
                fontFamily: r.fontFamily,
                fontSize: r.fontSize,
                fontWeight: r.fontWeight,
                color: r.color
            };
            toast('✅ 已複製字體樣式', 'success');
            updatePanel();
        }
        
        function pasteFontStyleToRegion() {
            if (!state.activeRegion || !state.copiedFontStyle) return;
            const s = state.copiedFontStyle;
            state.activeRegion.fontFamily = s.fontFamily;
            state.activeRegion.fontSize = s.fontSize;
            state.activeRegion.fontWeight = s.fontWeight;
            state.activeRegion.color = s.color;
            updatePanel();
            toast('✅ 已貼上字體樣式', 'success');
        }
        
        function copyFontStyleFromTextDialog(prefix) {
            const fontEl = document.getElementById(prefix + '-font');
            const sizeEl = document.getElementById(prefix + '-size');
            const colorEl = document.getElementById(prefix + '-color');
            const weightEl = document.getElementById(prefix + '-weight');
            if (!fontEl || !sizeEl || !colorEl) return;
            state.copiedFontStyle = {
                fontFamily: fontEl.value,
                fontSize: parseInt(sizeEl.value),
                fontWeight: weightEl ? weightEl.value : 'normal',
                color: colorEl.value
            };
            toast('✅ 已複製字體樣式', 'success');
        }
        
        function pasteFontStyleToTextDialog(prefix) {
            if (!state.copiedFontStyle) { toast('⚠️ 尚未複製字體樣式', 'warning'); return; }
            const s = state.copiedFontStyle;
            const fontEl = document.getElementById(prefix + '-font');
            const sizeEl = document.getElementById(prefix + '-size');
            const colorEl = document.getElementById(prefix + '-color');
            const weightEl = document.getElementById(prefix + '-weight');
            if (fontEl) {
                if (!Array.from(fontEl.options).some(o => o.value === s.fontFamily)) {
                    const opt = document.createElement('option');
                    opt.value = s.fontFamily; opt.textContent = s.fontFamily;
                    fontEl.appendChild(opt);
                }
                fontEl.value = s.fontFamily;
            }
            if (sizeEl) sizeEl.value = s.fontSize;
            if (colorEl) colorEl.value = s.color;
            if (weightEl) {
                if (Array.from(weightEl.options).some(o => o.value === s.fontWeight)) weightEl.value = s.fontWeight;
            }
            toast('✅ 已貼上字體樣式', 'success');
        }

        function copyStyle() {
            if (!state.activeRegion) return;
            
            const r = state.activeRegion;
            state.copiedStyle = {
                fontFamily: r.fontFamily,
                fontSize: r.fontSize,
                fontWeight: r.fontWeight,
                scaleY: r.scaleY,
                color: r.color,
                bgColor: r.bgColor,
                textAlign: r.textAlign,
                lineHeight: r.lineHeight,
                letterSpacing: r.letterSpacing,
                strokeColor: r.strokeColor,
                strokeWidth: r.strokeWidth,
                shadowColor: r.shadowColor,
                shadowBlur: r.shadowBlur,
                shadowOffsetX: r.shadowOffsetX,
                shadowOffsetY: r.shadowOffsetY,
                rotation: r.rotation,
                padding: r.padding
            };
            // 同步更新跨系統字體樣式剪貼簿
            state.copiedFontStyle = {
                fontFamily: r.fontFamily,
                fontSize: r.fontSize,
                fontWeight: r.fontWeight,
                color: r.color
            };
            
            toast('已複製樣式', 'success');
            updatePanel();
        }
        
        // 貼上樣式
        function pasteStyle() {
            if (!state.activeRegion || !state.copiedStyle) return;
            
            Object.assign(state.activeRegion, state.copiedStyle);
            updatePanel();
            toast('已套用樣式', 'success');
        }
        
        // 複製區塊
        function duplicateRegion() {
            if (!state.activeRegion) return;
            
            const r = state.activeRegion;
            const newRegion = {
                ...JSON.parse(JSON.stringify(r)),
                id: Date.now(),
                x: r.x + 20,
                y: r.y + 20,
                edited: false
            };
            
            state.regions.push(newRegion);
            state.activeRegion = newRegion;
            renderRegions();
            updatePanel();
            toast('已複製區塊', 'success');
        }
        
        // 多選切換
        function toggleMultiSelect(e, region) {
            e.preventDefault();
            
            const idx = state.selectedRegions.indexOf(region);
            if (idx === -1) {
                state.selectedRegions.push(region);
            } else {
                state.selectedRegions.splice(idx, 1);
            }
            
            renderRegions();
            updatePanel();
        }
        
        // 批次刪除
        function batchDelete() {
            if (state.selectedRegions.length === 0) return;
            
            if (!confirm(`確定要刪除 ${state.selectedRegions.length} 個區塊嗎？`)) return;
            
            state.selectedRegions.forEach(r => {
                const idx = state.regions.indexOf(r);
                if (idx !== -1) state.regions.splice(idx, 1);
            });
            
            state.selectedRegions = [];
            state.activeRegion = null;
            renderRegions();
            updatePanel();
            toast('已批次刪除', 'success');
        }
        
        // 批次套用樣式
        function batchApplyStyle() {
            if (state.selectedRegions.length === 0 || !state.copiedStyle) return;
            
            state.selectedRegions.forEach(r => {
                Object.assign(r, state.copiedStyle);
            });
            
            updatePanel();
            toast(`已套用樣式到 ${state.selectedRegions.length} 個區塊`, 'success');
        }

        function updateRegionProp(prop, value) {
            if (!state.activeRegion) return;
            
            state.activeRegion[prop] = value;
            
            // 更新顏色顯示
            if (prop === 'color') {
                const hex = document.querySelector('#edit-color + .color-hex');
                if (hex) hex.textContent = value;
            } else if (prop === 'bgColor') {
                const hex = document.querySelector('#edit-bgColor + .color-hex');
                if (hex) hex.textContent = value;
                const preview = document.querySelector('.preview-box');
                if (preview && !state.activeRegion.transparentBg) preview.style.background = value;
            }
            
            // 更新預覽樣式
            const previewSpan = document.querySelector('#preview-text');
            if (previewSpan) {
                if (prop === 'fontSize') previewSpan.style.fontSize = Math.min(value, 20) + 'px';
                if (prop === 'fontWeight') previewSpan.style.fontWeight = value;
                if (prop === 'fontFamily') previewSpan.style.fontFamily = `'${value}', 'Noto Sans TC', sans-serif`;
                if (prop === 'color') previewSpan.style.color = value;
            }
            
            // 如果是浮動文字，重新生成浮動圖像
            if (state.activeRegion.isFloating) {
                regenerateFloatingImage(state.activeRegion);
            }
        }
        
        // 切換圓角字體
        function toggleRoundedFont() {
            if (!state.activeRegion) return;
            
            const r = state.activeRegion;
            const hasChinese = /[\u4e00-\u9fff]/.test(r.text || '');
            
            // 圓角字體列表
            const roundedFonts = ['jf-openhuninn', 'Kosugi Maru', 'M PLUS Rounded 1c', 'Nunito', 'Quicksand', 'Comfortaa', 'Arial Rounded MT Bold'];
            const isCurrentlyRounded = roundedFonts.includes(r.fontFamily);
            
            // 記住原始字體（用於切換回去）
            if (!isCurrentlyRounded) {
                r._originalFontFamily = r.fontFamily;
            }
            
            if (isCurrentlyRounded) {
                // 切換回原始字體
                r.fontFamily = r._originalFontFamily || (hasChinese ? 'Noto Sans TC' : 'Inter');
            } else {
                // 切換到圓角字體
                if (hasChinese) {
                    r.fontFamily = 'jf-openhuninn'; // 中文圓角
                } else {
                    r.fontFamily = 'Nunito'; // 英文圓角
                }
            }
            
            // 更新下拉選單
            const fontSelect = document.getElementById('edit-fontFamily');
            if (fontSelect) {
                fontSelect.value = r.fontFamily;
            }
            
            // 更新預覽
            const previewSpan = document.querySelector('#preview-text');
            if (previewSpan) {
                previewSpan.style.fontFamily = `'${r.fontFamily}', 'Noto Sans TC', sans-serif`;
            }
            
            // 如果是浮動文字，重新生成
            if (r.isFloating) {
                regenerateFloatingImage(r);
            }
            
            // 重新打開編輯面板以更新按鈕狀態
            openEditPanel(r);
            
            toast(isCurrentlyRounded ? '已切換回一般字體' : '已切換為圓角字體', 'success');
        }
        
        // 更新浮動文字的文字內容
        function updateFloatingText(value) {
            if (!state.activeRegion) return;
            state.activeRegion.text = value;
            
            if (state.activeRegion.isFloating) {
                regenerateFloatingImage(state.activeRegion);
            }
        }
        
        // 重新生成浮動圖像
        function regenerateFloatingImage(r) {
            const pad = r.padding || 5;
            
            // 創建離屏 canvas 繪製透明背景文字
            const offCanvas = document.createElement('canvas');
            offCanvas.width = r.w + pad * 2;
            offCanvas.height = r.h + pad * 2;
            const offCtx = offCanvas.getContext('2d');
            
            // 確保背景透明
            offCtx.clearRect(0, 0, offCanvas.width, offCanvas.height);
            
            // 繪製文字到離屏 canvas（相對座標）
            const tempRegion = {
                ...r,
                x: pad,
                y: pad
            };
            drawTextOnContext(offCtx, tempRegion);
            
            // 更新浮動圖像
            r.floatingImage = offCanvas.toDataURL('image/png');
            
            // 更新顯示
            renderRegions();
        }
        
        // 微調位置（上下左右）
        function nudgeRegion(dx, dy) {
            if (!state.activeRegion) return;
            
            const r = state.activeRegion;
            const oldX = r.x;
            const oldY = r.y;
            const pad = r.padding || 5;
            
            // 更新位置
            r.x = Math.max(0, Math.min(canvas.width - r.w, r.x + dx));
            r.y = Math.max(0, Math.min(canvas.height - r.h, r.y + dy));
            
            // 浮動文字只需更新位置，不重繪畫布
            if (r.isFloating) {
                renderRegions();
                updatePanel();
                return;
            }
            
            // 如果已編輯，需要清除原位置並重新繪製
            if (r.edited) {
                saveHistory('微調位置');
                
                // 計算清除範圍（考慮描邊、陰影等效果）
                const strokeW = r.strokeWidth || 0;
                const shadowBlur = r.shadowBlur || 0;
                const shadowOffsetX = Math.abs(r.shadowOffsetX || 0);
                const shadowOffsetY = Math.abs(r.shadowOffsetY || 0);
                const extraPad = Math.max(20, strokeW + shadowBlur + Math.max(shadowOffsetX, shadowOffsetY) + 10);
                
                // 清除原位置
                const oldCoverX = Math.max(0, oldX - pad - extraPad);
                const oldCoverY = Math.max(0, oldY - pad - extraPad);
                const oldCoverW = Math.min(r.w + (pad + extraPad) * 2, canvas.width - oldCoverX);
                const oldCoverH = Math.min(r.h + (pad + extraPad) * 2, canvas.height - oldCoverY);
                ctx.fillStyle = r.bgColor;
                ctx.fillRect(oldCoverX, oldCoverY, oldCoverW, oldCoverH);
                
                // 在新位置繪製背景
                const newCoverX = Math.max(0, r.x - pad);
                const newCoverY = Math.max(0, r.y - pad);
                const newCoverW = Math.min(r.w + pad * 2, canvas.width - newCoverX);
                const newCoverH = Math.min(r.h + pad * 2, canvas.height - newCoverY);
                ctx.fillStyle = r.bgColor;
                ctx.fillRect(newCoverX, newCoverY, newCoverW, newCoverH);
                
                // 繪製文字（帶縮放）
                drawTextWithScale(r);
                
                updateUndoButton();
            }
            
            renderRegions();
            updatePanel();
        }
        
        // 更新位置
        function updateRegionPos(prop, value) {
            if (!state.activeRegion) return;
            
            const r = state.activeRegion;
            const oldX = r.x;
            const oldY = r.y;
            const pad = r.padding || 5;
            
            r[prop] = Math.max(0, value);
            
            // 浮動文字只需更新位置，不重繪畫布
            if (r.isFloating) {
                renderRegions();
                updatePanel();
                return;
            }
            
            // 如果已編輯，需要清除原位置並重新繪製
            if (r.edited) {
                saveHistory('調整位置');
                
                // 計算清除範圍（考慮描邊、陰影等效果）
                const strokeW = r.strokeWidth || 0;
                const shadowBlur = r.shadowBlur || 0;
                const shadowOffsetX = Math.abs(r.shadowOffsetX || 0);
                const shadowOffsetY = Math.abs(r.shadowOffsetY || 0);
                const extraPad = Math.max(20, strokeW + shadowBlur + Math.max(shadowOffsetX, shadowOffsetY) + 10);
                
                // 清除原位置
                const oldCoverX = Math.max(0, oldX - pad - extraPad);
                const oldCoverY = Math.max(0, oldY - pad - extraPad);
                const oldCoverW = Math.min(r.w + (pad + extraPad) * 2, canvas.width - oldCoverX);
                const oldCoverH = Math.min(r.h + (pad + extraPad) * 2, canvas.height - oldCoverY);
                ctx.fillStyle = r.bgColor;
                ctx.fillRect(oldCoverX, oldCoverY, oldCoverW, oldCoverH);
                
                // 在新位置繪製
                redrawRegion(r);
                updateUndoButton();
            }
            
            renderRegions();
            updatePanel();
        }
        
        // 更新尺寸
        function updateRegionSize(prop, value) {
            if (!state.activeRegion) return;
            
            state.activeRegion[prop] = Math.max(10, value);
            
            // 如果是浮動文字，重新生成浮動圖像
            if (state.activeRegion.isFloating) {
                regenerateFloatingImage(state.activeRegion);
            }
            
            renderRegions();
        }
        
        // 重新繪製已編輯區塊（用於移動後更新）
        function redrawRegion(region) {
            const pad = region.padding || 5;
            
            // 清除區域（含邊距）
            const coverX = Math.max(0, region.x - pad);
            const coverY = Math.max(0, region.y - pad);
            const coverW = region.w + pad * 2;
            const coverH = region.h + pad * 2;
            
            // 只有在非透明背景模式下才填充背景
            if (!region.transparentBg) {
                ctx.fillStyle = region.bgColor;
                ctx.fillRect(coverX, coverY, coverW, coverH);
            }
            
            // 繪製文字（帶縮放）
            drawTextWithScale(region);
        }
        
        // 通用繪製文字函數（支援垂直縮放）

        // ============ 直式標點修正 ============
        const VERTICAL_PUNCT_MAP = {
            '，': '︐', '。': '︒', '、': '︑', '；': '︔', '：': '︓',
            '！': '︕', '？': '︖', '「': '﹁', '」': '﹂', '『': '﹃',
            '』': '﹄', '（': '︵', '）': '︶', '【': '︻', '】': '︼',
            '《': '︽', '》': '︾', '〈': '︿', '〉': '﹀', '｛': '︷',
            '｝': '︸', '〔': '︹', '〕': '︺', '—': '︱', '…': '︙',
            '～': '｜', '﹏': '︴',
            // 半形標點
            ',': '︐', '.': '．', ';': '︔', ':': '︓', '!': '︕',
            '?': '︖', '(': '︵', ')': '︶', '[': '︹', ']': '︺',
            '{': '︷', '}': '︸', '-': '︱',
            // 需要旋轉的標點
            '「': '﹁', '」': '﹂',
        };
        
        // 需要90度旋轉而非替換的標點
        const VERTICAL_ROTATE_PUNCTS = new Set(['ー', '～', '~', '─', '━']);
        
        function getVerticalChar(char) {
            return VERTICAL_PUNCT_MAP[char] || char;
        }
        
        function needsVerticalRotation(char) {
            return VERTICAL_ROTATE_PUNCTS.has(char);
        }

        // ============ 多色文字解析 ============
        // 格式: {color:#ff0000}紅色文字{/color}普通文字{color:#00ff00}綠色{/color}
        function parseMultiColorText(text, defaultColor) {
            const segments = [];
            const regex = /\{color:(#[0-9a-fA-F]{3,8})\}(.*?)\{\/color\}/gs;
            let lastIndex = 0;
            let match;
            
            while ((match = regex.exec(text)) !== null) {
                // 前面的普通文字
                if (match.index > lastIndex) {
                    segments.push({ text: text.slice(lastIndex, match.index), color: defaultColor });
                }
                // 帶顏色的文字
                segments.push({ text: match[2], color: match[1] });
                lastIndex = match.index + match[0].length;
            }
            // 剩餘文字
            if (lastIndex < text.length) {
                segments.push({ text: text.slice(lastIndex), color: defaultColor });
            }
            return segments.length ? segments : [{ text, color: defaultColor }];
        }
        
        // 取得多色文字的純文字（去除標記）
        function stripColorTags(text) {
            return text.replace(/\{color:#[0-9a-fA-F]{3,8}\}/g, '').replace(/\{\/color\}/g, '');
        }
        
        // ============ 貝茲曲線路徑文字 ============
        function bezierPoint(t, p0, p1, p2, p3) {
            const u = 1 - t;
            return {
                x: u*u*u*p0.x + 3*u*u*t*p1.x + 3*u*t*t*p2.x + t*t*t*p3.x,
                y: u*u*u*p0.y + 3*u*u*t*p1.y + 3*u*t*t*p2.y + t*t*t*p3.y
            };
        }
        
        function bezierTangent(t, p0, p1, p2, p3) {
            const u = 1 - t;
            return {
                x: 3*u*u*(p1.x-p0.x) + 6*u*t*(p2.x-p1.x) + 3*t*t*(p3.x-p2.x),
                y: 3*u*u*(p1.y-p0.y) + 6*u*t*(p2.y-p1.y) + 3*t*t*(p3.y-p2.y)
            };
        }
        
        function bezierLength(p0, p1, p2, p3, steps) {
            steps = steps || 100;
            let len = 0, prev = p0;
            for (let i = 1; i <= steps; i++) {
                const pt = bezierPoint(i / steps, p0, p1, p2, p3);
                len += Math.hypot(pt.x - prev.x, pt.y - prev.y);
                prev = pt;
            }
            return len;
        }
        
        function tAtLength(targetLen, p0, p1, p2, p3, totalLen) {
            let len = 0, prev = p0;
            const steps = 200;
            for (let i = 1; i <= steps; i++) {
                const t = i / steps;
                const pt = bezierPoint(t, p0, p1, p2, p3);
                len += Math.hypot(pt.x - prev.x, pt.y - prev.y);
                prev = pt;
                if (len >= targetLen) return t;
            }
            return 1;
        }

        function drawTextWithScale(r) {
            if (!r.text.trim()) return;
            
            const scaleY = r.scaleY || 1.2;
            const lineHeightRatio = r.lineHeight || 1.2;
            const letterSpacing = r.letterSpacing || 0;
            const rotation = r.rotation || 0;
            const textAlign = r.textAlign || 'left';
            
            ctx.save();
            
            // 設定陰影
            if (r.shadowBlur > 0) {
                ctx.shadowColor = r.shadowColor || '#000000';
                ctx.shadowBlur = r.shadowBlur;
                ctx.shadowOffsetX = r.shadowOffsetX || 0;
                ctx.shadowOffsetY = r.shadowOffsetY || 0;
            }
            
            ctx.font = `${r.fontWeight} ${r.fontSize}px "${r.fontFamily}", "Noto Sans TC", sans-serif`;
            ctx.textBaseline = 'middle';
            
            // 準備填充樣式（漸層或純色）
            let fillStyle = r.color;
            if (r.gradientEnabled) {
                const gradient = ctx.createLinearGradient(
                    r.gradientDirection === 'vertical' ? r.x : r.x,
                    r.gradientDirection === 'horizontal' ? r.y : r.y,
                    r.gradientDirection === 'vertical' ? r.x : r.x + r.w,
                    r.gradientDirection === 'horizontal' ? r.y : r.y + r.h
                );
                gradient.addColorStop(0, r.gradientColor1 || '#ff0000');
                gradient.addColorStop(1, r.gradientColor2 || '#0000ff');
                fillStyle = gradient;
            }
            
            // 曲線文字模式
            if (r.curveEnabled) {
                const text = stripColorTags(r.text.replace(/\n/g, ' '));
                const colorSegments = parseMultiColorText(r.text.replace(/\n/g, ' '), r.color);
                
                // 建立每個字元的顏色映射
                const charColors = [];
                for (const seg of colorSegments) {
                    for (const ch of seg.text) charColors.push(seg.color);
                }
                
                if (r.curveMode === 'bezier') {
                    // 貝茲曲線模式
                    const p0 = { x: r.x + (r.bezierP0x ?? 0) / 100 * r.w, y: r.y + (r.bezierP0y ?? 80) / 100 * r.h };
                    const p1 = { x: r.x + (r.bezierP1x ?? 25) / 100 * r.w, y: r.y + (r.bezierP1y ?? 0) / 100 * r.h };
                    const p2 = { x: r.x + (r.bezierP2x ?? 75) / 100 * r.w, y: r.y + (r.bezierP2y ?? 0) / 100 * r.h };
                    const p3 = { x: r.x + (r.bezierP3x ?? 100) / 100 * r.w, y: r.y + (r.bezierP3y ?? 80) / 100 * r.h };
                    
                    const totalLen = bezierLength(p0, p1, p2, p3);
                    const chars = [...text];
                    
                    // 計算每個字元寬度
                    const charWidths = chars.map(ch => ctx.measureText(ch).width + (letterSpacing || 0));
                    const totalTextWidth = charWidths.reduce((a, b) => a + b, 0) - (letterSpacing || 0);
                    
                    let currentLen = Math.max(0, (totalLen - totalTextWidth) / 2);
                    
                    chars.forEach((char, i) => {
                        const t = tAtLength(currentLen + charWidths[i] / 2, p0, p1, p2, p3, totalLen);
                        const pt = bezierPoint(t, p0, p1, p2, p3);
                        const tan = bezierTangent(t, p0, p1, p2, p3);
                        const angle = Math.atan2(tan.y, tan.x);
                        
                        ctx.save();
                        ctx.translate(pt.x, pt.y);
                        ctx.rotate(angle);
                        ctx.scale(1, scaleY);
                        ctx.textAlign = 'center';
                        
                        if (r.strokeWidth > 0) {
                            ctx.strokeStyle = r.strokeColor || '#000000';
                            ctx.lineWidth = r.strokeWidth;
                            ctx.strokeText(char, 0, 0);
                        }
                        ctx.fillStyle = r.gradientEnabled ? fillStyle : (charColors[i] || r.color);
                        ctx.fillText(char, 0, 0);
                        ctx.restore();
                        
                        currentLen += charWidths[i];
                    });
                } else {
                    // 圓弧模式
                    const centerX = r.x + r.w / 2;
                    const centerY = r.y + r.h / 2;
                    const radius = r.curveRadius || 100;
                    const startAngle = ((r.curveStartAngle || 0) - 90) * Math.PI / 180;
                    
                    const totalAngle = Math.PI * 0.8;
                    const angleStep = text.length > 1 ? totalAngle / (text.length - 1) : 0;
                    let currentAngle = startAngle - totalAngle / 2;
                    
                    for (let i = 0; i < text.length; i++) {
                        const char = text[i];
                        const x = centerX + radius * Math.cos(currentAngle);
                        const y = centerY + radius * Math.sin(currentAngle);
                        
                        ctx.save();
                        ctx.translate(x, y);
                        ctx.rotate(currentAngle + Math.PI / 2);
                        ctx.scale(1, scaleY);
                        
                        if (r.strokeWidth > 0) {
                            ctx.strokeStyle = r.strokeColor || '#000000';
                            ctx.lineWidth = r.strokeWidth;
                            ctx.strokeText(char, 0, 0);
                        }
                        ctx.fillStyle = r.gradientEnabled ? fillStyle : (charColors[i] || r.color);
                        ctx.fillText(char, 0, 0);
                        
                        ctx.restore();
                        currentAngle += angleStep;
                    }
                }
                
                ctx.restore();
                return;
            }
            
            // 一般文字模式
            const lines = r.text.split('\n');
            const lineHeight = r.fontSize * lineHeightRatio;
            const totalHeight = lines.length * lineHeight * scaleY;
            const startY = r.y + (r.h - totalHeight) / 2 + (lineHeight * scaleY) / 2;
            
            // 計算區域中心（用於旋轉）
            const centerX = r.x + r.w / 2;
            const centerY = r.y + r.h / 2;
            
            // 應用旋轉
            if (rotation !== 0) {
                ctx.translate(centerX, centerY);
                ctx.rotate(rotation * Math.PI / 180);
                ctx.translate(-centerX, -centerY);
            }
            
            lines.forEach((line, i) => {
                // 計算文字位置（根據對齊方式）
                let textX;
                const textWidth = measureTextWithSpacing(line, letterSpacing);
                
                switch (textAlign) {
                    case 'center':
                        textX = r.x + (r.w - textWidth) / 2;
                        break;
                    case 'right':
                        textX = r.x + r.w - textWidth - 4;
                        break;
                    default: // left
                        textX = r.x + 4;
                }
                
                const textY = startY + i * lineHeight * scaleY;
                
                // 繪製文字（帶字間距和垂直縮放）
                ctx.save();
                ctx.translate(textX, textY);
                ctx.scale(1, scaleY);
                
                if (letterSpacing > 0) {
                    // 有字間距時逐字繪製
                    let offsetX = 0;
                    for (const char of line) {
                        // 描邊
                        if (r.strokeWidth > 0) {
                            ctx.strokeStyle = r.strokeColor || '#000000';
                            ctx.lineWidth = r.strokeWidth;
                            ctx.strokeText(char, offsetX, 0);
                        }
                        // 填充
                        ctx.fillStyle = fillStyle;
                        ctx.fillText(char, offsetX, 0);
                        offsetX += ctx.measureText(char).width + letterSpacing;
                    }
                } else {
                    // 無字間距時 — 支援多色文字
                    const lineSegments = parseMultiColorText(line, r.color);
                    const hasMultiColor = lineSegments.length > 1 || lineSegments[0]?.color !== r.color;
                    if (hasMultiColor && !r.gradientEnabled) {
                        let offsetX = 0;
                        for (const seg of lineSegments) {
                            for (const ch of seg.text) {
                                if (r.strokeWidth > 0) {
                                    ctx.strokeStyle = r.strokeColor || '#000000';
                                    ctx.lineWidth = r.strokeWidth;
                                    ctx.strokeText(ch, offsetX, 0);
                                }
                                ctx.fillStyle = seg.color;
                                ctx.fillText(ch, offsetX, 0);
                                offsetX += ctx.measureText(ch).width;
                            }
                        }
                    } else {
                        // 描邊
                        if (r.strokeWidth > 0) {
                            ctx.strokeStyle = r.strokeColor || '#000000';
                            ctx.lineWidth = r.strokeWidth;
                            ctx.strokeText(stripColorTags(line), 0, 0);
                        }
                        // 填充
                        ctx.fillStyle = fillStyle;
                        ctx.fillText(stripColorTags(line), 0, 0);
                    }
                }
                
                ctx.restore();
            });
            
            ctx.restore();
        }
        
        // 測量帶字間距的文字寬度
        function measureTextWithSpacing(text, spacing) {
            let width = 0;
            for (const char of text) {
                width += ctx.measureText(char).width + spacing;
            }
            return width - spacing; // 最後一個字不加間距
        }
        
        // 重新繪製（清除並重畫）- 解決疊影問題
        function reapplyRegion() {
            if (!state.activeRegion || !state.activeRegion.edited) return;
            
            const r = state.activeRegion;
            const pad = r.padding || 5;
            
            // 保存歷史
            saveHistory('重新繪製');
            
            // 用更大的範圍清除
            const coverX = Math.max(0, r.x - pad);
            const coverY = Math.max(0, r.y - pad);
            const coverW = r.w + pad * 2;
            const coverH = r.h + pad * 2;
            
            ctx.fillStyle = r.bgColor;
            ctx.fillRect(coverX, coverY, coverW, coverH);
            
            // 重新繪製文字（帶縮放）
            drawTextWithScale(r);
            
            updateUndoButton();
            toast('已重新繪製', 'success');
        }

        function commitRegion() {
            if (!state.activeRegion) return;
            
            const r = state.activeRegion;
            const pad = r.padding || 5;
            
            // 如果是透明背景模式，創建浮動文字
            if (r.transparentBg) {
                createFloatingText(r);
                return;
            }
            
            // 保存歷史
            saveHistory('文字編輯');
            
            // 計算含邊距的覆蓋範圍
            const coverX = Math.max(0, r.x - pad);
            const coverY = Math.max(0, r.y - pad);
            const coverW = r.w + pad * 2;
            const coverH = r.h + pad * 2;
            
            // 用背景色填充（覆蓋原文字，包含邊距）
            ctx.fillStyle = r.bgColor;
            ctx.fillRect(coverX, coverY, coverW, coverH);
            
            // 繪製新文字（帶縮放）
            drawTextWithScale(r);
            
            r.edited = true;
            state.activeRegion = null;
            
            renderRegions();
            updatePanel();
            updateUndoButton();
            toast('已寫入圖片', 'success');
        }
        
        // 創建浮動文字（透明背景）
        function createFloatingText(r) {
            const pad = r.padding || 5;
            
            // 保存歷史
            saveHistory('建立浮動文字');
            
            // 先用背景色清除原區域的文字
            const coverX = Math.max(0, r.x - pad);
            const coverY = Math.max(0, r.y - pad);
            const coverW = r.w + pad * 2;
            const coverH = r.h + pad * 2;
            ctx.fillStyle = r.bgColor;
            ctx.fillRect(coverX, coverY, coverW, coverH);
            
            // 創建離屏 canvas 繪製透明背景文字
            const offCanvas = document.createElement('canvas');
            offCanvas.width = r.w + pad * 2;
            offCanvas.height = r.h + pad * 2;
            const offCtx = offCanvas.getContext('2d');
            
            // 確保背景透明
            offCtx.clearRect(0, 0, offCanvas.width, offCanvas.height);
            
            // 繪製文字到離屏 canvas（相對座標）
            const tempRegion = {
                ...r,
                x: pad,
                y: pad
            };
            drawTextOnContext(offCtx, tempRegion);
            
            // 保存浮動圖像數據
            r.floatingImage = offCanvas.toDataURL('image/png');
            r.isFloating = true;
            r.edited = true;
            
            // 保持選中狀態以便移動
            state.activeRegion = r;
            
            renderRegions();
            updatePanel();
            updateUndoButton();
            toast('已建立浮動文字 - 可自由移動到新位置', 'success');
        }
        
        // 在指定 context 上繪製文字
        function drawTextOnContext(targetCtx, r) {
            if (!r.text.trim()) return;
            
            const scaleY = r.scaleY || 1.2;
            const lineHeightRatio = r.lineHeight || 1.2;
            const letterSpacing = r.letterSpacing || 0;
            const rotation = r.rotation || 0;
            const textAlign = r.textAlign || 'left';
            const direction = r.direction || 'horizontal';
            const transform = r.transform || 'none';
            const transformAmount = (r.transformAmount || 50) / 100;
            
            targetCtx.save();
            
            // 設定陰影
            if (r.shadowBlur > 0) {
                targetCtx.shadowColor = r.shadowColor || '#000000';
                targetCtx.shadowBlur = r.shadowBlur;
                targetCtx.shadowOffsetX = r.shadowOffsetX || 0;
                targetCtx.shadowOffsetY = r.shadowOffsetY || 0;
            }
            
            targetCtx.font = `${r.fontWeight} ${r.fontSize}px "${r.fontFamily}", "Noto Sans TC", sans-serif`;
            targetCtx.textBaseline = 'middle';
            
            // 準備填充樣式
            let fillStyle = r.color;
            if (r.gradientEnabled) {
                const gradient = targetCtx.createLinearGradient(
                    r.gradientDirection === 'vertical' ? r.x : r.x,
                    r.gradientDirection === 'horizontal' ? r.y : r.y,
                    r.gradientDirection === 'vertical' ? r.x : r.x + r.w,
                    r.gradientDirection === 'horizontal' ? r.y : r.y + r.h
                );
                gradient.addColorStop(0, r.gradientColor1 || '#ff0000');
                gradient.addColorStop(1, r.gradientColor2 || '#0000ff');
                fillStyle = gradient;
            }
            
            const lines = r.text.split('\n');
            const lineHeight = r.fontSize * lineHeightRatio;
            
            const centerX = r.x + r.w / 2;
            const centerY = r.y + r.h / 2;
            
            if (rotation !== 0) {
                targetCtx.translate(centerX, centerY);
                targetCtx.rotate(rotation * Math.PI / 180);
                targetCtx.translate(-centerX, -centerY);
            }
            
            // 直書模式（含標點修正）
            if (direction === 'vertical') {
                const colWidth = r.fontSize * 1.5;
                const startX = r.x + r.w - colWidth / 2; // 從右開始
                
                lines.forEach((line, colIndex) => {
                    const chars = [...line];
                    const x = startX - colIndex * colWidth;
                    const totalHeight = chars.length * r.fontSize * 1.2;
                    const startY = r.y + (r.h - totalHeight) / 2 + r.fontSize / 2;
                    
                    chars.forEach((char, charIndex) => {
                        const y = startY + charIndex * r.fontSize * 1.2;
                        const vertChar = r.verticalPunctFix !== false ? getVerticalChar(char) : char;
                        const needsRotate = r.verticalPunctFix !== false && needsVerticalRotation(char);
                        
                        targetCtx.save();
                        targetCtx.translate(x, y);
                        if (needsRotate) {
                            targetCtx.rotate(Math.PI / 2);
                        }
                        targetCtx.scale(1, scaleY);
                        targetCtx.textAlign = 'center';
                        
                        if (r.strokeWidth > 0) {
                            targetCtx.strokeStyle = r.strokeColor || '#000000';
                            targetCtx.lineWidth = r.strokeWidth;
                            targetCtx.strokeText(vertChar, 0, 0);
                        }
                        targetCtx.fillStyle = fillStyle;
                        targetCtx.fillText(vertChar, 0, 0);
                        targetCtx.restore();
                    });
                });
                targetCtx.restore();
                return;
            }
            
            // 橫書模式（含變形效果）
            const totalHeight = lines.length * lineHeight * scaleY;
            const startY = r.y + (r.h - totalHeight) / 2 + (lineHeight * scaleY) / 2;
            
            // 繪製單個字元的輔助函數
            function drawCharWithTransform(char, baseX, baseY, charIndex, totalChars) {
                let finalX = baseX;
                let finalY = baseY;
                let charScale = 1;
                let charRotation = 0;
                
                // 應用變形效果
                if (transform !== 'none' && totalChars > 1) {
                    const progress = charIndex / Math.max(totalChars - 1, 1);
                    const distFromCenter = Math.abs(progress - 0.5);
                    
                    switch (transform) {
                        case 'arc':
                            const arcAngle = (progress - 0.5) * Math.PI * transformAmount;
                            finalY += Math.cos(arcAngle) * r.fontSize * transformAmount * 0.5 - r.fontSize * transformAmount * 0.5;
                            break;
                        case 'arc-down':
                            const arcDownAngle = (progress - 0.5) * Math.PI * transformAmount;
                            finalY -= Math.cos(arcDownAngle) * r.fontSize * transformAmount * 0.5 - r.fontSize * transformAmount * 0.5;
                            break;
                        case 'wave':
                            finalY += Math.sin(progress * Math.PI * 4 * transformAmount) * r.fontSize * 0.3 * transformAmount;
                            break;
                        case 'bulge':
                            charScale = 1 + (1 - distFromCenter * 2) * transformAmount * 0.5;
                            break;
                        case 'pinch':
                            charScale = 1 - (1 - distFromCenter * 2) * transformAmount * 0.3;
                            break;
                        case 'flag':
                            finalY += Math.sin(progress * Math.PI * 2) * r.fontSize * 0.3 * transformAmount;
                            charScale = 1 + Math.sin(progress * Math.PI) * transformAmount * 0.2;
                            break;
                        case 'fish':
                            const fishScale = 1 - Math.pow(progress - 0.5, 2) * 4 * transformAmount * 0.5;
                            charScale = Math.max(0.5, fishScale);
                            finalY += (1 - fishScale) * r.fontSize * 0.3;
                            break;
                    }
                }
                
                targetCtx.save();
                targetCtx.translate(finalX, finalY);
                if (charRotation !== 0) {
                    targetCtx.rotate(charRotation);
                }
                targetCtx.scale(charScale, scaleY * charScale);
                targetCtx.textAlign = 'left';
                
                if (r.strokeWidth > 0) {
                    targetCtx.strokeStyle = r.strokeColor || '#000000';
                    targetCtx.lineWidth = r.strokeWidth;
                    targetCtx.strokeText(char, 0, 0);
                }
                targetCtx.fillStyle = fillStyle;
                targetCtx.fillText(char, 0, 0);
                targetCtx.restore();
            }
            
            lines.forEach((line, i) => {
                const y = startY + i * lineHeight * scaleY;
                let x = r.x;
                
                if (textAlign === 'center') {
                    x = r.x + r.w / 2;
                } else if (textAlign === 'right') {
                    x = r.x + r.w;
                }
                
                // 如果有變形效果，逐字繪製
                if (transform !== 'none') {
                    const chars = [...line];
                    const totalWidth = chars.reduce((sum, char) => sum + targetCtx.measureText(char).width + letterSpacing, -letterSpacing);
                    
                    let startX = x;
                    if (textAlign === 'center') {
                        startX = x - totalWidth / 2;
                    } else if (textAlign === 'right') {
                        startX = x - totalWidth;
                    }
                    
                    let currentX = startX;
                    chars.forEach((char, charIndex) => {
                        drawCharWithTransform(char, currentX, y, charIndex, chars.length);
                        currentX += targetCtx.measureText(char).width + letterSpacing;
                    });
                } else {
                    // 無變形，使用原本的繪製方式
                    targetCtx.save();
                    targetCtx.translate(x, y);
                    targetCtx.scale(1, scaleY);
                    targetCtx.textAlign = textAlign;
                    
                    if (letterSpacing === 0) {
                        if (r.strokeWidth > 0) {
                            targetCtx.strokeStyle = r.strokeColor || '#000000';
                            targetCtx.lineWidth = r.strokeWidth;
                            targetCtx.strokeText(line, 0, 0);
                        }
                        targetCtx.fillStyle = fillStyle;
                        targetCtx.fillText(line, 0, 0);
                    } else {
                        let currentX = 0;
                        if (textAlign === 'center') {
                            const totalWidth = [...line].reduce((sum, char) => sum + targetCtx.measureText(char).width + letterSpacing, -letterSpacing);
                            currentX = -totalWidth / 2;
                        } else if (textAlign === 'right') {
                            const totalWidth = [...line].reduce((sum, char) => sum + targetCtx.measureText(char).width + letterSpacing, -letterSpacing);
                            currentX = -totalWidth;
                        }
                        
                        for (const char of line) {
                            if (r.strokeWidth > 0) {
                                targetCtx.strokeStyle = r.strokeColor || '#000000';
                                targetCtx.lineWidth = r.strokeWidth;
                                targetCtx.strokeText(char, currentX, 0);
                            }
                            targetCtx.fillStyle = fillStyle;
                            targetCtx.fillText(char, currentX, 0);
                            currentX += targetCtx.measureText(char).width + letterSpacing;
                        }
                    }
                    
                    targetCtx.restore();
                }
            });
            
            targetCtx.restore();
        }
        
        // 確認浮動文字位置（最終繪製）
        function commitFloatingText() {
            if (!state.activeRegion || !state.activeRegion.isFloating) return;
            
            const r = state.activeRegion;
            
            // 保存歷史
            saveHistory('確認文字位置');
            
            // 繪製到主畫布（透明背景，只繪製文字）
            const img = new Image();
            img.onload = () => {
                const pad = r.padding || 5;
                ctx.drawImage(img, r.x - pad, r.y - pad);
                
                // 清除浮動狀態
                r.isFloating = false;
                r.floatingImage = null;
                r.originalPosition = null;
                r.originalCleared = null;
                state.activeRegion = null;
                
                renderRegions();
                updatePanel();
                updateUndoButton();
                toast('文字已固定到圖片', 'success');
            };
            img.src = r.floatingImage;
        }
        
        // 取消浮動文字（還原）
        function cancelFloatingText() {
            if (!state.activeRegion || !state.activeRegion.isFloating) return;
            
            const r = state.activeRegion;
            
            // 復原到建立浮動文字前的狀態（會恢復原文字）
            undoLast();
            
            // 移除該區域
            const idx = state.regions.indexOf(r);
            if (idx > -1) {
                state.regions.splice(idx, 1);
            }
            state.activeRegion = null;
            
            renderRegions();
            updatePanel();
            toast('已取消並還原原文字', 'info');
        }

        function cancelRegion() {
            // 清除選取預覽
            clearSelectionPreview();
            
            state.activeRegion = null;
            renderRegions();
            updatePanel();
        }

        function deleteRegion() {
            if (!state.activeRegion) return;
            
            const region = state.activeRegion;
            const pad = region.padding || 2;
            
            // 如果區塊已編輯過，需要用背景色清除該區域
            if (region.edited) {
                saveHistory('刪除區域');
                
                // 用背景色填充該區域（含邊距）
                const coverX = Math.max(0, region.x - pad);
                const coverY = Math.max(0, region.y - pad);
                ctx.fillStyle = region.bgColor;
                ctx.fillRect(coverX, coverY, region.w + pad * 2, region.h + pad * 2);
                
                updateUndoButton();
            }
            
            const idx = state.regions.indexOf(state.activeRegion);
            if (idx !== -1) {
                state.regions.splice(idx, 1);
            }
            state.activeRegion = null;
            
            renderRegions();
            updatePanel();
            toast('已刪除區域', 'success');
        }

        function saveHistory(actionName = '操作') {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            // 複製區域狀態
            const regionsCopy = JSON.parse(JSON.stringify(state.regions.map(r => ({
                ...r,
                edited: r.edited
            }))));
            
            // 如果當前不在歷史末尾，刪除後面的記錄（新操作會覆蓋 redo 記錄）
            if (state.historyIndex < state.history.length - 1) {
                state.history = state.history.slice(0, state.historyIndex + 1);
                state.historyNames = state.historyNames.slice(0, state.historyIndex + 1);
            }
            
            state.history.push({
                imageData: imageData,
                regions: regionsCopy,
                canvasWidth: canvas.width,   // 保存畫布尺寸
                canvasHeight: canvas.height, // 保存畫布尺寸
                timestamp: Date.now()
            });
            state.historyNames.push(actionName);
            state.historyIndex = state.history.length - 1;
            
            // 限制歷史記錄數量
            if (state.history.length > 50) {
                state.history.shift();
                state.historyNames.shift();
                state.historyIndex--;
            }
            
            updateUndoButton();
            updateHistoryPanel();
        }

        function undoLast() {
            if (state.historyIndex <= 0) {
                toast('沒有更多可復原的操作', 'error');
                return;
            }
            
            state.historyIndex--;
            
            // 取得上一個狀態
            const prevState = state.history[state.historyIndex];
            
            // 恢復畫布尺寸（從保存的尺寸或從 imageData 推斷）
            const prevWidth = prevState.canvasWidth || prevState.imageData.width;
            const prevHeight = prevState.canvasHeight || prevState.imageData.height;
            
            if (canvas.width !== prevWidth || canvas.height !== prevHeight) {
                canvas.width = prevWidth;
                canvas.height = prevHeight;
                state.image = { width: prevWidth, height: prevHeight };
            }
            
            // 恢復圖片
            ctx.putImageData(prevState.imageData, 0, 0);
            
            // 恢復區域狀態
            state.regions = prevState.regions.map(r => ({...r}));
            state.activeRegion = null;
            
            renderRegions();
            updatePanel();
            updateUndoButton();
            updateHistoryPanel();
            fitCanvasToScreen();
            
            toast(`已復原「${state.historyNames[state.historyIndex + 1] || '操作'}」`, 'success');
        }
        
        function redoLast() {
            if (state.historyIndex >= state.history.length - 1) {
                toast('沒有可重做的操作', 'error');
                return;
            }
            
            state.historyIndex++;
            
            // 取得下一個狀態
            const nextState = state.history[state.historyIndex];
            
            // 恢復畫布尺寸（從保存的尺寸或從 imageData 推斷）
            const nextWidth = nextState.canvasWidth || nextState.imageData.width;
            const nextHeight = nextState.canvasHeight || nextState.imageData.height;
            
            if (canvas.width !== nextWidth || canvas.height !== nextHeight) {
                canvas.width = nextWidth;
                canvas.height = nextHeight;
                state.image = { width: nextWidth, height: nextHeight };
            }
            
            // 恢復圖片
            ctx.putImageData(nextState.imageData, 0, 0);
            
            // 恢復區域狀態
            state.regions = nextState.regions.map(r => ({...r}));
            state.activeRegion = null;
            
            renderRegions();
            updatePanel();
            updateUndoButton();
            updateHistoryPanel();
            fitCanvasToScreen();
            
            toast(`已重做「${state.historyNames[state.historyIndex] || '操作'}」`, 'success');
        }
        
        function updateUndoButton() {
            const undoCount = state.historyIndex;
            const redoCount = state.history.length - 1 - state.historyIndex;
            
            const undoBtn = document.getElementById('undo-btn');
            const redoBtn = document.getElementById('redo-btn');
            
            if (undoBtn) {
                undoBtn.textContent = undoCount > 0 ? `↶ 復原 (${undoCount})` : '↶ 復原';
                undoBtn.style.opacity = undoCount > 0 ? '1' : '0.5';
            }
            
            if (redoBtn) {
                redoBtn.textContent = redoCount > 0 ? `↷ 重做 (${redoCount})` : '↷ 重做';
                redoBtn.style.opacity = redoCount > 0 ? '1' : '0.5';
            }
        }
        
        // ============ 歷史記錄面板 ============
        
        function toggleHistoryPanel() {
            const panel = document.getElementById('history-panel');
            panel.classList.toggle('show');
            if (panel.classList.contains('show')) {
                updateHistoryPanel();
            }
        }
        
        function updateHistoryPanel() {
            const list = document.getElementById('history-list');
            if (!list) return;
            
            if (state.history.length === 0) {
                list.innerHTML = '<div style="padding:20px;text-align:center;color:#666;">尚無歷史記錄</div>';
                return;
            }
            
            const icons = {
                '載入圖片': '🖼️',
                '框選區域': '⛶',
                '魔術棒選取': '🪄',
                '文字編輯': '✏️',
                '清除區域': '🧹',
                '畫筆': '🖌️',
                '形狀': '⬜',
                '馬賽克': '🔲',
                '模糊': '💧',
                '貼上圖片': '📋',
                '拼接圖片': '📑',
                '調整尺寸': '📐',
                '橡皮擦': '🧽',
                '油漆桶填充': '🪣',
                '漸層填充': '🌈',
                '文字': '✏️',
                '操作': '📝'
            };
            
            let html = '';
            for (let i = 0; i < state.history.length; i++) {
                const name = state.historyNames[i] || '操作';
                const icon = icons[name] || '📝';
                const isCurrent = i === state.historyIndex;
                const isFuture = i > state.historyIndex;
                const time = state.history[i].timestamp ? new Date(state.history[i].timestamp).toLocaleTimeString() : '';
                const w = state.history[i].canvasWidth || state.history[i].imageData.width;
                const h = state.history[i].canvasHeight || state.history[i].imageData.height;
                const sizeInfo = `${w}×${h}`;
                
                html += `
                    <div class="history-item ${isCurrent ? 'current' : ''} ${isFuture ? 'future' : ''}" 
                         onclick="jumpToHistory(${i})" title="${sizeInfo}">
                        <span class="history-item-icon">${icon}</span>
                        <span class="history-item-name">${name}</span>
                        <span class="history-item-time">${time}</span>
                    </div>
                `;
            }
            
            list.innerHTML = html;
            
            // 滾動到當前位置
            const currentItem = list.querySelector('.current');
            if (currentItem) {
                currentItem.scrollIntoView({ block: 'nearest' });
            }
        }
        
        function jumpToHistory(index) {
            if (index < 0 || index >= state.history.length) return;
            
            state.historyIndex = index;
            
            const targetState = state.history[index];
            
            // 恢復畫布尺寸（從保存的尺寸或從 imageData 推斷）
            const targetWidth = targetState.canvasWidth || targetState.imageData.width;
            const targetHeight = targetState.canvasHeight || targetState.imageData.height;
            
            if (canvas.width !== targetWidth || canvas.height !== targetHeight) {
                canvas.width = targetWidth;
                canvas.height = targetHeight;
                state.image = { width: targetWidth, height: targetHeight };
            }
            
            // 恢復圖片
            ctx.putImageData(targetState.imageData, 0, 0);
            
            // 恢復區域狀態
            state.regions = targetState.regions.map(r => ({...r}));
            state.activeRegion = null;
            
            renderRegions();
            updatePanel();
            updateUndoButton();
            updateHistoryPanel();
            fitCanvasToScreen();
            
            toast(`跳轉到「${state.historyNames[index] || '操作'}」`, 'success');
        }
        
        // ============ 剪貼簿貼上 ============
        
        async function handlePaste(e) {
            const items = e.clipboardData?.items;
            if (!items) return;
            
            for (const item of items) {
                if (item.type.startsWith('image/')) {
                    e.preventDefault();
                    
                    const blob = item.getAsFile();
                    
                    // 使用 FileReader 而非 blob URL 以避免跨域問題
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const img = new Image();
                        img.onload = () => {
                            try {
                                // 如果已有圖片，保存歷史
                                if (state.image) {
                                    saveHistory('貼上圖片');
                                }
                                
                                state.image = img;
                                canvas.width = img.width;
                                canvas.height = img.height;
                                ctx.drawImage(img, 0, 0);
                                
                                fitCanvasToView();
                                
                                // 如果是第一張圖片，初始化歷史
                                if (state.history.length === 0) {
                                    saveHistory('載入圖片');
                                }
                                
                                state.regions = [];
                                state.activeRegion = null;
                                state.pdfPages = [];
                                document.getElementById('pdf-nav').classList.remove('show');
                                document.getElementById('btn-download').disabled = false;
                                document.getElementById('btn-pptx').disabled = false;
                                
                                renderRegions();
                                updatePanel();
                                
                                toast('已從剪貼簿貼上圖片', 'success');
                            } catch(err) {
                                // 靜默忽略
                            }
                        };
                        img.src = event.target.result;
                    };
                    reader.readAsDataURL(blob);
                    return;
                }
            }
        }
        
        // ============ 圖片拼接 ============
        
        function openStitchDialog() {
            document.getElementById('stitch-dialog').classList.add('show');
            state.stitchImages = [];
            updateStitchImagesList();
            updateStitchPreview();
        }
        
        function closeStitchDialog() {
            document.getElementById('stitch-dialog').classList.remove('show');
            state.stitchImages = [];
        }
        
        function handleStitchFiles(files) {
            for (const file of files) {
                if (file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const img = new Image();
                        img.onload = () => {
                            state.stitchImages.push({
                                img: img,
                                name: file.name
                            });
                            updateStitchImagesList();
                            updateStitchPreview();
                        };
                        img.src = e.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            }
        }
        
        function updateStitchImagesList() {
            const list = document.getElementById('stitch-images-list');
            const applyBtn = document.getElementById('apply-stitch-btn');
            
            if (state.stitchImages.length === 0) {
                list.innerHTML = '<div style="color:#666;padding:20px;text-align:center;width:100%;">尚未選擇圖片</div>';
                applyBtn.disabled = true;
                return;
            }
            
            applyBtn.disabled = false;
            
            list.innerHTML = state.stitchImages.map((item, i) => `
                <div class="stitch-image-item" draggable="true" 
                     ondragstart="dragStitchStart(event, ${i})"
                     ondragover="dragStitchOver(event)"
                     ondrop="dropStitch(event, ${i})">
                    <img src="${item.img.src}" alt="${item.name}">
                    <button class="remove-btn" onclick="removeStitchImage(${i})">×</button>
                    <div class="order-num">${i + 1}</div>
                </div>
            `).join('');
        }
        
        let dragStitchIndex = null;
        
        function dragStitchStart(e, index) {
            dragStitchIndex = index;
            e.dataTransfer.effectAllowed = 'move';
        }
        
        function dragStitchOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
        }
        
        function dropStitch(e, targetIndex) {
            e.preventDefault();
            if (dragStitchIndex === null || dragStitchIndex === targetIndex) return;
            
            const item = state.stitchImages.splice(dragStitchIndex, 1)[0];
            state.stitchImages.splice(targetIndex, 0, item);
            dragStitchIndex = null;
            
            updateStitchImagesList();
            updateStitchPreview();
        }
        
        function removeStitchImage(index) {
            state.stitchImages.splice(index, 1);
            updateStitchImagesList();
            updateStitchPreview();
        }
        
        function setStitchMode(mode) {
            state.stitchMode = mode;
            document.querySelectorAll('.stitch-option').forEach(el => {
                el.classList.toggle('selected', el.dataset.mode === mode);
            });
            updateStitchPreview();
        }
        
        function updateStitchPreview() {
            const preview = document.getElementById('stitch-preview');
            const gapInput = document.getElementById('stitch-gap');
            const gapValue = document.getElementById('stitch-gap-value');
            
            state.stitchGap = parseInt(gapInput.value) || 0;
            gapValue.textContent = state.stitchGap + 'px';
            
            if (state.stitchImages.length === 0) {
                preview.innerHTML = '<div style="color:#666;">請先添加圖片</div>';
                return;
            }
            
            // 創建預覽 canvas
            const previewCanvas = document.createElement('canvas');
            const previewCtx = previewCanvas.getContext('2d');
            
            const images = state.stitchImages.map(item => item.img);
            const gap = state.stitchGap;
            
            let totalWidth, totalHeight;
            
            if (state.stitchMode === 'vertical') {
                totalWidth = Math.max(...images.map(img => img.width));
                totalHeight = images.reduce((sum, img) => sum + img.height, 0) + gap * (images.length - 1);
            } else if (state.stitchMode === 'horizontal') {
                totalWidth = images.reduce((sum, img) => sum + img.width, 0) + gap * (images.length - 1);
                totalHeight = Math.max(...images.map(img => img.height));
            } else { // grid
                const cols = Math.ceil(Math.sqrt(images.length));
                const rows = Math.ceil(images.length / cols);
                const maxW = Math.max(...images.map(img => img.width));
                const maxH = Math.max(...images.map(img => img.height));
                totalWidth = cols * maxW + gap * (cols - 1);
                totalHeight = rows * maxH + gap * (rows - 1);
            }
            
            previewCanvas.width = totalWidth;
            previewCanvas.height = totalHeight;
            
            // 填充背景（透明）
            previewCtx.fillStyle = '#333';
            previewCtx.fillRect(0, 0, totalWidth, totalHeight);
            
            // 繪製圖片
            let x = 0, y = 0;
            
            if (state.stitchMode === 'vertical') {
                images.forEach((img, i) => {
                    const offsetX = (totalWidth - img.width) / 2;
                    previewCtx.drawImage(img, offsetX, y);
                    y += img.height + gap;
                });
            } else if (state.stitchMode === 'horizontal') {
                images.forEach((img, i) => {
                    const offsetY = (totalHeight - img.height) / 2;
                    previewCtx.drawImage(img, x, offsetY);
                    x += img.width + gap;
                });
            } else { // grid
                const cols = Math.ceil(Math.sqrt(images.length));
                const maxW = Math.max(...images.map(img => img.width));
                const maxH = Math.max(...images.map(img => img.height));
                
                images.forEach((img, i) => {
                    const col = i % cols;
                    const row = Math.floor(i / cols);
                    const cellX = col * (maxW + gap);
                    const cellY = row * (maxH + gap);
                    const offsetX = (maxW - img.width) / 2;
                    const offsetY = (maxH - img.height) / 2;
                    previewCtx.drawImage(img, cellX + offsetX, cellY + offsetY);
                });
            }
            
            preview.innerHTML = `<img src="${previewCanvas.toDataURL()}" alt="預覽">`;
        }
        
        function applyStitch() {
            if (state.stitchImages.length === 0) return;
            
            // 使用預覽生成的邏輯
            const images = state.stitchImages.map(item => item.img);
            const gap = state.stitchGap;
            
            let totalWidth, totalHeight;
            
            if (state.stitchMode === 'vertical') {
                totalWidth = Math.max(...images.map(img => img.width));
                totalHeight = images.reduce((sum, img) => sum + img.height, 0) + gap * (images.length - 1);
            } else if (state.stitchMode === 'horizontal') {
                totalWidth = images.reduce((sum, img) => sum + img.width, 0) + gap * (images.length - 1);
                totalHeight = Math.max(...images.map(img => img.height));
            } else { // grid
                const cols = Math.ceil(Math.sqrt(images.length));
                const rows = Math.ceil(images.length / cols);
                const maxW = Math.max(...images.map(img => img.width));
                const maxH = Math.max(...images.map(img => img.height));
                totalWidth = cols * maxW + gap * (cols - 1);
                totalHeight = rows * maxH + gap * (rows - 1);
            }
            
            // 保存歷史
            if (state.image) {
                saveHistory('拼接圖片');
            }
            
            // 調整 canvas 大小
            canvas.width = totalWidth;
            canvas.height = totalHeight;
            
            // 填充白色背景
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, totalWidth, totalHeight);
            
            // 繪製圖片
            let x = 0, y = 0;
            
            if (state.stitchMode === 'vertical') {
                images.forEach((img, i) => {
                    const offsetX = (totalWidth - img.width) / 2;
                    ctx.drawImage(img, offsetX, y);
                    y += img.height + gap;
                });
            } else if (state.stitchMode === 'horizontal') {
                images.forEach((img, i) => {
                    const offsetY = (totalHeight - img.height) / 2;
                    ctx.drawImage(img, x, offsetY);
                    x += img.width + gap;
                });
            } else { // grid
                const cols = Math.ceil(Math.sqrt(images.length));
                const maxW = Math.max(...images.map(img => img.width));
                const maxH = Math.max(...images.map(img => img.height));
                
                images.forEach((img, i) => {
                    const col = i % cols;
                    const row = Math.floor(i / cols);
                    const cellX = col * (maxW + gap);
                    const cellY = row * (maxH + gap);
                    const offsetX = (maxW - img.width) / 2;
                    const offsetY = (maxH - img.height) / 2;
                    ctx.drawImage(img, cellX + offsetX, cellY + offsetY);
                });
            }
            
            // 建立合成圖片物件
            const stitchedImg = new Image();
            stitchedImg.src = canvas.toDataURL();
            state.image = stitchedImg;
            
            fitCanvasToView();
            
            // 初始化歷史（如果是第一次）
            if (state.history.length === 0) {
                saveHistory('拼接圖片');
            }
            
            state.regions = [];
            state.activeRegion = null;
            state.pdfPages = [];
            document.getElementById('pdf-nav').classList.remove('show');
            document.getElementById('btn-download').disabled = false;
            document.getElementById('btn-pptx').disabled = false;
            
            renderRegions();
            updatePanel();
            
            closeStitchDialog();
            toast(`已拼接 ${images.length} 張圖片`, 'success');
        }

        // ============ 插入圖像功能 ============
        
        function insertImageToCanvas() {
            if (!state.image) {
                toast('請先載入圖片或新增空白頁面', 'error');
                return;
            }
            
            const dialog = document.createElement('div');
            dialog.id = 'insert-image-dialog';
            dialog.style.cssText = `
                position: fixed;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                background: #1a1a1a;
                border: 1px solid #444;
                border-radius: 12px;
                padding: 20px;
                z-index: 10001;
                width: 450px;
                box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            `;
            
            dialog.innerHTML = `
                <h3 style="margin:0 0 15px 0;display:flex;justify-content:space-between;align-items:center;">
                    <span>🖼️ 插入圖像</span>
                    <button onclick="document.getElementById('insert-image-dialog').remove()" 
                        style="background:none;border:none;color:#fff;font-size:20px;cursor:pointer;">×</button>
                </h3>
                
                <div style="margin-bottom:15px;">
                    <label style="display:block;margin-bottom:8px;font-size:12px;color:#aaa;">選擇圖像來源</label>
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;">
                        <label class="btn btn-outline" style="display:flex;flex-direction:column;align-items:center;padding:20px;cursor:pointer;">
                            <span style="font-size:32px;margin-bottom:8px;">📁</span>
                            <span>從電腦選擇</span>
                            <input type="file" accept="image/*" onchange="handleInsertImageFile(this)" style="display:none;">
                        </label>
                        <button class="btn btn-outline" style="display:flex;flex-direction:column;align-items:center;padding:20px;" onclick="insertImageFromClipboard()">
                            <span style="font-size:32px;margin-bottom:8px;">📋</span>
                            <span>從剪貼簿貼上</span>
                        </button>
                    </div>
                </div>
                
                <div style="margin-bottom:15px;">
                    <label style="display:block;margin-bottom:8px;font-size:12px;color:#aaa;">或輸入圖片網址</label>
                    <div style="display:flex;gap:8px;">
                        <input type="text" id="insert-image-url" placeholder="https://example.com/image.png" 
                            style="flex:1;padding:10px;background:#2a2a2a;border:1px solid #444;border-radius:6px;color:#fff;">
                        <button onclick="insertImageFromUrl()" class="btn btn-primary" style="padding:10px 15px;">載入</button>
                    </div>
                </div>
                
                <div id="insert-image-preview" style="display:none;margin-bottom:15px;">
                    <label style="display:block;margin-bottom:8px;font-size:12px;color:#aaa;">預覽</label>
                    <div style="background:#2a2a2a;border-radius:8px;padding:10px;text-align:center;">
                        <img id="insert-image-preview-img" style="max-width:100%;max-height:200px;border-radius:4px;">
                    </div>
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px;">
                        <div>
                            <label style="display:block;margin-bottom:4px;font-size:11px;color:#888;">初始寬度</label>
                            <input type="number" id="insert-image-width" min="20" max="2000" 
                                style="width:100%;padding:8px;background:#2a2a2a;border:1px solid #444;border-radius:6px;color:#fff;">
                        </div>
                        <div>
                            <label style="display:block;margin-bottom:4px;font-size:11px;color:#888;">初始高度</label>
                            <input type="number" id="insert-image-height" min="20" max="2000" 
                                style="width:100%;padding:8px;background:#2a2a2a;border:1px solid #444;border-radius:6px;color:#fff;">
                        </div>
                    </div>
                    <div style="margin-top:10px;">
                        <label style="display:flex;align-items:center;gap:8px;font-size:12px;color:#aaa;">
                            <input type="checkbox" id="insert-image-keep-ratio" checked>
                            保持比例
                        </label>
                    </div>
                </div>
                
                <div style="font-size:11px;color:#888;margin-bottom:15px;">
                    💡 提示：插入後可以拖拉移動、縮放、旋轉圖像，點擊「固定到圖片」完成編輯
                </div>
                
                <div style="display:flex;gap:10px;justify-content:flex-end;">
                    <button onclick="document.getElementById('insert-image-dialog').remove()" class="btn btn-outline">取消</button>
                    <button onclick="confirmInsertImage()" id="btn-confirm-insert" class="btn btn-primary" disabled>插入圖像</button>
                </div>
            `;
            
            document.body.appendChild(dialog);
            makeDraggable(dialog);
            
            // 監聽寬度/高度變化以保持比例
            document.getElementById('insert-image-width').addEventListener('input', (e) => {
                if (document.getElementById('insert-image-keep-ratio').checked && insertImageData) {
                    const ratio = insertImageData.height / insertImageData.width;
                    document.getElementById('insert-image-height').value = Math.round(e.target.value * ratio);
                }
            });
            
            document.getElementById('insert-image-height').addEventListener('input', (e) => {
                if (document.getElementById('insert-image-keep-ratio').checked && insertImageData) {
                    const ratio = insertImageData.width / insertImageData.height;
                    document.getElementById('insert-image-width').value = Math.round(e.target.value * ratio);
                }
            });
        }
        
        // 暫存待插入的圖像
        let insertImageData = null;
        
        // 處理選擇的圖片檔案
        function handleInsertImageFile(input) {
            if (!input.files || !input.files[0]) return;
            
            const file = input.files[0];
            const reader = new FileReader();
            
            reader.onload = (e) => {
                loadInsertImagePreview(e.target.result);
            };
            
            reader.readAsDataURL(file);
        }
        
        // 從剪貼簿貼上圖像
        async function insertImageFromClipboard() {
            try {
                const items = await navigator.clipboard.read();
                for (const item of items) {
                    for (const type of item.types) {
                        if (type.startsWith('image/')) {
                            const blob = await item.getType(type);
                            const reader = new FileReader();
                            reader.onload = (e) => {
                                loadInsertImagePreview(e.target.result);
                            };
                            reader.readAsDataURL(blob);
                            return;
                        }
                    }
                }
                toast('剪貼簿中沒有圖片', 'warning');
            } catch (e) {
                toast('無法讀取剪貼簿: ' + e.message, 'error');
            }
        }
        
        // 從網址載入圖像
        function insertImageFromUrl() {
            const url = document.getElementById('insert-image-url').value.trim();
            if (!url) {
                toast('請輸入圖片網址', 'warning');
                return;
            }
            
            loadInsertImagePreview(url);
        }
        
        // 載入圖像預覽
        function loadInsertImagePreview(src) {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            
            img.onload = () => {
                insertImageData = {
                    src: src,
                    width: img.width,
                    height: img.height
                };
                
                // 計算適合的初始尺寸（不超過畫布的 50%）
                let w = img.width;
                let h = img.height;
                const maxW = canvas.width * 0.5;
                const maxH = canvas.height * 0.5;
                
                if (w > maxW) {
                    h = h * (maxW / w);
                    w = maxW;
                }
                if (h > maxH) {
                    w = w * (maxH / h);
                    h = maxH;
                }
                
                document.getElementById('insert-image-preview').style.display = 'block';
                document.getElementById('insert-image-preview-img').src = src;
                document.getElementById('insert-image-width').value = Math.round(w);
                document.getElementById('insert-image-height').value = Math.round(h);
                document.getElementById('btn-confirm-insert').disabled = false;
                
                toast('圖像已載入', 'success');
            };
            
            img.onerror = () => {
                toast('無法載入圖像', 'error');
            };
            
            img.src = src;
        }
        
        // 確認插入圖像
        function confirmInsertImage() {
            if (!insertImageData) return;
            
            const w = parseInt(document.getElementById('insert-image-width').value);
            const h = parseInt(document.getElementById('insert-image-height').value);
            
            document.getElementById('insert-image-dialog').remove();
            
            // 創建圖像區塊
            const centerX = canvas.width / 2 - w / 2;
            const centerY = canvas.height / 2 - h / 2;
            
            const imageRegion = {
                id: Date.now(),
                type: 'image',
                isInsertedImage: true,
                x: Math.max(0, centerX),
                y: Math.max(0, centerY),
                w: w,
                h: h,
                originalW: insertImageData.width,
                originalH: insertImageData.height,
                originalX: Math.max(0, centerX),
                originalY: Math.max(0, centerY),
                imageData: insertImageData.src,
                originalImageData: insertImageData.src,
                bgColor: 'transparent',
                transparentBg: true,
                isFloating: true,
                rotation: 0,
                scale: 1,
                layerIndex: activeLayerIndex // 記錄所屬圖層
            };
            
            state.imageRegions = state.imageRegions || [];
            state.imageRegions.push(imageRegion);
            state.activeImageRegion = imageRegion;
            renderImageRegions();
            
            insertImageData = null;
            
            toast('圖像已插入，可拖拉調整位置和大小', 'success');
        }

        // ============ 浮水印功能 ============
        
        function openWatermarkDialog() {
            if (!state.image) {
                toast('請先載入圖片', 'error');
                return;
            }
            
            // 重置浮水印狀態
            state.watermark = null;
            state.watermarkX = 0;
            state.watermarkY = 0;
            
            document.getElementById('watermark-settings').style.display = 'none';
            document.getElementById('apply-watermark-btn').disabled = true;
            document.getElementById('watermark-dropzone').style.display = 'block';
            document.getElementById('watermark-dialog').classList.add('show');
            
            // 顯示/隱藏多頁選項
            const scopeDiv = document.getElementById('watermark-apply-scope');
            if (state.pdfPages.length > 1) {
                scopeDiv.style.display = 'block';
                // 預設選擇「所有頁面」
                document.querySelector('input[name="watermark-scope"][value="all"]').checked = true;
            } else {
                scopeDiv.style.display = 'none';
            }
            
            // 設置拖放區域事件
            const dropzone = document.getElementById('watermark-dropzone');
            dropzone.ondragover = (e) => {
                e.preventDefault();
                dropzone.style.borderColor = '#6366f1';
                dropzone.style.background = 'rgba(99, 102, 241, 0.1)';
            };
            dropzone.ondragleave = () => {
                dropzone.style.borderColor = '#444';
                dropzone.style.background = 'transparent';
            };
            dropzone.ondrop = (e) => {
                e.preventDefault();
                dropzone.style.borderColor = '#444';
                dropzone.style.background = 'transparent';
                if (e.dataTransfer.files[0]) {
                    handleWatermarkFile(e.dataTransfer.files[0]);
                }
            };
        }
        
        function closeWatermarkDialog() {
            document.getElementById('watermark-dialog').classList.remove('show');
            state.watermark = null;
        }
        
        function handleWatermarkFile(file) {
            if (!file || !file.type.startsWith('image/')) {
                toast('請選擇圖片檔案', 'error');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    state.watermark = img;
                    state.watermarkOriginalWidth = img.width;
                    state.watermarkOriginalHeight = img.height;
                    
                    // 預設大小：原圖的 20% 或最大 200px
                    const maxSize = Math.min(canvas.width, canvas.height) * 0.2;
                    const scale = Math.min(maxSize / img.width, maxSize / img.height, 1);
                    state.watermarkWidth = Math.round(img.width * scale);
                    state.watermarkHeight = Math.round(img.height * scale);
                    
                    // 預設位置：右下角
                    state.watermarkX = canvas.width - state.watermarkWidth - 20;
                    state.watermarkY = canvas.height - state.watermarkHeight - 20;
                    state.watermarkOpacity = 0.5;
                    state.watermarkRotation = 0; // 旋轉角度
                    
                    // 更新 UI
                    document.getElementById('watermark-width').value = state.watermarkWidth;
                    document.getElementById('watermark-height').value = state.watermarkHeight;
                    document.getElementById('watermark-opacity').value = 50;
                    document.getElementById('watermark-opacity-value').textContent = '50%';
                    document.getElementById('watermark-rotation').value = 0;
                    document.getElementById('watermark-rotation-value').textContent = '0°';
                    document.getElementById('watermark-lock-ratio').checked = true;
                    
                    document.getElementById('watermark-dropzone').style.display = 'none';
                    document.getElementById('watermark-settings').style.display = 'block';
                    document.getElementById('apply-watermark-btn').disabled = false;
                    
                    updateWatermarkPreview();
                    setupWatermarkDrag();
                    setupWatermarkRotate();
                    setupWatermarkResize();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
        
        function updateWatermarkPreview() {
            if (!state.watermark || !state.image) return;
            
            const previewCanvas = document.getElementById('watermark-preview-canvas');
            const previewCtx = previewCanvas.getContext('2d');
            const overlay = document.getElementById('watermark-overlay');
            const wrap = document.getElementById('watermark-preview-wrap');
            
            // 計算預覽縮放比例（增大預覽尺寸以便看清高解析度圖像）
            const maxW = 850;
            const maxH = 500;
            const scale = Math.min(maxW / canvas.width, maxH / canvas.height, 1);
            
            const canvasW = Math.round(canvas.width * scale);
            const canvasH = Math.round(canvas.height * scale);
            
            previewCanvas.width = canvasW;
            previewCanvas.height = canvasH;
            previewCanvas.style.width = canvasW + 'px';
            previewCanvas.style.height = canvasH + 'px';
            
            // 繪製背景圖片
            previewCtx.drawImage(canvas, 0, 0, canvasW, canvasH);
            
            // 繪製浮水印（帶透明度和旋轉）
            previewCtx.globalAlpha = state.watermarkOpacity;
            
            const rotation = state.watermarkRotation || 0;
            const wmX = state.watermarkX * scale;
            const wmY = state.watermarkY * scale;
            const wmW = state.watermarkWidth * scale;
            const wmH = state.watermarkHeight * scale;
            
            // 旋轉繪製
            previewCtx.save();
            previewCtx.translate(wmX + wmW / 2, wmY + wmH / 2);
            previewCtx.rotate(rotation * Math.PI / 180);
            previewCtx.drawImage(state.watermark, -wmW / 2, -wmH / 2, wmW, wmH);
            previewCtx.restore();
            
            previewCtx.globalAlpha = 1;
            
            // 更新浮水印覆蓋層位置和旋轉
            overlay.style.display = 'block';
            overlay.style.left = wmX + 'px';
            overlay.style.top = wmY + 'px';
            overlay.style.width = wmW + 'px';
            overlay.style.height = wmH + 'px';
            overlay.style.transform = `rotate(${rotation}deg)`;
            overlay.style.transformOrigin = 'center center';
            
            // 更新角度顯示
            const angleDisplay = document.getElementById('watermark-angle-display');
            if (angleDisplay) {
                angleDisplay.textContent = `${rotation}°`;
            }
            
            // 更新尺寸顯示
            const sizeDisplay = document.getElementById('watermark-size-display');
            if (sizeDisplay) {
                sizeDisplay.textContent = `${state.watermarkWidth} × ${state.watermarkHeight}`;
            }
            
            // 保存縮放比例供拖動使用
            state.watermarkPreviewScale = scale;
        }
        
        function setupWatermarkDrag() {
            const overlay = document.getElementById('watermark-overlay');
            const wrap = document.getElementById('watermark-preview-wrap');
            
            overlay.onmousedown = (e) => {
                // 排除縮放和旋轉控制點
                if (e.target.classList.contains('watermark-resize-handle') ||
                    e.target.classList.contains('watermark-edge-handle') ||
                    e.target.classList.contains('watermark-rotate-handle')) {
                    return;
                }
                
                e.preventDefault();
                state.isWatermarkDragging = true;
                overlay.classList.add('dragging');
                
                const rect = wrap.getBoundingClientRect();
                const scale = state.watermarkPreviewScale;
                
                state.watermarkDragOffset = {
                    x: (e.clientX - rect.left) / scale - state.watermarkX,
                    y: (e.clientY - rect.top) / scale - state.watermarkY
                };
                
                document.addEventListener('mousemove', onWatermarkDragMove);
                document.addEventListener('mouseup', onWatermarkDragEnd);
            };
        }
        
        function onWatermarkDragMove(e) {
            if (!state.isWatermarkDragging) return;
            
            const wrap = document.getElementById('watermark-preview-wrap');
            const rect = wrap.getBoundingClientRect();
            const scale = state.watermarkPreviewScale;
            
            let newX = (e.clientX - rect.left) / scale - state.watermarkDragOffset.x;
            let newY = (e.clientY - rect.top) / scale - state.watermarkDragOffset.y;
            
            // 限制範圍
            newX = Math.max(0, Math.min(canvas.width - state.watermarkWidth, newX));
            newY = Math.max(0, Math.min(canvas.height - state.watermarkHeight, newY));
            
            state.watermarkX = Math.round(newX);
            state.watermarkY = Math.round(newY);
            
            updateWatermarkPreview();
        }
        
        function onWatermarkDragEnd() {
            state.isWatermarkDragging = false;
            document.getElementById('watermark-overlay').classList.remove('dragging');
            document.removeEventListener('mousemove', onWatermarkDragMove);
            document.removeEventListener('mouseup', onWatermarkDragEnd);
        }
        
        // 設置浮水印旋轉拖曳
        function setupWatermarkRotate() {
            const handle = document.getElementById('watermark-rotate-handle');
            const overlay = document.getElementById('watermark-overlay');
            const wrap = document.getElementById('watermark-preview-wrap');
            
            if (!handle) return;
            
            handle.onmousedown = (e) => {
                e.preventDefault();
                e.stopPropagation();
                state.isWatermarkRotating = true;
                handle.classList.add('rotating');
                overlay.classList.add('rotating');
                
                const rect = wrap.getBoundingClientRect();
                const scale = state.watermarkPreviewScale;
                
                // 計算浮水印中心點
                state.watermarkRotateCenter = {
                    x: rect.left + (state.watermarkX + state.watermarkWidth / 2) * scale,
                    y: rect.top + (state.watermarkY + state.watermarkHeight / 2) * scale
                };
                
                document.addEventListener('mousemove', onWatermarkRotateMove);
                document.addEventListener('mouseup', onWatermarkRotateEnd);
            };
        }
        
        function onWatermarkRotateMove(e) {
            if (!state.isWatermarkRotating) return;
            
            const center = state.watermarkRotateCenter;
            
            // 計算從中心到滑鼠的角度
            const dx = e.clientX - center.x;
            const dy = e.clientY - center.y;
            let angle = Math.atan2(dy, dx) * 180 / Math.PI + 90; // 加90度因為控制點在頂部
            
            // 標準化到 -180 ~ 180
            while (angle > 180) angle -= 360;
            while (angle < -180) angle += 360;
            
            // 捕捉到特定角度（每15度）
            if (Math.abs(angle % 15) < 3) {
                angle = Math.round(angle / 15) * 15;
            }
            
            state.watermarkRotation = Math.round(angle);
            
            // 更新滑桿和顯示
            document.getElementById('watermark-rotation').value = state.watermarkRotation;
            document.getElementById('watermark-rotation-value').textContent = state.watermarkRotation + '°';
            
            updateWatermarkPreview();
        }
        
        function onWatermarkRotateEnd() {
            state.isWatermarkRotating = false;
            document.getElementById('watermark-rotate-handle').classList.remove('rotating');
            document.getElementById('watermark-overlay').classList.remove('rotating');
            document.removeEventListener('mousemove', onWatermarkRotateMove);
            document.removeEventListener('mouseup', onWatermarkRotateEnd);
        }
        
        // 設置浮水印縮放拖拉
        function setupWatermarkResize() {
            const overlay = document.getElementById('watermark-overlay');
            
            // 四角縮放控制點
            overlay.querySelectorAll('.watermark-resize-handle').forEach(handle => {
                handle.onmousedown = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    state.isWatermarkResizing = true;
                    state.watermarkResizeCorner = handle.dataset.corner;
                    state.watermarkResizeStart = {
                        x: state.watermarkX,
                        y: state.watermarkY,
                        w: state.watermarkWidth,
                        h: state.watermarkHeight,
                        mouseX: e.clientX,
                        mouseY: e.clientY
                    };
                    
                    document.addEventListener('mousemove', onWatermarkResizeMove);
                    document.addEventListener('mouseup', onWatermarkResizeEnd);
                };
            });
            
            // 四邊縮放控制點
            overlay.querySelectorAll('.watermark-edge-handle').forEach(handle => {
                handle.onmousedown = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    state.isWatermarkEdgeResizing = true;
                    state.watermarkResizeEdge = handle.dataset.edge;
                    state.watermarkResizeStart = {
                        x: state.watermarkX,
                        y: state.watermarkY,
                        w: state.watermarkWidth,
                        h: state.watermarkHeight,
                        mouseX: e.clientX,
                        mouseY: e.clientY
                    };
                    
                    document.addEventListener('mousemove', onWatermarkEdgeResizeMove);
                    document.addEventListener('mouseup', onWatermarkResizeEnd);
                };
            });
        }
        
        function onWatermarkResizeMove(e) {
            if (!state.isWatermarkResizing) return;
            
            const scale = state.watermarkPreviewScale;
            const start = state.watermarkResizeStart;
            const corner = state.watermarkResizeCorner;
            const lockRatio = document.getElementById('watermark-lock-ratio').checked;
            
            const dx = (e.clientX - start.mouseX) / scale;
            const dy = (e.clientY - start.mouseY) / scale;
            
            // 保持長寬比
            const aspectRatio = state.watermarkOriginalWidth / state.watermarkOriginalHeight;
            
            let newW, newH, newX, newY;
            
            if (corner === 'se') {
                newW = Math.max(20, start.w + dx);
                newH = lockRatio ? newW / aspectRatio : Math.max(20, start.h + dy);
                newX = start.x;
                newY = start.y;
            } else if (corner === 'sw') {
                newW = Math.max(20, start.w - dx);
                newH = lockRatio ? newW / aspectRatio : Math.max(20, start.h + dy);
                newX = start.x + (start.w - newW);
                newY = start.y;
            } else if (corner === 'ne') {
                newW = Math.max(20, start.w + dx);
                newH = lockRatio ? newW / aspectRatio : Math.max(20, start.h - dy);
                newX = start.x;
                newY = start.y + (start.h - newH);
            } else if (corner === 'nw') {
                newW = Math.max(20, start.w - dx);
                newH = lockRatio ? newW / aspectRatio : Math.max(20, start.h - dy);
                newX = start.x + (start.w - newW);
                newY = start.y + (start.h - newH);
            }
            
            // 限制範圍
            newX = Math.max(0, newX);
            newY = Math.max(0, newY);
            newW = Math.min(newW, canvas.width - newX);
            newH = Math.min(newH, canvas.height - newY);
            
            state.watermarkX = Math.round(newX);
            state.watermarkY = Math.round(newY);
            state.watermarkWidth = Math.round(newW);
            state.watermarkHeight = Math.round(newH);
            
            // 更新輸入框
            document.getElementById('watermark-width').value = state.watermarkWidth;
            document.getElementById('watermark-height').value = state.watermarkHeight;
            
            updateWatermarkPreview();
        }
        
        function onWatermarkEdgeResizeMove(e) {
            if (!state.isWatermarkEdgeResizing) return;
            
            const scale = state.watermarkPreviewScale;
            const start = state.watermarkResizeStart;
            const edge = state.watermarkResizeEdge;
            const lockRatio = document.getElementById('watermark-lock-ratio').checked;
            
            const dx = (e.clientX - start.mouseX) / scale;
            const dy = (e.clientY - start.mouseY) / scale;
            
            const aspectRatio = state.watermarkOriginalWidth / state.watermarkOriginalHeight;
            
            let newW = start.w, newH = start.h, newX = start.x, newY = start.y;
            
            switch (edge) {
                case 'e': // 右邊
                    newW = Math.max(20, start.w + dx);
                    if (lockRatio) newH = newW / aspectRatio;
                    break;
                case 'w': // 左邊
                    newW = Math.max(20, start.w - dx);
                    newX = start.x + (start.w - newW);
                    if (lockRatio) newH = newW / aspectRatio;
                    break;
                case 's': // 下邊
                    newH = Math.max(20, start.h + dy);
                    if (lockRatio) newW = newH * aspectRatio;
                    break;
                case 'n': // 上邊
                    newH = Math.max(20, start.h - dy);
                    newY = start.y + (start.h - newH);
                    if (lockRatio) newW = newH * aspectRatio;
                    break;
            }
            
            // 限制範圍
            newX = Math.max(0, newX);
            newY = Math.max(0, newY);
            newW = Math.min(newW, canvas.width - newX);
            newH = Math.min(newH, canvas.height - newY);
            
            state.watermarkX = Math.round(newX);
            state.watermarkY = Math.round(newY);
            state.watermarkWidth = Math.round(newW);
            state.watermarkHeight = Math.round(newH);
            
            // 更新輸入框
            document.getElementById('watermark-width').value = state.watermarkWidth;
            document.getElementById('watermark-height').value = state.watermarkHeight;
            
            updateWatermarkPreview();
        }
        
        function onWatermarkResizeEnd() {
            state.isWatermarkResizing = false;
            state.isWatermarkEdgeResizing = false;
            document.removeEventListener('mousemove', onWatermarkResizeMove);
            document.removeEventListener('mousemove', onWatermarkEdgeResizeMove);
            document.removeEventListener('mouseup', onWatermarkResizeEnd);
        }
        
        // 更新浮水印旋轉（滑桿）
        function updateWatermarkRotation(value) {
            state.watermarkRotation = parseInt(value) || 0;
            document.getElementById('watermark-rotation-value').textContent = state.watermarkRotation + '°';
            updateWatermarkPreview();
        }
        
        // 設置浮水印旋轉（快捷按鈕）
        function setWatermarkRotation(angle) {
            state.watermarkRotation = angle;
            document.getElementById('watermark-rotation').value = angle;
            document.getElementById('watermark-rotation-value').textContent = angle + '°';
            updateWatermarkPreview();
        }
        
        function updateWatermarkSize(prop, value) {
            value = parseInt(value) || 10;
            const lockRatio = document.getElementById('watermark-lock-ratio').checked;
            
            if (prop === 'width') {
                const oldWidth = state.watermarkWidth;
                state.watermarkWidth = Math.max(10, value);
                
                if (lockRatio && state.watermarkOriginalWidth > 0) {
                    const ratio = state.watermarkOriginalHeight / state.watermarkOriginalWidth;
                    state.watermarkHeight = Math.round(state.watermarkWidth * ratio);
                    document.getElementById('watermark-height').value = state.watermarkHeight;
                }
            } else {
                const oldHeight = state.watermarkHeight;
                state.watermarkHeight = Math.max(10, value);
                
                if (lockRatio && state.watermarkOriginalHeight > 0) {
                    const ratio = state.watermarkOriginalWidth / state.watermarkOriginalHeight;
                    state.watermarkWidth = Math.round(state.watermarkHeight * ratio);
                    document.getElementById('watermark-width').value = state.watermarkWidth;
                }
            }
            
            // 確保浮水印不超出範圍
            state.watermarkX = Math.min(state.watermarkX, canvas.width - state.watermarkWidth);
            state.watermarkY = Math.min(state.watermarkY, canvas.height - state.watermarkHeight);
            
            updateWatermarkPreview();
        }
        
        // 按比例縮放浮水印
        function scaleWatermark(scale) {
            if (!state.watermark) return;
            
            state.watermarkWidth = Math.round(state.watermarkOriginalWidth * scale);
            state.watermarkHeight = Math.round(state.watermarkOriginalHeight * scale);
            
            // 確保不超出畫布邊界
            state.watermarkX = Math.min(state.watermarkX, canvas.width - state.watermarkWidth);
            state.watermarkY = Math.min(state.watermarkY, canvas.height - state.watermarkHeight);
            state.watermarkX = Math.max(0, state.watermarkX);
            state.watermarkY = Math.max(0, state.watermarkY);
            
            // 更新輸入框
            document.getElementById('watermark-width').value = state.watermarkWidth;
            document.getElementById('watermark-height').value = state.watermarkHeight;
            
            updateWatermarkPreview();
        }
        
        function updateWatermarkOpacityPreview(value) {
            state.watermarkOpacity = parseInt(value) / 100;
            document.getElementById('watermark-opacity-value').textContent = value + '%';
            updateWatermarkPreview();
        }
        
        function positionWatermark(position) {
            const margin = 20;
            const w = state.watermarkWidth;
            const h = state.watermarkHeight;
            const cw = canvas.width;
            const ch = canvas.height;
            
            switch (position) {
                case 'top-left':
                    state.watermarkX = margin;
                    state.watermarkY = margin;
                    break;
                case 'top-center':
                    state.watermarkX = (cw - w) / 2;
                    state.watermarkY = margin;
                    break;
                case 'top-right':
                    state.watermarkX = cw - w - margin;
                    state.watermarkY = margin;
                    break;
                case 'middle-left':
                    state.watermarkX = margin;
                    state.watermarkY = (ch - h) / 2;
                    break;
                case 'center':
                    state.watermarkX = (cw - w) / 2;
                    state.watermarkY = (ch - h) / 2;
                    break;
                case 'middle-right':
                    state.watermarkX = cw - w - margin;
                    state.watermarkY = (ch - h) / 2;
                    break;
                case 'bottom-left':
                    state.watermarkX = margin;
                    state.watermarkY = ch - h - margin;
                    break;
                case 'bottom-center':
                    state.watermarkX = (cw - w) / 2;
                    state.watermarkY = ch - h - margin;
                    break;
                case 'bottom-right':
                    state.watermarkX = cw - w - margin;
                    state.watermarkY = ch - h - margin;
                    break;
            }
            
            state.watermarkX = Math.round(state.watermarkX);
            state.watermarkY = Math.round(state.watermarkY);
            
            updateWatermarkPreview();
        }
        
        // ============ 前後對照比較 ============
        
        let compareState = {
            mode: 'slider', // slider, sidebyside, toggle
            sliderPos: 50,
            isDragging: false,
            toggleShow: 'after', // before, after
            originalImage: null // 保存原始圖片
        };
        
        // ============ 快捷鍵面板 ============
        
        function openShortcutsPanel() {
            const dialog = document.createElement('div');
            dialog.id = 'shortcuts-panel';
            dialog.style.cssText = `
                position: fixed;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                background: #1a1a1a;
                border: 1px solid #444;
                border-radius: 12px;
                padding: 20px;
                z-index: 10001;
                width: 600px;
                max-height: 80vh;
                overflow-y: auto;
                box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            `;
            
            dialog.innerHTML = `
                <h3 style="margin:0 0 20px 0;display:flex;justify-content:space-between;align-items:center;">
                    <span>⌨️ 快捷鍵說明</span>
                    <button onclick="document.getElementById('shortcuts-panel').remove()" 
                        style="background:none;border:none;color:#fff;font-size:20px;cursor:pointer;">×</button>
                </h3>
                
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:20px;">
                    <!-- 基本操作 -->
                    <div>
                        <h4 style="color:#4a90d9;margin:0 0 10px 0;border-bottom:1px solid #333;padding-bottom:5px;">📋 基本操作</h4>
                        <div style="display:flex;flex-direction:column;gap:6px;">
                            ${shortcutItem('Ctrl + Z', '復原')}
                            ${shortcutItem('Ctrl + Y', '重做')}
                            ${shortcutItem('Ctrl + V', '貼上剪貼簿圖片')}
                            ${shortcutItem('Ctrl + S', '下載圖片')}
                            ${shortcutItem('Delete', '刪除選取區塊')}
                            ${shortcutItem('Escape', '取消選取/關閉對話框')}
                        </div>
                    </div>
                    
                    <!-- PDF 導航 -->
                    <div>
                        <h4 style="color:#4a90d9;margin:0 0 10px 0;border-bottom:1px solid #333;padding-bottom:5px;">📄 PDF 導航</h4>
                        <div style="display:flex;flex-direction:column;gap:6px;">
                            ${shortcutItem('PageUp', '上一頁')}
                            ${shortcutItem('PageDown', '下一頁')}
                        </div>
                    </div>
                    
                    <!-- 套索工具 -->
                    <div>
                        <h4 style="color:#4a90d9;margin:0 0 10px 0;border-bottom:1px solid #333;padding-bottom:5px;">✂️ 套索工具</h4>
                        <div style="display:flex;flex-direction:column;gap:6px;">
                            ${shortcutItem('點擊', '添加路徑點')}
                            ${shortcutItem('Enter', '閉合選取區域')}
                            ${shortcutItem('Backspace', '刪除最後一個點')}
                            ${shortcutItem('Escape', '取消套索')}
                        </div>
                    </div>
                    
                    <!-- 克隆圖章 -->
                    <div>
                        <h4 style="color:#4a90d9;margin:0 0 10px 0;border-bottom:1px solid #333;padding-bottom:5px;">🖌️ 克隆圖章</h4>
                        <div style="display:flex;flex-direction:column;gap:6px;">
                            ${shortcutItem('Alt + 點擊', '設定克隆來源點')}
                            ${shortcutItem('拖曳', '塗抹複製')}
                        </div>
                    </div>
                    
                    <!-- 橡皮擦 -->
                    <div>
                        <h4 style="color:#4a90d9;margin:0 0 10px 0;border-bottom:1px solid #333;padding-bottom:5px;">🧽 橡皮擦</h4>
                        <div style="display:flex;flex-direction:column;gap:6px;">
                            ${shortcutItem('Alt + 點擊', '取色（取色/自訂模式）')}
                        </div>
                    </div>
                    
                    <!-- 區塊操作 -->
                    <div>
                        <h4 style="color:#4a90d9;margin:0 0 10px 0;border-bottom:1px solid #333;padding-bottom:5px;">⬚ 區塊操作</h4>
                        <div style="display:flex;flex-direction:column;gap:6px;">
                            ${shortcutItem('Ctrl + 點擊', '多選區塊')}
                            ${shortcutItem('拖曳', '移動區塊')}
                            ${shortcutItem('雙擊', '編輯區塊')}
                        </div>
                    </div>
                    
                    <!-- 文字工具 -->
                    <div>
                        <h4 style="color:#4a90d9;margin:0 0 10px 0;border-bottom:1px solid #333;padding-bottom:5px;">✏️ 文字工具</h4>
                        <div style="display:flex;flex-direction:column;gap:6px;">
                            ${shortcutItem('點擊空白處', '新增文字')}
                            ${shortcutItem('拖曳文字', '移動文字')}
                            ${shortcutItem('雙擊文字', '編輯文字')}
                            ${shortcutItem('點擊 ×', '刪除文字')}
                        </div>
                    </div>
                    
                    <!-- 滑鼠操作 -->
                    <div>
                        <h4 style="color:#4a90d9;margin:0 0 10px 0;border-bottom:1px solid #333;padding-bottom:5px;">🖱️ 滑鼠操作</h4>
                        <div style="display:flex;flex-direction:column;gap:6px;">
                            ${shortcutItem('滾輪', '縮放畫布')}
                            ${shortcutItem('拖曳漸層', '調整漸層位置')}
                        </div>
                    </div>
                </div>
                
                <div style="margin-top:20px;padding:15px;background:#2a2a2a;border-radius:8px;">
                    <h4 style="color:#22c55e;margin:0 0 10px 0;">💡 小提示</h4>
                    <ul style="margin:0;padding-left:20px;color:#aaa;font-size:13px;line-height:1.8;">
                        <li>文字和漸層區塊可以隨時拖拉移動位置</li>
                        <li>點擊 ✓ 按鈕可將文字/漸層合併到圖片</li>
                        <li>自動儲存每 60 秒執行一次，關閉瀏覽器後可恢復</li>
                        <li>支援從剪貼簿直接貼上截圖 (Ctrl+V)</li>
                    </ul>
                </div>
            `;
            
            document.body.appendChild(dialog);
        }
        
        function shortcutItem(key, desc) {
            return `<div style="display:flex;justify-content:space-between;align-items:center;">
                <span style="color:#ccc;font-size:13px;">${desc}</span>
                <kbd style="background:#333;padding:3px 8px;border-radius:4px;font-size:12px;color:#fff;border:1px solid #555;">${key}</kbd>
            </div>`;
        }
        
        // ============ 圖表工具 ============
        
        function openChartTool() {
            const dialog = document.createElement('div');
            dialog.id = 'chart-tool-dialog';
            dialog.style.cssText = `
                position: fixed;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                background: #1a1a1a;
                border: 1px solid #444;
                border-radius: 12px;
                padding: 20px;
                z-index: 10001;
                width: 550px;
                max-height: 85vh;
                overflow-y: auto;
                box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            `;
            
            dialog.innerHTML = `
                <h3 style="margin:0 0 15px 0;display:flex;justify-content:space-between;align-items:center;">
                    <span>📊 圖表工具</span>
                    <button onclick="document.getElementById('chart-tool-dialog').remove()" 
                        style="background:none;border:none;color:#fff;font-size:20px;cursor:pointer;">×</button>
                </h3>
                
                <div style="margin-bottom:15px;">
                    <label style="display:block;margin-bottom:8px;font-size:12px;color:#aaa;">圖表類型</label>
                    <div style="display:grid;grid-template-columns:repeat(4, 1fr);gap:6px;">
                        <button onclick="setChartType('pie')" id="chart-type-pie" class="btn btn-primary" style="padding:8px;font-size:12px;">
                            🥧 圓餅圖
                        </button>
                        <button onclick="setChartType('bar')" id="chart-type-bar" class="btn btn-outline" style="padding:8px;font-size:12px;">
                            📊 長條圖
                        </button>
                        <button onclick="setChartType('line')" id="chart-type-line" class="btn btn-outline" style="padding:8px;font-size:12px;">
                            📈 折線圖
                        </button>
                        <button onclick="setChartType('stairs')" id="chart-type-stairs" class="btn btn-outline" style="padding:8px;font-size:12px;">
                            🪜 階梯圖
                        </button>
                        <button onclick="setChartType('petal')" id="chart-type-petal" class="btn btn-outline" style="padding:8px;font-size:12px;">
                            🌸 花瓣圖
                        </button>
                        <button onclick="setChartType('sketch')" id="chart-type-sketch" class="btn btn-outline" style="padding:8px;font-size:12px;">
                            ✏️ 手繪圖
                        </button>
                        <button onclick="setChartType('category')" id="chart-type-category" class="btn btn-outline" style="padding:8px;font-size:12px;">
                            📋 分類圖
                        </button>
                        <button onclick="setChartType('compare')" id="chart-type-compare" class="btn btn-outline" style="padding:8px;font-size:12px;">
                            ⚖️ 對比圖
                        </button>
                    </div>
                </div>
                
                <div style="margin-bottom:15px;">
                    <label style="display:block;margin-bottom:8px;font-size:12px;color:#aaa;">圖表標題</label>
                    <input type="text" id="chart-title" value="我的圖表" 
                        style="width:100%;padding:8px;background:#2a2a2a;border:1px solid #444;border-radius:6px;color:#fff;">
                </div>
                
                <div style="margin-bottom:15px;">
                    <label style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;font-size:12px;color:#aaa;">
                        <span>資料項目</span>
                        <div style="display:flex;gap:6px;">
                            <button onclick="selectTableFromImage()" class="btn btn-outline" style="padding:2px 10px;font-size:11px;" title="從圖片中選取表格區域">📷 從圖片讀取</button>
                            <button onclick="openManualTableInput()" class="btn btn-outline" style="padding:2px 10px;font-size:11px;" title="貼上表格數據">📋 貼上數據</button>
                            <button onclick="addChartDataItem()" class="btn btn-outline" style="padding:2px 10px;font-size:11px;">+ 新增</button>
                        </div>
                    </label>
                    <div id="chart-data-items" style="display:flex;flex-direction:column;gap:8px;max-height:200px;overflow-y:auto;">
                        <div class="chart-data-row" style="display:grid;grid-template-columns:2fr 1fr 40px 30px;gap:8px;align-items:center;">
                            <input type="text" value="項目 A" placeholder="名稱" class="chart-label" style="padding:6px;background:#2a2a2a;border:1px solid #444;border-radius:4px;color:#fff;">
                            <input type="number" value="30" placeholder="數值" class="chart-value" style="padding:6px;background:#2a2a2a;border:1px solid #444;border-radius:4px;color:#fff;">
                            <input type="color" value="#ff6384" class="chart-color" style="width:100%;height:30px;border:none;border-radius:4px;cursor:pointer;">
                            <button onclick="removeChartDataItem(this)" style="background:#ff4444;border:none;color:white;border-radius:4px;cursor:pointer;height:30px;">×</button>
                        </div>
                        <div class="chart-data-row" style="display:grid;grid-template-columns:2fr 1fr 40px 30px;gap:8px;align-items:center;">
                            <input type="text" value="項目 B" placeholder="名稱" class="chart-label" style="padding:6px;background:#2a2a2a;border:1px solid #444;border-radius:4px;color:#fff;">
                            <input type="number" value="25" placeholder="數值" class="chart-value" style="padding:6px;background:#2a2a2a;border:1px solid #444;border-radius:4px;color:#fff;">
                            <input type="color" value="#36a2eb" class="chart-color" style="width:100%;height:30px;border:none;border-radius:4px;cursor:pointer;">
                            <button onclick="removeChartDataItem(this)" style="background:#ff4444;border:none;color:white;border-radius:4px;cursor:pointer;height:30px;">×</button>
                        </div>
                        <div class="chart-data-row" style="display:grid;grid-template-columns:2fr 1fr 40px 30px;gap:8px;align-items:center;">
                            <input type="text" value="項目 C" placeholder="名稱" class="chart-label" style="padding:6px;background:#2a2a2a;border:1px solid #444;border-radius:4px;color:#fff;">
                            <input type="number" value="20" placeholder="數值" class="chart-value" style="padding:6px;background:#2a2a2a;border:1px solid #444;border-radius:4px;color:#fff;">
                            <input type="color" value="#ffce56" class="chart-color" style="width:100%;height:30px;border:none;border-radius:4px;cursor:pointer;">
                            <button onclick="removeChartDataItem(this)" style="background:#ff4444;border:none;color:white;border-radius:4px;cursor:pointer;height:30px;">×</button>
                        </div>
                        <div class="chart-data-row" style="display:grid;grid-template-columns:2fr 1fr 40px 30px;gap:8px;align-items:center;">
                            <input type="text" value="項目 D" placeholder="名稱" class="chart-label" style="padding:6px;background:#2a2a2a;border:1px solid #444;border-radius:4px;color:#fff;">
                            <input type="number" value="25" placeholder="數值" class="chart-value" style="padding:6px;background:#2a2a2a;border:1px solid #444;border-radius:4px;color:#fff;">
                            <input type="color" value="#4bc0c0" class="chart-color" style="width:100%;height:30px;border:none;border-radius:4px;cursor:pointer;">
                            <button onclick="removeChartDataItem(this)" style="background:#ff4444;border:none;color:white;border-radius:4px;cursor:pointer;height:30px;">×</button>
                        </div>
                    </div>
                </div>
                
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-bottom:15px;">
                    <div>
                        <label style="display:block;margin-bottom:4px;font-size:12px;color:#aaa;">圖表寬度</label>
                        <input type="number" id="chart-width" value="400" min="200" max="1000" 
                            style="width:100%;padding:8px;background:#2a2a2a;border:1px solid #444;border-radius:6px;color:#fff;">
                    </div>
                    <div>
                        <label style="display:block;margin-bottom:4px;font-size:12px;color:#aaa;">圖表高度</label>
                        <input type="number" id="chart-height" value="300" min="150" max="800" 
                            style="width:100%;padding:8px;background:#2a2a2a;border:1px solid #444;border-radius:6px;color:#fff;">
                    </div>
                </div>
                
                <div style="margin-bottom:15px;">
                    <label style="display:block;margin-bottom:8px;font-size:12px;color:#aaa;">預覽</label>
                    <div id="chart-preview" style="background:repeating-conic-gradient(#808080 0% 25%, #a0a0a0 0% 50%) 50% / 20px 20px;border-radius:8px;padding:10px;display:flex;justify-content:center;align-items:center;min-height:200px;">
                        <canvas id="chart-preview-canvas" width="380" height="200"></canvas>
                    </div>
                </div>
                
                <div style="display:flex;gap:10px;justify-content:flex-end;">
                    <button onclick="previewChart()" class="btn btn-outline">預覽更新</button>
                    <button onclick="document.getElementById('chart-tool-dialog').remove()" class="btn btn-outline">取消</button>
                    <button onclick="insertChart()" class="btn btn-primary">插入圖表</button>
                </div>
            `;
            
            document.body.appendChild(dialog);
            makeDraggable(dialog);
            
            // 初始化預覽
            setTimeout(() => previewChart(), 100);
        }
        
        let currentChartType = 'pie';
        
        // 需要子項目輸入的圖表類型
        const subItemChartTypes = ['stairs', 'petal', 'sketch', 'category', 'compare'];
        
        function setChartType(type) {
            currentChartType = type;
            document.querySelectorAll('#chart-tool-dialog button[id^="chart-type-"]').forEach(btn => {
                btn.className = 'btn btn-outline';
                btn.style.fontSize = '12px';
                btn.style.padding = '8px';
            });
            const activeBtn = document.getElementById('chart-type-' + type);
            if (activeBtn) {
                activeBtn.className = 'btn btn-primary';
                activeBtn.style.fontSize = '12px';
                activeBtn.style.padding = '8px';
            }
            
            // 更新欄位標籤和類型
            updateChartDataFieldType(type);
            previewChart();
        }
        
        function updateChartDataFieldType(type) {
            const isSubItemType = subItemChartTypes.includes(type);
            const container = document.getElementById('chart-data-items');
            if (!container) return;
            
            // 更新欄位標題
            const label = container.parentElement.querySelector('label span:first-child');
            if (label) {
                if (isSubItemType) {
                    label.textContent = '資料項目（標題 + 子項目）';
                } else {
                    label.textContent = '資料項目';
                }
            }
            
            // 更新每個資料行的欄位
            container.querySelectorAll('.chart-data-row').forEach(row => {
                const valueInput = row.querySelector('.chart-value');
                if (valueInput) {
                    if (isSubItemType) {
                        // 改為文字輸入
                        valueInput.type = 'text';
                        valueInput.placeholder = '子項目（用;分隔）';
                        if (!isNaN(valueInput.value) && valueInput.value !== '') {
                            valueInput.value = ''; // 清空數值
                        }
                        valueInput.style.minWidth = '150px';
                    } else {
                        // 改回數值輸入
                        valueInput.type = 'number';
                        valueInput.placeholder = '數值';
                        valueInput.style.minWidth = '';
                    }
                }
            });
            
            // 更新網格佈局
            container.querySelectorAll('.chart-data-row').forEach(row => {
                if (isSubItemType) {
                    row.style.gridTemplateColumns = '1fr 2fr 40px 30px';
                } else {
                    row.style.gridTemplateColumns = '2fr 1fr 40px 30px';
                }
            });
        }
        
        function addChartDataItem() {
            // 預設顏色（包含適合階梯圖的漸層色調）
            const colors = ['#5d9a8d', '#7db8a8', '#b8d4a8', '#e8d87d', '#e8b86d', '#d98a5c', '#ff6384', '#36a2eb', '#ffce56', '#4bc0c0', '#9966ff', '#ff9f40'];
            const container = document.getElementById('chart-data-items');
            const count = container.children.length;
            const color = colors[count % colors.length];
            
            const isSubItemType = subItemChartTypes.includes(currentChartType);
            
            const row = document.createElement('div');
            row.className = 'chart-data-row';
            
            if (isSubItemType) {
                row.style.cssText = 'display:grid;grid-template-columns:1fr 2fr 40px 30px;gap:8px;align-items:center;';
                row.innerHTML = `
                    <input type="text" value="項目 ${String.fromCharCode(65 + count)}" placeholder="標題" class="chart-label" style="padding:6px;background:#2a2a2a;border:1px solid #444;border-radius:4px;color:#fff;">
                    <input type="text" value="" placeholder="子項目（用;分隔）" class="chart-value" style="padding:6px;background:#2a2a2a;border:1px solid #444;border-radius:4px;color:#fff;min-width:150px;">
                    <input type="color" value="${color}" class="chart-color" style="width:100%;height:30px;border:none;border-radius:4px;cursor:pointer;">
                    <button onclick="removeChartDataItem(this)" style="background:#ff4444;border:none;color:white;border-radius:4px;cursor:pointer;height:30px;">×</button>
                `;
            } else {
                row.style.cssText = 'display:grid;grid-template-columns:2fr 1fr 40px 30px;gap:8px;align-items:center;';
                row.innerHTML = `
                    <input type="text" value="項目 ${String.fromCharCode(65 + count)}" placeholder="名稱" class="chart-label" style="padding:6px;background:#2a2a2a;border:1px solid #444;border-radius:4px;color:#fff;">
                    <input type="number" value="20" placeholder="數值" class="chart-value" style="padding:6px;background:#2a2a2a;border:1px solid #444;border-radius:4px;color:#fff;">
                    <input type="color" value="${color}" class="chart-color" style="width:100%;height:30px;border:none;border-radius:4px;cursor:pointer;">
                    <button onclick="removeChartDataItem(this)" style="background:#ff4444;border:none;color:white;border-radius:4px;cursor:pointer;height:30px;">×</button>
                `;
            }
            container.appendChild(row);
        }
        
        function removeChartDataItem(btn) {
            const container = document.getElementById('chart-data-items');
            if (container.children.length <= 1) {
                toast('至少需要一個資料項目', 'warning');
                return;
            }
            btn.closest('.chart-data-row').remove();
        }
        
        function getChartData() {
            const rows = document.querySelectorAll('.chart-data-row');
            const labels = [];
            const values = [];
            const colors = [];
            const subItems = []; // 子項目陣列
            
            const isSubItemType = subItemChartTypes.includes(currentChartType);
            
            rows.forEach(row => {
                labels.push(row.querySelector('.chart-label').value);
                const valueInput = row.querySelector('.chart-value');
                
                if (isSubItemType) {
                    // 子項目類型：值存為字串，解析為子項目陣列
                    const valueStr = valueInput.value || '';
                    values.push(valueStr); // 保留原始字串
                    subItems.push(valueStr.split(';').map(s => s.trim()).filter(s => s));
                } else {
                    // 數值類型
                    values.push(parseFloat(valueInput.value) || 0);
                    subItems.push([]);
                }
                colors.push(row.querySelector('.chart-color').value);
            });
            
            return { labels, values, colors, subItems };
        }
        
        function previewChart() {
            const previewCanvas = document.getElementById('chart-preview-canvas');
            const ctx = previewCanvas.getContext('2d');
            const { labels, values, colors, subItems } = getChartData();
            const title = document.getElementById('chart-title').value;
            
            previewCanvas.width = 380;
            previewCanvas.height = 200;
            
            // 清除畫布（透明背景）
            ctx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
            
            drawChart(ctx, previewCanvas.width, previewCanvas.height, currentChartType, title, labels, values, colors, subItems);
        }
        
        function drawChart(ctx, width, height, type, title, labels, values, colors, subItems) {
            const padding = 40;
            const titleHeight = 30;
            const legendHeight = 40;
            subItems = subItems || []; // 確保有默認值
            
            // 繪製帶描邊的文字輔助函數
            function drawTextWithOutline(text, x, y, fillColor, outlineColor) {
                ctx.strokeStyle = outlineColor || '#ffffff';
                ctx.lineWidth = 3;
                ctx.lineJoin = 'round';
                ctx.strokeText(text, x, y);
                ctx.fillStyle = fillColor;
                ctx.fillText(text, x, y);
            }
            
            // 輔助函數：調整顏色明暗
            function adjustColor(color, amount) {
                const hex = color.replace('#', '');
                const r = Math.max(0, Math.min(255, parseInt(hex.substr(0, 2), 16) + amount));
                const g = Math.max(0, Math.min(255, parseInt(hex.substr(2, 2), 16) + amount));
                const b = Math.max(0, Math.min(255, parseInt(hex.substr(4, 2), 16) + amount));
                return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
            }
            
            // 標題
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            drawTextWithOutline(title, width / 2, 25, '#333333', '#ffffff');
            
            const chartTop = titleHeight + 10;
            const chartHeight = height - chartTop - legendHeight - 10;
            const chartWidth = width - padding * 2;
            
            // 對於子項目類型，values 可能是字串
            const numericValues = values.map(v => typeof v === 'number' ? v : 0);
            const total = numericValues.reduce((a, b) => a + b, 0);
            
            if (type === 'pie') {
                // 圓餅圖
                const centerX = width / 2;
                const centerY = chartTop + chartHeight / 2;
                const radius = Math.min(chartWidth, chartHeight) / 2 - 10;
                
                let startAngle = -Math.PI / 2;
                values.forEach((value, i) => {
                    const sliceAngle = (value / total) * Math.PI * 2;
                    const endAngle = startAngle + sliceAngle;
                    
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.arc(centerX, centerY, radius, startAngle, endAngle);
                    ctx.closePath();
                    ctx.fillStyle = colors[i];
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // 百分比標籤
                    const midAngle = startAngle + sliceAngle / 2;
                    const labelRadius = radius * 0.7;
                    const labelX = centerX + Math.cos(midAngle) * labelRadius;
                    const labelY = centerY + Math.sin(midAngle) * labelRadius;
                    
                    const percent = Math.round((value / total) * 100);
                    if (percent > 5) {
                        ctx.font = 'bold 12px Arial';
                        ctx.textAlign = 'center';
                        drawTextWithOutline(percent + '%', labelX, labelY + 4, '#ffffff', '#000000');
                    }
                    
                    startAngle = endAngle;
                });
            } else if (type === 'bar') {
                // 長條圖
                const maxValue = Math.max(...values);
                const barWidth = (chartWidth - 20) / values.length - 10;
                const barAreaHeight = chartHeight - 20;
                
                // Y 軸
                ctx.strokeStyle = '#888';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(padding, chartTop);
                ctx.lineTo(padding, chartTop + chartHeight);
                ctx.lineTo(width - padding, chartTop + chartHeight);
                ctx.stroke();
                
                values.forEach((value, i) => {
                    const barHeight = (value / maxValue) * barAreaHeight;
                    const x = padding + 15 + i * (barWidth + 10);
                    const y = chartTop + chartHeight - barHeight;
                    
                    ctx.fillStyle = colors[i];
                    ctx.fillRect(x, y, barWidth, barHeight);
                    
                    // 數值標籤
                    ctx.font = '11px Arial';
                    ctx.textAlign = 'center';
                    drawTextWithOutline(value.toString(), x + barWidth / 2, y - 5, '#333333', '#ffffff');
                });
            } else if (type === 'line') {
                // 折線圖
                const maxValue = Math.max(...values);
                const pointGap = chartWidth / (values.length - 1 || 1);
                const chartAreaHeight = chartHeight - 20;
                
                // 網格
                ctx.strokeStyle = 'rgba(150, 150, 150, 0.5)';
                ctx.lineWidth = 1;
                for (let i = 0; i <= 4; i++) {
                    const y = chartTop + (chartAreaHeight / 4) * i;
                    ctx.beginPath();
                    ctx.moveTo(padding, y);
                    ctx.lineTo(width - padding, y);
                    ctx.stroke();
                }
                
                // 繪製線
                ctx.beginPath();
                ctx.strokeStyle = colors[0];
                ctx.lineWidth = 3;
                
                const points = [];
                values.forEach((value, i) => {
                    const x = padding + i * pointGap;
                    const y = chartTop + chartAreaHeight - (value / maxValue) * chartAreaHeight;
                    points.push({ x, y, value });
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                ctx.stroke();
                
                // 繪製點
                points.forEach((p, i) => {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
                    ctx.fillStyle = colors[i % colors.length];
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // 數值標籤
                    ctx.font = '11px Arial';
                    ctx.textAlign = 'center';
                    drawTextWithOutline(p.value.toString(), p.x, p.y - 10, '#333333', '#ffffff');
                });
            } else if (type === 'stairs') {
                // 階梯圖 - 3D 效果
                const stepCount = labels.length;
                const stepWidth = Math.min(80, (chartWidth - 100) / stepCount);
                const stepHeight = Math.min(35, (chartHeight - 40) / stepCount);
                const depth3D = stepWidth * 0.4; // 3D 深度
                
                // 計算起始位置（左下角）
                const startX = padding + 20;
                const startY = chartTop + chartHeight - 20;
                
                // 繪製每個階梯（從下到上）
                for (let i = 0; i < stepCount; i++) {
                    const x = startX + i * stepWidth;
                    const y = startY - (i + 1) * stepHeight;
                    const color = colors[i % colors.length];
                    
                    // 計算顏色變體（用於 3D 效果）
                    const darkerColor = adjustColor(color, -30);
                    const lighterColor = adjustColor(color, 20);
                    
                    // 繪製頂面（最亮）
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + stepWidth, y);
                    ctx.lineTo(x + stepWidth + depth3D, y - depth3D * 0.6);
                    ctx.lineTo(x + depth3D, y - depth3D * 0.6);
                    ctx.closePath();
                    ctx.fillStyle = lighterColor;
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    
                    // 繪製正面
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + stepWidth, y);
                    ctx.lineTo(x + stepWidth, y + stepHeight);
                    ctx.lineTo(x, y + stepHeight);
                    ctx.closePath();
                    ctx.fillStyle = color;
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(0,0,0,0.2)';
                    ctx.stroke();
                    
                    // 繪製右側面（較暗）
                    ctx.beginPath();
                    ctx.moveTo(x + stepWidth, y);
                    ctx.lineTo(x + stepWidth + depth3D, y - depth3D * 0.6);
                    ctx.lineTo(x + stepWidth + depth3D, y + stepHeight - depth3D * 0.6);
                    ctx.lineTo(x + stepWidth, y + stepHeight);
                    ctx.closePath();
                    ctx.fillStyle = darkerColor;
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(0,0,0,0.2)';
                    ctx.stroke();
                    
                    // 繪製標籤連接線
                    const labelX = x + stepWidth + depth3D + 15;
                    const labelY = y + stepHeight / 2 - depth3D * 0.3;
                    
                    ctx.beginPath();
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 2;
                    ctx.moveTo(x + stepWidth + depth3D, labelY);
                    ctx.lineTo(labelX - 5, labelY);
                    ctx.stroke();
                    
                    // 繪製圓點
                    ctx.beginPath();
                    ctx.arc(labelX - 5, labelY, 4, 0, Math.PI * 2);
                    ctx.fillStyle = color;
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    
                    // 繪製標籤文字
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'left';
                    drawTextWithOutline(labels[i], labelX + 5, labelY + 4, '#333333', '#ffffff');
                    
                    // 顯示子項目（如果有）
                    const items = subItems[i] || [];
                    if (items.length > 0) {
                        ctx.font = '9px Arial';
                        items.slice(0, 2).forEach((item, idx) => {
                            drawTextWithOutline(item, labelX + 5, labelY + 18 + idx * 12, '#666666', '#ffffff');
                        });
                    } else if (values[i] && typeof values[i] === 'string' && values[i]) {
                        ctx.font = '10px Arial';
                        drawTextWithOutline(values[i], labelX + 5, labelY + 18, '#666666', '#ffffff');
                    }
                }
                
                // 繪製 START 標籤
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                drawTextWithOutline('START', startX - 10, startY + 20, '#666666', '#ffffff');
                
                // 繪製起始圓點
                ctx.beginPath();
                ctx.arc(startX - 10, startY + 5, 6, 0, Math.PI * 2);
                ctx.fillStyle = '#999';
                ctx.fill();
                
                // 繪製 FINISH 標籤和箭頭
                const finishX = startX + stepCount * stepWidth + depth3D / 2;
                const finishY = startY - stepCount * stepHeight - depth3D * 0.6 - 15;
                
                // 箭頭
                ctx.beginPath();
                ctx.strokeStyle = '#c0392b';
                ctx.fillStyle = '#c0392b';
                ctx.lineWidth = 3;
                ctx.moveTo(finishX - 15, finishY + 25);
                ctx.lineTo(finishX, finishY);
                ctx.stroke();
                
                // 箭頭頭部
                ctx.beginPath();
                ctx.moveTo(finishX, finishY);
                ctx.lineTo(finishX - 8, finishY + 5);
                ctx.lineTo(finishX - 3, finishY + 10);
                ctx.closePath();
                ctx.fill();
                
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                drawTextWithOutline('FINISH', finishX + 30, finishY + 5, '#c0392b', '#ffffff');
                
                // 階梯圖不需要底部圖例
                return;
            } else if (type === 'petal') {
                // 花瓣圖 - 中心主題 + 周圍花瓣
                const centerX = width / 2;
                const centerY = height / 2;
                const petalCount = labels.length;
                const centerRadius = Math.min(width, height) * 0.12;
                const petalRadius = Math.min(width, height) * 0.28;
                const petalWidth = Math.min(width, height) * 0.18;
                
                // 繪製花瓣
                for (let i = 0; i < petalCount; i++) {
                    const angle = (i / petalCount) * Math.PI * 2 - Math.PI / 2;
                    const petalCenterX = centerX + Math.cos(angle) * petalRadius * 0.7;
                    const petalCenterY = centerY + Math.sin(angle) * petalRadius * 0.7;
                    
                    // 花瓣形狀（橢圓）
                    ctx.save();
                    ctx.translate(petalCenterX, petalCenterY);
                    ctx.rotate(angle + Math.PI / 2);
                    
                    // 繪製花瓣
                    ctx.beginPath();
                    ctx.ellipse(0, 0, petalWidth * 0.5, petalRadius * 0.5, 0, 0, Math.PI * 2);
                    ctx.fillStyle = colors[i % colors.length];
                    ctx.fill();
                    ctx.strokeStyle = adjustColor(colors[i % colors.length], -30);
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    ctx.restore();
                    
                    // 花瓣上的圖標（用圓形表示）
                    const iconX = centerX + Math.cos(angle) * petalRadius * 0.65;
                    const iconY = centerY + Math.sin(angle) * petalRadius * 0.65;
                    ctx.beginPath();
                    ctx.arc(iconX, iconY, 15, 0, Math.PI * 2);
                    ctx.fillStyle = '#ffffff';
                    ctx.fill();
                    ctx.strokeStyle = colors[i % colors.length];
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // 標籤文字（在花瓣外圍）
                    const labelX = centerX + Math.cos(angle) * (petalRadius * 1.15);
                    const labelY = centerY + Math.sin(angle) * (petalRadius * 1.15);
                    
                    ctx.font = 'bold 11px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    drawTextWithOutline(labels[i], labelX, labelY, colors[i % colors.length], '#ffffff');
                    
                    // 顯示子項目（如果有）
                    const items = subItems[i] || [];
                    if (items.length > 0) {
                        ctx.font = '9px Arial';
                        const firstItem = items[0].length > 15 ? items[0].substring(0, 15) + '...' : items[0];
                        drawTextWithOutline(firstItem, labelX, labelY + 14, '#666666', '#ffffff');
                    }
                }
                
                // 中心圓
                ctx.beginPath();
                ctx.arc(centerX, centerY, centerRadius, 0, Math.PI * 2);
                const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, centerRadius);
                gradient.addColorStop(0, '#4a6fa5');
                gradient.addColorStop(1, '#2c3e50');
                ctx.fillStyle = gradient;
                ctx.fill();
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // 中心文字
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = '#ffffff';
                ctx.fillText(title.length > 8 ? title.substring(0, 8) : title, centerX, centerY);
                
                return;
            } else if (type === 'sketch') {
                // 手繪風格對比圖
                const boxWidth = (width - padding * 3) / 2;
                const boxHeight = chartHeight - 20;
                const boxY = chartTop + 10;
                
                // 左側框（紅色系 - 錯誤/問題）
                const leftX = padding;
                ctx.strokeStyle = '#c0392b';
                ctx.lineWidth = 3;
                ctx.setLineDash([]);
                
                // 手繪風格矩形（稍微不規則）
                ctx.beginPath();
                ctx.moveTo(leftX + 3, boxY);
                ctx.lineTo(leftX + boxWidth - 2, boxY + 2);
                ctx.lineTo(leftX + boxWidth, boxY + boxHeight - 3);
                ctx.lineTo(leftX + 2, boxY + boxHeight);
                ctx.closePath();
                ctx.stroke();
                
                // 填充斜線背景
                ctx.save();
                ctx.clip();
                ctx.strokeStyle = 'rgba(192, 57, 43, 0.1)';
                ctx.lineWidth = 1;
                for (let i = -boxHeight; i < boxWidth + boxHeight; i += 8) {
                    ctx.beginPath();
                    ctx.moveTo(leftX + i, boxY);
                    ctx.lineTo(leftX + i - boxHeight, boxY + boxHeight);
                    ctx.stroke();
                }
                ctx.restore();
                
                // 左側標題
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'left';
                drawTextWithOutline(labels[0] || '問題', leftX + 10, boxY + 25, '#c0392b', '#ffffff');
                
                // X 標記
                ctx.font = 'bold 24px Arial';
                ctx.fillStyle = '#c0392b';
                ctx.fillText('✗', leftX + 10, boxY + boxHeight - 20);
                
                // 右側框（綠色系 - 正確/解決）
                const rightX = padding * 2 + boxWidth;
                ctx.strokeStyle = '#27ae60';
                ctx.lineWidth = 3;
                
                ctx.beginPath();
                ctx.moveTo(rightX + 2, boxY + 1);
                ctx.lineTo(rightX + boxWidth - 3, boxY);
                ctx.lineTo(rightX + boxWidth - 1, boxY + boxHeight - 2);
                ctx.lineTo(rightX + 1, boxY + boxHeight);
                ctx.closePath();
                ctx.stroke();
                
                // 填充斜線背景
                ctx.save();
                ctx.beginPath();
                ctx.moveTo(rightX + 2, boxY + 1);
                ctx.lineTo(rightX + boxWidth - 3, boxY);
                ctx.lineTo(rightX + boxWidth - 1, boxY + boxHeight - 2);
                ctx.lineTo(rightX + 1, boxY + boxHeight);
                ctx.closePath();
                ctx.clip();
                ctx.strokeStyle = 'rgba(39, 174, 96, 0.1)';
                ctx.lineWidth = 1;
                for (let i = -boxHeight; i < boxWidth + boxHeight; i += 8) {
                    ctx.beginPath();
                    ctx.moveTo(rightX + i, boxY);
                    ctx.lineTo(rightX + i - boxHeight, boxY + boxHeight);
                    ctx.stroke();
                }
                ctx.restore();
                
                // 右側標題
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'left';
                drawTextWithOutline(labels[1] || '解決方案', rightX + 10, boxY + 25, '#27ae60', '#ffffff');
                
                // ✓ 標記
                ctx.font = 'bold 24px Arial';
                ctx.fillStyle = '#27ae60';
                ctx.fillText('✓', rightX + 10, boxY + boxHeight - 20);
                
                // 繪製左側子項目
                ctx.font = '11px Arial';
                ctx.textAlign = 'left';
                const leftItems = subItems[0] || [];
                leftItems.slice(0, 5).forEach((item, idx) => {
                    const y = boxY + 50 + idx * 18;
                    drawTextWithOutline('• ' + item, leftX + 15, y, '#333333', '#ffffff');
                });
                
                // 繪製右側子項目
                const rightItems = subItems[1] || [];
                rightItems.slice(0, 5).forEach((item, idx) => {
                    const y = boxY + 50 + idx * 18;
                    drawTextWithOutline('• ' + item, rightX + 15, y, '#333333', '#ffffff');
                });
                
                return;
            } else if (type === 'category') {
                // 分類條列圖
                const colCount = Math.min(labels.length, 4);
                const colWidth = (width - padding * 2 - (colCount - 1) * 15) / colCount;
                const headerHeight = 50;
                const contentY = chartTop + headerHeight + 10;
                
                for (let i = 0; i < colCount && i < labels.length; i++) {
                    const x = padding + i * (colWidth + 15);
                    const color = colors[i % colors.length];
                    
                    // 標題欄
                    ctx.fillStyle = color;
                    roundRect(ctx, x, chartTop, colWidth, headerHeight, 6);
                    ctx.fill();
                    
                    // 標題文字
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillStyle = '#ffffff';
                    
                    // 分割標籤（支援用|分隔的中英文標題）
                    const parts = labels[i].split('|');
                    if (parts.length > 1) {
                        ctx.fillText(parts[0], x + colWidth / 2, chartTop + 20);
                        ctx.font = '10px Arial';
                        ctx.fillText(parts[1], x + colWidth / 2, chartTop + 38);
                    } else {
                        ctx.fillText(labels[i], x + colWidth / 2, chartTop + 30);
                    }
                    
                    // 內容區域背景
                    ctx.fillStyle = '#f8f9fa';
                    roundRect(ctx, x, contentY, colWidth, chartHeight - headerHeight - 20, 6);
                    ctx.fill();
                    ctx.strokeStyle = '#e0e0e0';
                    ctx.lineWidth = 1;
                    roundRect(ctx, x, contentY, colWidth, chartHeight - headerHeight - 20, 6);
                    ctx.stroke();
                    
                    // 內容項目（使用 subItems）
                    const items = subItems[i] || [];
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'left';
                    
                    const maxItems = Math.min(items.length || 3, 6);
                    for (let j = 0; j < maxItems; j++) {
                        const itemY = contentY + 18 + j * 22;
                        // 項目標記
                        ctx.fillStyle = color;
                        ctx.beginPath();
                        ctx.arc(x + 12, itemY, 3, 0, Math.PI * 2);
                        ctx.fill();
                        // 項目文字
                        ctx.fillStyle = '#333333';
                        const itemText = items[j] || '項目 ' + (j + 1);
                        // 截斷過長文字
                        const maxLen = Math.floor(colWidth / 7);
                        ctx.fillText(itemText.length > maxLen ? itemText.substring(0, maxLen) + '...' : itemText, x + 20, itemY + 4);
                    }
                }
                
                // 輔助函數：繪製圓角矩形
                function roundRect(ctx, x, y, w, h, r) {
                    ctx.beginPath();
                    ctx.moveTo(x + r, y);
                    ctx.lineTo(x + w - r, y);
                    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
                    ctx.lineTo(x + w, y + h - r);
                    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
                    ctx.lineTo(x + r, y + h);
                    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
                    ctx.lineTo(x, y + r);
                    ctx.quadraticCurveTo(x, y, x + r, y);
                    ctx.closePath();
                }
                
                return;
            } else if (type === 'compare') {
                // 對比圖（左右對比，帶圖標）
                const boxWidth = (width - padding * 3) / 2;
                const boxHeight = chartHeight;
                const leftX = padding;
                const rightX = padding * 2 + boxWidth;
                
                // 左側標題欄
                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(leftX, chartTop, boxWidth, 35);
                ctx.font = 'bold 13px Arial';
                ctx.textAlign = 'center';
                ctx.fillStyle = '#ffffff';
                ctx.fillText(labels[0] || '方案 A', leftX + boxWidth / 2, chartTop + 23);
                
                // 左側內容區
                ctx.fillStyle = '#fdf2f2';
                ctx.fillRect(leftX, chartTop + 35, boxWidth, boxHeight - 35);
                ctx.strokeStyle = '#e74c3c';
                ctx.lineWidth = 2;
                ctx.strokeRect(leftX, chartTop, boxWidth, boxHeight);
                
                // 右側標題欄
                ctx.fillStyle = '#27ae60';
                ctx.fillRect(rightX, chartTop, boxWidth, 35);
                ctx.font = 'bold 13px Arial';
                ctx.textAlign = 'center';
                ctx.fillStyle = '#ffffff';
                ctx.fillText(labels[1] || '方案 B', rightX + boxWidth / 2, chartTop + 23);
                
                // 右側內容區
                ctx.fillStyle = '#f2fdf5';
                ctx.fillRect(rightX, chartTop + 35, boxWidth, boxHeight - 35);
                ctx.strokeStyle = '#27ae60';
                ctx.lineWidth = 2;
                ctx.strokeRect(rightX, chartTop, boxWidth, boxHeight);
                
                // 繪製左側子項目
                ctx.font = '11px Arial';
                ctx.textAlign = 'left';
                const startY = chartTop + 55;
                const lineHeight = 20;
                
                const leftItems = subItems[0] || [];
                leftItems.slice(0, 6).forEach((item, idx) => {
                    const y = startY + idx * lineHeight;
                    // 標記符號
                    ctx.font = '12px Arial';
                    ctx.fillStyle = '#e74c3c';
                    ctx.fillText('✗', leftX + 15, y);
                    // 項目文字
                    ctx.font = '11px Arial';
                    ctx.fillStyle = '#333333';
                    ctx.fillText(item, leftX + 33, y);
                });
                
                // 繪製右側子項目
                const rightItems = subItems[1] || [];
                rightItems.slice(0, 6).forEach((item, idx) => {
                    const y = startY + idx * lineHeight;
                    // 標記符號
                    ctx.font = '12px Arial';
                    ctx.fillStyle = '#27ae60';
                    ctx.fillText('✓', rightX + 15, y);
                    // 項目文字
                    ctx.font = '11px Arial';
                    ctx.fillStyle = '#333333';
                    ctx.fillText(item, rightX + 33, y);
                });
                
                // 中間 VS 標記
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillStyle = '#666666';
                ctx.fillText('VS', width / 2, chartTop + boxHeight / 2);
                
                return;
            }
            
            // 圖例
            const legendY = height - legendHeight + 15;
            const legendItemWidth = width / labels.length;
            
            labels.forEach((label, i) => {
                const x = legendItemWidth * i + legendItemWidth / 2;
                
                ctx.fillStyle = colors[i];
                ctx.fillRect(x - 30, legendY - 8, 12, 12);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.strokeRect(x - 30, legendY - 8, 12, 12);
                
                ctx.font = '11px Arial';
                ctx.textAlign = 'left';
                drawTextWithOutline(label, x - 15, legendY + 2, '#333333', '#ffffff');
            });
        }
        
        // 從圖片選取表格區域
        function selectTableFromImage() {
            if (!state.image) {
                toast('請先載入圖片', 'error');
                return;
            }
            
            // 暫時隱藏圖表對話框
            const chartDialog = document.getElementById('chart-tool-dialog');
            if (chartDialog) {
                chartDialog.style.display = 'none';
            }
            
            toast('請在圖片上框選表格區域，按 ESC 取消', 'info');
            
            // 設置框選模式 - 使用 region 模式來正確顯示選框
            setMode('region');
            
            // 設置框選完成回調
            state.onSelectComplete = async (x, y, w, h) => {
                state.onSelectComplete = null;
                
                // 恢復模式
                setMode('select');
                
                // 顯示圖表對話框
                if (chartDialog) {
                    chartDialog.style.display = 'block';
                }
                
                // 擷取選取區域
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = w;
                tempCanvas.height = h;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(canvas, x, y, w, h, 0, 0, w, h);
                
                // OCR 識別
                await recognizeTableData(tempCanvas);
            };
            
            // 監聯取消
            const escHandler = (e) => {
                if (e.key === 'Escape') {
                    state.onSelectComplete = null;
                    setMode('select');
                    if (chartDialog) {
                        chartDialog.style.display = 'block';
                    }
                    document.removeEventListener('keydown', escHandler);
                    toast('已取消選取', 'info');
                }
            };
            document.addEventListener('keydown', escHandler);
        }
        
        // OCR 識別表格數據
        async function recognizeTableData(imageCanvas) {
            try {
                showLoading('正在識別表格...');
                
                // 載入 Tesseract
                if (!window.Tesseract) {
                    await loadTesseract();
                }
                
                const result = await Tesseract.recognize(
                    imageCanvas,
                    'chi_tra+eng',
                    {
                        logger: m => {
                            if (m.status === 'recognizing text') {
                                setProgress(Math.round(m.progress * 100));
                            }
                        }
                    }
                );
                
                hideLoading();
                
                const text = result.data.text;
                console.log('OCR 結果:', text);
                
                // 解析表格數據
                const tableData = parseTableData(text);
                
                if (tableData.length === 0) {
                    toast('未能識別到表格數據，請手動輸入', 'warning');
                    return;
                }
                
                // 填入圖表數據
                fillChartData(tableData);
                toast(`已識別 ${tableData.length} 筆數據`, 'success');
                
            } catch (e) {
                hideLoading();
                console.error('OCR 錯誤:', e);
                toast('識別失敗: ' + e.message, 'error');
            }
        }
        
        // 解析表格數據
        function parseTableData(text) {
            const lines = text.split('\n').filter(line => line.trim());
            const data = [];
            const colors = ['#5d9a8d', '#7db8a8', '#b8d4a8', '#e8d87d', '#e8b86d', '#d98a5c', '#ff6384', '#36a2eb', '#ffce56', '#4bc0c0', '#9966ff', '#ff9f40'];
            
            for (const line of lines) {
                // 嘗試多種分隔符：空格、Tab、|、:、,
                let parts = line.split(/[\t|]+/).map(s => s.trim()).filter(s => s);
                
                if (parts.length < 2) {
                    // 嘗試用多個空格分割
                    parts = line.split(/\s{2,}/).map(s => s.trim()).filter(s => s);
                }
                
                if (parts.length < 2) {
                    // 嘗試用單個空格分割，找最後一個數字
                    const match = line.match(/^(.+?)\s+([\d,.]+%?)\s*$/);
                    if (match) {
                        parts = [match[1].trim(), match[2].trim()];
                    }
                }
                
                if (parts.length >= 2) {
                    // 找出哪個是數字
                    let label = '';
                    let value = 0;
                    
                    for (let i = 0; i < parts.length; i++) {
                        const numMatch = parts[i].replace(/,/g, '').match(/^([\d.]+)%?$/);
                        if (numMatch) {
                            value = parseFloat(numMatch[1]);
                            // 其他部分作為標籤
                            label = parts.filter((_, idx) => idx !== i).join(' ');
                            break;
                        }
                    }
                    
                    // 如果沒找到數字，假設最後一個是數字
                    if (!label && parts.length >= 2) {
                        const lastPart = parts[parts.length - 1].replace(/,/g, '');
                        const numMatch = lastPart.match(/^([\d.]+)%?$/);
                        if (numMatch) {
                            value = parseFloat(numMatch[1]);
                            label = parts.slice(0, -1).join(' ');
                        }
                    }
                    
                    if (label && value > 0) {
                        data.push({
                            label: label,
                            value: value,
                            color: colors[data.length % colors.length]
                        });
                    }
                }
            }
            
            return data;
        }
        
        // 填入圖表數據
        function fillChartData(tableData) {
            const container = document.getElementById('chart-data-items');
            if (!container) return;
            
            // 清空現有數據
            container.innerHTML = '';
            
            // 添加識別到的數據
            tableData.forEach(item => {
                const row = document.createElement('div');
                row.className = 'chart-data-row';
                row.style.cssText = 'display:grid;grid-template-columns:2fr 1fr 40px 30px;gap:8px;align-items:center;';
                row.innerHTML = `
                    <input type="text" value="${item.label}" placeholder="名稱" class="chart-label" style="padding:6px;background:#2a2a2a;border:1px solid #444;border-radius:4px;color:#fff;">
                    <input type="number" value="${item.value}" placeholder="數值" class="chart-value" style="padding:6px;background:#2a2a2a;border:1px solid #444;border-radius:4px;color:#fff;">
                    <input type="color" value="${item.color}" class="chart-color" style="width:100%;height:30px;border:none;border-radius:4px;cursor:pointer;">
                    <button onclick="removeChartDataItem(this)" style="background:#ff4444;border:none;color:white;border-radius:4px;cursor:pointer;height:30px;">×</button>
                `;
                container.appendChild(row);
            });
            
            // 更新預覽
            previewChart();
        }
        
        // 手動輸入表格數據
        function openManualTableInput() {
            const dialog = document.createElement('div');
            dialog.id = 'table-input-dialog';
            dialog.style.cssText = `
                position: fixed;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                background: #1a1a1a;
                border: 1px solid #444;
                border-radius: 12px;
                padding: 20px;
                z-index: 10002;
                width: 450px;
                box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            `;
            
            dialog.innerHTML = `
                <h3 style="margin:0 0 15px 0;display:flex;justify-content:space-between;align-items:center;">
                    <span>📋 貼上表格數據</span>
                    <button onclick="document.getElementById('table-input-dialog').remove()" 
                        style="background:none;border:none;color:#fff;font-size:20px;cursor:pointer;">×</button>
                </h3>
                <div style="margin-bottom:15px;">
                    <label style="display:block;margin-bottom:8px;font-size:12px;color:#aaa;">
                        貼上表格數據（每行一筆，格式：名稱 數值）
                    </label>
                    <textarea id="table-paste-input" rows="10" placeholder="範例：
蘋果 30
香蕉 25
橘子 20
葡萄 15
西瓜 10" style="width:100%;padding:10px;background:#2a2a2a;border:1px solid #444;border-radius:6px;color:#fff;font-family:monospace;resize:vertical;"></textarea>
                </div>
                <div style="font-size:11px;color:#888;margin-bottom:15px;">
                    💡 支援的格式：
                    <ul style="margin:5px 0;padding-left:20px;">
                        <li>名稱 數值（空格分隔）</li>
                        <li>名稱	數值（Tab 分隔）</li>
                        <li>名稱|數值（豎線分隔）</li>
                        <li>名稱,數值（逗號分隔）</li>
                    </ul>
                </div>
                <div style="display:flex;gap:10px;justify-content:flex-end;">
                    <button onclick="document.getElementById('table-input-dialog').remove()" class="btn btn-outline">取消</button>
                    <button onclick="parseManualTableInput()" class="btn btn-primary">解析並填入</button>
                </div>
            `;
            
            document.body.appendChild(dialog);
            makeDraggable(dialog);
            document.getElementById('table-paste-input').focus();
        }
        
        // 解析手動輸入的表格
        function parseManualTableInput() {
            const text = document.getElementById('table-paste-input').value;
            document.getElementById('table-input-dialog').remove();
            
            const tableData = parseTableData(text);
            
            if (tableData.length === 0) {
                toast('未能解析數據，請檢查格式', 'warning');
                return;
            }
            
            fillChartData(tableData);
            toast(`已填入 ${tableData.length} 筆數據`, 'success');
        }
        
        function insertChart() {
            if (!state.image) {
                toast('請先載入圖片或新增空白頁面', 'error');
                return;
            }
            
            const chartWidth = parseInt(document.getElementById('chart-width').value);
            const chartHeight = parseInt(document.getElementById('chart-height').value);
            const title = document.getElementById('chart-title').value;
            const { labels, values, colors, subItems } = getChartData();
            
            document.getElementById('chart-tool-dialog').remove();
            
            // 創建圖表 canvas（透明背景）
            const chartCanvas = document.createElement('canvas');
            chartCanvas.width = chartWidth;
            chartCanvas.height = chartHeight;
            const chartCtx = chartCanvas.getContext('2d');
            
            // 透明背景，不填充白色
            // chartCtx.fillStyle = '#ffffff';
            // chartCtx.fillRect(0, 0, chartWidth, chartHeight);
            
            drawChart(chartCtx, chartWidth, chartHeight, currentChartType, title, labels, values, colors, subItems);
            
            // 添加為圖像區塊
            const centerX = canvas.width / 2 - chartWidth / 2;
            const centerY = canvas.height / 2 - chartHeight / 2;
            
            const imageRegion = {
                id: Date.now(),
                type: 'chart', // 標記為圖表類型
                isChart: true,
                chartType: currentChartType,
                chartTitle: title,
                chartLabels: labels.slice(),
                chartValues: values.slice(),
                chartColors: colors.slice(),
                chartSubItems: subItems.map(arr => arr.slice()), // 保存子項目
                x: Math.max(0, centerX),
                y: Math.max(0, centerY),
                w: chartWidth,
                h: chartHeight,
                originalW: chartWidth,
                originalH: chartHeight,
                originalX: Math.max(0, centerX),
                originalY: Math.max(0, centerY),
                imageData: chartCanvas.toDataURL('image/png'),
                originalImageData: chartCanvas.toDataURL('image/png'),
                bgColor: 'transparent',
                transparentBg: true,
                isFloating: true,
                rotation: 0,
                scale: 1,
                layerIndex: activeLayerIndex // 記錄所屬圖層
            };
            
            state.imageRegions = state.imageRegions || [];
            state.imageRegions.push(imageRegion);
            state.activeImageRegion = imageRegion;
            renderImageRegions();
            
            toast('圖表已插入，雙擊可編輯資料', 'success');
        }
        
        // 編輯現有圖表
        function editChartObject(region) {
            const dialog = document.createElement('div');
            dialog.id = 'chart-tool-dialog';
            dialog.style.cssText = `
                position: fixed;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                background: #1a1a1a;
                border: 1px solid #444;
                border-radius: 12px;
                padding: 20px;
                z-index: 10001;
                width: 550px;
                max-height: 85vh;
                overflow-y: auto;
                box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            `;
            
            // 判斷是否為子項目類型
            const isSubItemType = subItemChartTypes.includes(region.chartType);
            const chartSubItems = region.chartSubItems || [];
            
            // 生成資料行 HTML
            let dataRowsHtml = '';
            region.chartLabels.forEach((label, i) => {
                const value = region.chartValues[i];
                const subItemStr = chartSubItems[i] ? chartSubItems[i].join(';') : (typeof value === 'string' ? value : '');
                
                if (isSubItemType) {
                    dataRowsHtml += `
                        <div class="chart-data-row" style="display:grid;grid-template-columns:1fr 2fr 40px 30px;gap:8px;align-items:center;">
                            <input type="text" value="${label}" placeholder="標題" class="chart-label" style="padding:6px;background:#2a2a2a;border:1px solid #444;border-radius:4px;color:#fff;">
                            <input type="text" value="${subItemStr}" placeholder="子項目（用;分隔）" class="chart-value" style="padding:6px;background:#2a2a2a;border:1px solid #444;border-radius:4px;color:#fff;min-width:150px;">
                            <input type="color" value="${region.chartColors[i]}" class="chart-color" style="width:100%;height:30px;border:none;border-radius:4px;cursor:pointer;">
                            <button onclick="removeChartDataItem(this)" style="background:#ff4444;border:none;color:white;border-radius:4px;cursor:pointer;height:30px;">×</button>
                        </div>
                    `;
                } else {
                    dataRowsHtml += `
                        <div class="chart-data-row" style="display:grid;grid-template-columns:2fr 1fr 40px 30px;gap:8px;align-items:center;">
                            <input type="text" value="${label}" placeholder="名稱" class="chart-label" style="padding:6px;background:#2a2a2a;border:1px solid #444;border-radius:4px;color:#fff;">
                            <input type="number" value="${typeof value === 'number' ? value : 0}" placeholder="數值" class="chart-value" style="padding:6px;background:#2a2a2a;border:1px solid #444;border-radius:4px;color:#fff;">
                            <input type="color" value="${region.chartColors[i]}" class="chart-color" style="width:100%;height:30px;border:none;border-radius:4px;cursor:pointer;">
                            <button onclick="removeChartDataItem(this)" style="background:#ff4444;border:none;color:white;border-radius:4px;cursor:pointer;height:30px;">×</button>
                        </div>
                    `;
                }
            });
            
            // 設置當前圖表類型
            currentChartType = region.chartType;
            
            dialog.innerHTML = `
                <h3 style="margin:0 0 15px 0;display:flex;justify-content:space-between;align-items:center;">
                    <span>📊 編輯圖表</span>
                    <button onclick="document.getElementById('chart-tool-dialog').remove()" 
                        style="background:none;border:none;color:#fff;font-size:20px;cursor:pointer;">×</button>
                </h3>
                
                <div style="margin-bottom:15px;">
                    <label style="display:block;margin-bottom:8px;font-size:12px;color:#aaa;">圖表類型</label>
                    <div style="display:grid;grid-template-columns:repeat(4, 1fr);gap:6px;">
                        <button onclick="setChartType('pie')" id="chart-type-pie" class="btn ${region.chartType === 'pie' ? 'btn-primary' : 'btn-outline'}" style="padding:8px;font-size:12px;">
                            🥧 圓餅圖
                        </button>
                        <button onclick="setChartType('bar')" id="chart-type-bar" class="btn ${region.chartType === 'bar' ? 'btn-primary' : 'btn-outline'}" style="padding:8px;font-size:12px;">
                            📊 長條圖
                        </button>
                        <button onclick="setChartType('line')" id="chart-type-line" class="btn ${region.chartType === 'line' ? 'btn-primary' : 'btn-outline'}" style="padding:8px;font-size:12px;">
                            📈 折線圖
                        </button>
                        <button onclick="setChartType('stairs')" id="chart-type-stairs" class="btn ${region.chartType === 'stairs' ? 'btn-primary' : 'btn-outline'}" style="padding:8px;font-size:12px;">
                            🪜 階梯圖
                        </button>
                        <button onclick="setChartType('petal')" id="chart-type-petal" class="btn ${region.chartType === 'petal' ? 'btn-primary' : 'btn-outline'}" style="padding:8px;font-size:12px;">
                            🌸 花瓣圖
                        </button>
                        <button onclick="setChartType('sketch')" id="chart-type-sketch" class="btn ${region.chartType === 'sketch' ? 'btn-primary' : 'btn-outline'}" style="padding:8px;font-size:12px;">
                            ✏️ 手繪圖
                        </button>
                        <button onclick="setChartType('category')" id="chart-type-category" class="btn ${region.chartType === 'category' ? 'btn-primary' : 'btn-outline'}" style="padding:8px;font-size:12px;">
                            📋 分類圖
                        </button>
                        <button onclick="setChartType('compare')" id="chart-type-compare" class="btn ${region.chartType === 'compare' ? 'btn-primary' : 'btn-outline'}" style="padding:8px;font-size:12px;">
                            ⚖️ 對比圖
                        </button>
                    </div>
                </div>
                
                <div style="margin-bottom:15px;">
                    <label style="display:block;margin-bottom:8px;font-size:12px;color:#aaa;">圖表標題</label>
                    <input type="text" id="chart-title" value="${region.chartTitle}" 
                        style="width:100%;padding:8px;background:#2a2a2a;border:1px solid #444;border-radius:6px;color:#fff;">
                </div>
                
                <div style="margin-bottom:15px;">
                    <label style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;font-size:12px;color:#aaa;">
                        <span>${isSubItemType ? '資料項目（標題 + 子項目）' : '資料項目'}</span>
                        <div style="display:flex;gap:6px;">
                            <button onclick="selectTableFromImage()" class="btn btn-outline" style="padding:2px 10px;font-size:11px;" title="從圖片中選取表格區域">📷 從圖片讀取</button>
                            <button onclick="openManualTableInput()" class="btn btn-outline" style="padding:2px 10px;font-size:11px;" title="貼上表格數據">📋 貼上數據</button>
                            <button onclick="addChartDataItem()" class="btn btn-outline" style="padding:2px 10px;font-size:11px;">+ 新增</button>
                        </div>
                    </label>
                    <div id="chart-data-items" style="display:flex;flex-direction:column;gap:8px;max-height:200px;overflow-y:auto;">
                        ${dataRowsHtml}
                    </div>
                </div>
                
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-bottom:15px;">
                    <div>
                        <label style="display:block;margin-bottom:4px;font-size:12px;color:#aaa;">圖表寬度</label>
                        <input type="number" id="chart-width" value="${region.w}" min="200" max="1000" 
                            style="width:100%;padding:8px;background:#2a2a2a;border:1px solid #444;border-radius:6px;color:#fff;">
                    </div>
                    <div>
                        <label style="display:block;margin-bottom:4px;font-size:12px;color:#aaa;">圖表高度</label>
                        <input type="number" id="chart-height" value="${region.h}" min="150" max="800" 
                            style="width:100%;padding:8px;background:#2a2a2a;border:1px solid #444;border-radius:6px;color:#fff;">
                    </div>
                </div>
                
                <div style="margin-bottom:15px;">
                    <label style="display:block;margin-bottom:8px;font-size:12px;color:#aaa;">預覽</label>
                    <div id="chart-preview" style="background:repeating-conic-gradient(#808080 0% 25%, #a0a0a0 0% 50%) 50% / 20px 20px;border-radius:8px;padding:10px;display:flex;justify-content:center;align-items:center;min-height:200px;">
                        <canvas id="chart-preview-canvas" width="380" height="200"></canvas>
                    </div>
                </div>
                
                <div style="display:flex;gap:10px;justify-content:flex-end;">
                    <button onclick="previewChart()" class="btn btn-outline">預覽更新</button>
                    <button onclick="document.getElementById('chart-tool-dialog').remove()" class="btn btn-outline">取消</button>
                    <button onclick="updateChartObject(${region.id})" class="btn btn-primary">更新圖表</button>
                </div>
            `;
            
            document.body.appendChild(dialog);
            makeDraggable(dialog);
            currentChartType = region.chartType;
            
            // 初始化預覽
            setTimeout(() => previewChart(), 100);
        }
        
        // 更新圖表物件
        function updateChartObject(regionId) {
            const region = state.imageRegions.find(r => r.id === regionId);
            if (!region) return;
            
            const chartWidth = parseInt(document.getElementById('chart-width').value);
            const chartHeight = parseInt(document.getElementById('chart-height').value);
            const title = document.getElementById('chart-title').value;
            const { labels, values, colors, subItems } = getChartData();
            
            document.getElementById('chart-tool-dialog').remove();
            
            // 重新繪製圖表
            const chartCanvas = document.createElement('canvas');
            chartCanvas.width = chartWidth;
            chartCanvas.height = chartHeight;
            const chartCtx = chartCanvas.getContext('2d');
            
            drawChart(chartCtx, chartWidth, chartHeight, currentChartType, title, labels, values, colors, subItems);
            
            // 更新區塊資料
            region.chartType = currentChartType;
            region.chartTitle = title;
            region.chartLabels = labels.slice();
            region.chartValues = values.slice();
            region.chartColors = colors.slice();
            region.chartSubItems = subItems.map(arr => arr.slice());
            region.w = chartWidth;
            region.h = chartHeight;
            region.imageData = chartCanvas.toDataURL('image/png');
            
            renderImageRegions();
            toast('圖表已更新', 'success');
        }
        
        function openCompareDialog() {
            if (!state.image) {
                toast('請先載入圖片', 'error');
                return;
            }
            
            // 檢查是否有原始圖片
            if (!state.originalImageData) {
                toast('沒有原始圖片可比較', 'error');
                return;
            }
            
            // 獲取原始圖片
            const originalSrc = state.originalImageData;
            // 獲取當前圖片
            const currentSrc = canvas.toDataURL();
            
            // 檢查是否有差異
            if (originalSrc === currentSrc) {
                toast('圖片尚未編輯，無差異可比較', 'info');
                return;
            }
            
            // 設置圖片
            document.getElementById('compare-before').src = originalSrc;
            document.getElementById('compare-after').src = currentSrc;
            
            // 重置狀態
            compareState.sliderPos = 50;
            compareState.mode = 'slider';
            setCompareMode('slider');
            
            // 顯示對話框
            document.getElementById('compare-dialog').classList.add('show');
            
            // 設置滑桿事件
            setupCompareSlider();
        }
        
        function closeCompareDialog() {
            document.getElementById('compare-dialog').classList.remove('show');
            // 移除事件
            const container = document.getElementById('compare-container');
            container.onmousedown = null;
            document.onmousemove = null;
            document.onmouseup = null;
        }
        
        function setupCompareSlider() {
            const wrapper = document.getElementById('compare-wrapper');
            const slider = document.getElementById('compare-slider');
            const beforeImg = document.getElementById('compare-before');
            
            function updateSliderPosition(x) {
                const rect = wrapper.getBoundingClientRect();
                let pos = ((x - rect.left) / rect.width) * 100;
                pos = Math.max(0, Math.min(100, pos));
                compareState.sliderPos = pos;
                
                slider.style.left = pos + '%';
                beforeImg.style.clipPath = `inset(0 ${100 - pos}% 0 0)`;
            }
            
            wrapper.onmousedown = (e) => {
                if (compareState.mode !== 'slider') return;
                compareState.isDragging = true;
                updateSliderPosition(e.clientX);
            };
            
            document.onmousemove = (e) => {
                if (!compareState.isDragging) return;
                updateSliderPosition(e.clientX);
            };
            
            document.onmouseup = () => {
                compareState.isDragging = false;
            };
            
            // 觸控支援
            wrapper.ontouchstart = (e) => {
                if (compareState.mode !== 'slider') return;
                compareState.isDragging = true;
                updateSliderPosition(e.touches[0].clientX);
            };
            
            wrapper.ontouchmove = (e) => {
                if (!compareState.isDragging) return;
                updateSliderPosition(e.touches[0].clientX);
            };
            
            wrapper.ontouchend = () => {
                compareState.isDragging = false;
            };
            
            // 初始位置
            setTimeout(() => {
                const rect = wrapper.getBoundingClientRect();
                updateSliderPosition(rect.left + rect.width / 2);
            }, 100);
        }
        
        function setCompareMode(mode) {
            compareState.mode = mode;
            
            // 更新按鈕狀態
            document.querySelectorAll('.compare-mode-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById('mode-' + mode).classList.add('active');
            
            const container = document.getElementById('compare-container');
            const wrapper = document.getElementById('compare-wrapper');
            const slider = document.getElementById('compare-slider');
            const beforeImg = document.getElementById('compare-before');
            const afterImg = document.getElementById('compare-after');
            const labels = document.getElementById('compare-labels');
            const infoText = document.getElementById('compare-info-text');
            
            // 移除點擊事件
            wrapper.onclick = null;
            
            // 重置樣式
            wrapper.classList.remove('sidebyside');
            wrapper.style.cursor = 'ew-resize';
            beforeImg.style.position = 'absolute';
            beforeImg.style.opacity = '1';
            beforeImg.style.maxWidth = '';
            beforeImg.style.width = '100%';
            beforeImg.style.height = '100%';
            afterImg.style.opacity = '1';
            afterImg.style.maxWidth = '';
            slider.style.display = 'block';
            labels.style.display = 'flex';
            
            switch (mode) {
                case 'slider':
                    slider.style.display = 'block';
                    slider.style.left = compareState.sliderPos + '%';
                    beforeImg.style.clipPath = `inset(0 ${100 - compareState.sliderPos}% 0 0)`;
                    infoText.textContent = '拖動滑桿比較差異';
                    break;
                    
                case 'sidebyside':
                    slider.style.display = 'none';
                    wrapper.classList.add('sidebyside');
                    wrapper.style.cursor = 'default';
                    beforeImg.style.position = 'relative';
                    beforeImg.style.width = 'auto';
                    beforeImg.style.height = 'auto';
                    beforeImg.style.clipPath = 'none';
                    labels.style.display = 'none';
                    infoText.textContent = '左：編輯前 | 右：編輯後';
                    break;
                    
                case 'toggle':
                    slider.style.display = 'none';
                    labels.style.display = 'flex';
                    compareState.toggleShow = 'after';
                    beforeImg.style.opacity = '0';
                    afterImg.style.opacity = '1';
                    beforeImg.style.clipPath = 'none';
                    wrapper.style.cursor = 'pointer';
                    infoText.textContent = '點擊切換顯示（目前：編輯後）';
                    
                    // 點擊切換
                    wrapper.onclick = () => {
                        if (compareState.mode !== 'toggle') return;
                        if (compareState.toggleShow === 'after') {
                            compareState.toggleShow = 'before';
                            beforeImg.style.opacity = '1';
                            afterImg.style.opacity = '0';
                            infoText.textContent = '點擊切換顯示（目前：編輯前）';
                        } else {
                            compareState.toggleShow = 'after';
                            beforeImg.style.opacity = '0';
                            afterImg.style.opacity = '1';
                            infoText.textContent = '點擊切換顯示（目前：編輯後）';
                        }
                    };
                    break;
            }
        }

        // ============ 濾鏡功能 ============
        
        function openFilterDialog() {
            if (!state.image) {
                toast('請先載入圖片', 'error');
                return;
            }
            
            // 保存原始圖像數據
            state.filterOriginalData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            
            // 重置濾鏡值
            document.getElementById('filter-brightness').value = 0;
            document.getElementById('filter-contrast').value = 0;
            document.getElementById('filter-saturation').value = 0;
            document.getElementById('filter-hue').value = 0;
            document.getElementById('filter-blur-amount').value = 0;
            document.getElementById('filter-sharpen').value = 0;
            
            updateFilterPreview();
            document.getElementById('filter-dialog').classList.add('show');
        }
        
        function closeFilterDialog() {
            document.getElementById('filter-dialog').classList.remove('show');
            // 恢復原始圖像
            if (state.filterOriginalData) {
                ctx.putImageData(state.filterOriginalData, 0, 0);
            }
        }
        
        function updateFilterPreview() {
            const brightness = parseInt(document.getElementById('filter-brightness').value);
            const contrast = parseInt(document.getElementById('filter-contrast').value);
            const saturation = parseInt(document.getElementById('filter-saturation').value);
            const hue = parseInt(document.getElementById('filter-hue').value);
            const blur = parseInt(document.getElementById('filter-blur-amount').value);
            const sharpen = parseInt(document.getElementById('filter-sharpen').value);
            
            // 更新顯示值
            document.getElementById('filter-brightness-val').textContent = brightness;
            document.getElementById('filter-contrast-val').textContent = contrast;
            document.getElementById('filter-saturation-val').textContent = saturation;
            document.getElementById('filter-hue-val').textContent = hue + '°';
            document.getElementById('filter-blur-val').textContent = blur;
            document.getElementById('filter-sharpen-val').textContent = sharpen;
            
            // 創建預覽
            const previewCanvas = document.getElementById('filter-preview-canvas');
            const previewCtx = previewCanvas.getContext('2d');
            
            // 計算預覽尺寸
            const maxW = 600;
            const maxH = 250;
            const scale = Math.min(maxW / canvas.width, maxH / canvas.height, 1);
            previewCanvas.width = canvas.width * scale;
            previewCanvas.height = canvas.height * scale;
            
            // 繪製原始圖像
            previewCtx.drawImage(canvas, 0, 0, previewCanvas.width, previewCanvas.height);
            
            // 應用 CSS 濾鏡
            previewCtx.filter = `
                brightness(${100 + brightness}%)
                contrast(${100 + contrast}%)
                saturate(${100 + saturation}%)
                hue-rotate(${hue}deg)
                blur(${blur}px)
            `;
            
            previewCtx.drawImage(previewCanvas, 0, 0);
            previewCtx.filter = 'none';
        }
        
        function resetFilters() {
            document.getElementById('filter-brightness').value = 0;
            document.getElementById('filter-contrast').value = 0;
            document.getElementById('filter-saturation').value = 0;
            document.getElementById('filter-hue').value = 0;
            document.getElementById('filter-blur-amount').value = 0;
            document.getElementById('filter-sharpen').value = 0;
            updateFilterPreview();
        }
        
        function applyFilterPreset(preset) {
            resetFilters();
            switch (preset) {
                case 'warm':
                    document.getElementById('filter-saturation').value = 20;
                    document.getElementById('filter-hue').value = -10;
                    break;
                case 'cool':
                    document.getElementById('filter-saturation').value = 10;
                    document.getElementById('filter-hue').value = 20;
                    break;
                case 'vintage':
                    document.getElementById('filter-contrast').value = 10;
                    document.getElementById('filter-saturation').value = -30;
                    document.getElementById('filter-brightness').value = 10;
                    break;
                case 'grayscale':
                    document.getElementById('filter-saturation').value = -100;
                    break;
                case 'sepia':
                    document.getElementById('filter-saturation').value = -50;
                    document.getElementById('filter-hue').value = 30;
                    document.getElementById('filter-brightness').value = 10;
                    break;
            }
            updateFilterPreview();
        }
        
        function applyFilters() {
            const brightness = parseInt(document.getElementById('filter-brightness').value);
            const contrast = parseInt(document.getElementById('filter-contrast').value);
            const saturation = parseInt(document.getElementById('filter-saturation').value);
            const hue = parseInt(document.getElementById('filter-hue').value);
            const blur = parseInt(document.getElementById('filter-blur-amount').value);
            
            saveHistory('套用濾鏡');
            
            // 應用濾鏡到主 canvas
            ctx.filter = `
                brightness(${100 + brightness}%)
                contrast(${100 + contrast}%)
                saturate(${100 + saturation}%)
                hue-rotate(${hue}deg)
                blur(${blur}px)
            `;
            
            ctx.drawImage(canvas, 0, 0);
            ctx.filter = 'none';
            
            // 更新 state.image
            const newImg = new Image();
            newImg.src = canvas.toDataURL();
            state.image = newImg;
            
            document.getElementById('filter-dialog').classList.remove('show');
            toast('已套用濾鏡', 'success');
        }
        
        // ============ 裁切工具 ============
        
        function initCrop() {
            if (!state.image) return;
            
            state.cropMode = true;
            
            const overlay = document.getElementById('crop-overlay');
            const toolbar = document.getElementById('crop-toolbar');
            const mask = document.getElementById('crop-mask');
            const box = document.getElementById('crop-box');
            
            // 初始裁切框（中央 80%）
            const margin = 0.1;
            state.cropBox = {
                x: canvas.width * margin,
                y: canvas.height * margin,
                w: canvas.width * (1 - margin * 2),
                h: canvas.height * (1 - margin * 2)
            };
            
            updateCropBox();
            overlay.classList.remove('hidden');
            toolbar.classList.remove('hidden');
            
            // 設置事件（綁定到 mask，因為 box 現在是 mask 的子元素）
            mask.onmousedown = startCropDrag;
            document.querySelectorAll('.crop-handle').forEach(handle => {
                handle.onmousedown = (e) => startCropResize(e, handle.dataset.handle);
            });
        }
        
        function updateCropBox() {
            const mask = document.getElementById('crop-mask');
            const container = document.getElementById('canvas-container');
            const containerRect = container.getBoundingClientRect();
            const wrapperRect = canvasWrapper.getBoundingClientRect();
            const scale = state.displayScale;
            
            // 計算 container 相對於 wrapper 的位置
            const offsetX = containerRect.left - wrapperRect.left + canvasWrapper.scrollLeft;
            const offsetY = containerRect.top - wrapperRect.top + canvasWrapper.scrollTop;
            
            // 設定 mask 的位置和大小（對應裁切框在螢幕上的實際位置）
            mask.style.left = (offsetX + state.cropBox.x * scale) + 'px';
            mask.style.top = (offsetY + state.cropBox.y * scale) + 'px';
            mask.style.width = (state.cropBox.w * scale) + 'px';
            mask.style.height = (state.cropBox.h * scale) + 'px';
        }
        
        function startCropDrag(e) {
            if (e.target.classList.contains('crop-handle')) return;
            e.preventDefault();
            
            state.cropDragging = true;
            const container = document.getElementById('canvas-container');
            const rect = container.getBoundingClientRect();
            const scale = state.displayScale;
            
            // 計算滑鼠在 canvas 座標系中的位置
            const mouseX = (e.clientX - rect.left) / scale;
            const mouseY = (e.clientY - rect.top) / scale;
            
            state.cropDragStart = {
                x: mouseX - state.cropBox.x,
                y: mouseY - state.cropBox.y
            };
            
            document.addEventListener('mousemove', onCropDrag);
            document.addEventListener('mouseup', endCropDrag);
        }
        
        function onCropDrag(e) {
            if (!state.cropDragging) return;
            
            const container = document.getElementById('canvas-container');
            const rect = container.getBoundingClientRect();
            const scale = state.displayScale;
            
            // 計算滑鼠在 canvas 座標系中的位置
            const mouseX = (e.clientX - rect.left) / scale;
            const mouseY = (e.clientY - rect.top) / scale;
            
            let newX = mouseX - state.cropDragStart.x;
            let newY = mouseY - state.cropDragStart.y;
            
            // 邊界限制
            newX = Math.max(0, Math.min(canvas.width - state.cropBox.w, newX));
            newY = Math.max(0, Math.min(canvas.height - state.cropBox.h, newY));
            
            state.cropBox.x = newX;
            state.cropBox.y = newY;
            updateCropBox();
        }
        
        function endCropDrag() {
            state.cropDragging = false;
            document.removeEventListener('mousemove', onCropDrag);
            document.removeEventListener('mouseup', endCropDrag);
        }
        
        function startCropResize(e, handle) {
            e.preventDefault();
            e.stopPropagation();
            
            state.cropResizing = true;
            state.cropHandle = handle;
            state.cropResizeStart = {
                x: e.clientX,
                y: e.clientY,
                box: { ...state.cropBox }
            };
            
            document.addEventListener('mousemove', onCropResize);
            document.addEventListener('mouseup', endCropResize);
        }
        
        function onCropResize(e) {
            if (!state.cropResizing) return;
            
            const scale = state.displayScale;
            const dx = (e.clientX - state.cropResizeStart.x) / scale;
            const dy = (e.clientY - state.cropResizeStart.y) / scale;
            const start = state.cropResizeStart.box;
            const handle = state.cropHandle;
            
            let newBox = { ...state.cropBox };
            
            // 根據拖動的控制點調整
            if (handle.includes('w')) {
                newBox.x = Math.max(0, Math.min(start.x + start.w - 20, start.x + dx));
                newBox.w = start.w - (newBox.x - start.x);
            }
            if (handle.includes('e')) {
                newBox.w = Math.max(20, Math.min(canvas.width - start.x, start.w + dx));
            }
            if (handle.includes('n')) {
                newBox.y = Math.max(0, Math.min(start.y + start.h - 20, start.y + dy));
                newBox.h = start.h - (newBox.y - start.y);
            }
            if (handle.includes('s')) {
                newBox.h = Math.max(20, Math.min(canvas.height - start.y, start.h + dy));
            }
            
            // 如果有固定比例
            if (state.cropRatio !== 'free') {
                const [rw, rh] = state.cropRatio.split(':').map(Number);
                const ratio = rw / rh;
                
                if (handle.includes('e') || handle.includes('w')) {
                    newBox.h = newBox.w / ratio;
                } else {
                    newBox.w = newBox.h * ratio;
                }
            }
            
            state.cropBox = newBox;
            updateCropBox();
        }
        
        function endCropResize() {
            state.cropResizing = false;
            document.removeEventListener('mousemove', onCropResize);
            document.removeEventListener('mouseup', endCropResize);
        }
        
        function setCropRatio(ratio) {
            state.cropRatio = ratio;
            
            if (ratio !== 'free') {
                const [rw, rh] = ratio.split(':').map(Number);
                const targetRatio = rw / rh;
                const currentRatio = state.cropBox.w / state.cropBox.h;
                
                if (currentRatio > targetRatio) {
                    state.cropBox.w = state.cropBox.h * targetRatio;
                } else {
                    state.cropBox.h = state.cropBox.w / targetRatio;
                }
                
                updateCropBox();
            }
        }
        
        function applyCrop() {
            saveHistory('裁切圖片');
            
            const { x, y, w, h } = state.cropBox;
            const imageData = ctx.getImageData(x, y, w, h);
            
            canvas.width = w;
            canvas.height = h;
            ctx.putImageData(imageData, 0, 0);
            
            // 更新 state.image
            const newImg = new Image();
            newImg.src = canvas.toDataURL();
            state.image = newImg;
            
            // 清除所有區域（位置已經變了）
            state.regions = [];
            renderRegions();
            
            cancelCrop();
            zoomFit();
            toast('已裁切圖片', 'success');
        }
        
        function cancelCrop() {
            state.cropMode = false;
            document.getElementById('crop-overlay').classList.add('hidden');
            document.getElementById('crop-toolbar').classList.add('hidden');
            setMode('select');
        }
        
        // ============ 箭頭標註 ============
        
        function drawArrow(x1, y1, x2, y2, color, width, style) {
            const headLen = width * 5;
            const angle = Math.atan2(y2 - y1, x2 - x1);
            
            ctx.save();
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = width;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            if (style === 'dashed') {
                ctx.setLineDash([width * 2, width * 2]);
            }
            
            // 畫線
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
            
            // 畫箭頭
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 - headLen * Math.cos(angle - Math.PI / 6), y2 - headLen * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(x2 - headLen * Math.cos(angle + Math.PI / 6), y2 - headLen * Math.sin(angle + Math.PI / 6));
            ctx.closePath();
            ctx.fill();
            
            ctx.restore();
        }
        
        // ============ 標記符號 ============
        
        function drawMarker(x, y, type, color, size, filled, number) {
            ctx.save();
            ctx.strokeStyle = color;
            ctx.fillStyle = filled ? color : 'transparent';
            ctx.lineWidth = 3;
            ctx.font = `bold ${size * 0.6}px Inter, sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            const half = size / 2;
            
            switch (type) {
                case 'circle':
                    ctx.beginPath();
                    ctx.arc(x, y, half, 0, Math.PI * 2);
                    if (filled) ctx.fill();
                    ctx.stroke();
                    break;
                    
                case 'rect':
                    ctx.beginPath();
                    ctx.rect(x - half, y - half, size, size);
                    if (filled) ctx.fill();
                    ctx.stroke();
                    break;
                    
                case 'check':
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(x - half * 0.5, y);
                    ctx.lineTo(x - half * 0.1, y + half * 0.4);
                    ctx.lineTo(x + half * 0.5, y - half * 0.4);
                    ctx.stroke();
                    break;
                    
                case 'cross':
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(x - half * 0.4, y - half * 0.4);
                    ctx.lineTo(x + half * 0.4, y + half * 0.4);
                    ctx.moveTo(x + half * 0.4, y - half * 0.4);
                    ctx.lineTo(x - half * 0.4, y + half * 0.4);
                    ctx.stroke();
                    break;
                    
                case 'number':
                    ctx.beginPath();
                    ctx.arc(x, y, half, 0, Math.PI * 2);
                    ctx.fillStyle = color;
                    ctx.fill();
                    ctx.fillStyle = '#fff';
                    ctx.fillText(number.toString(), x, y);
                    break;
            }
            
            ctx.restore();
        }
        
        // ============ 搜尋取代 ============
        
        function openSearchReplace() {
            if (state.regions.length === 0) {
                toast('沒有文字區域可搜尋', 'error');
                return;
            }
            
            document.getElementById('search-text').value = '';
            document.getElementById('replace-text').value = '';
            document.getElementById('search-results').innerHTML = '<span style="color:#888;">輸入搜尋文字後點擊「搜尋」</span>';
            state.searchMatches = [];
            state.searchIndex = 0;
            
            document.getElementById('search-dialog').classList.add('show');
        }
        
        function closeSearchReplace() {
            document.getElementById('search-dialog').classList.remove('show');
        }
        
        function searchText() {
            const searchStr = document.getElementById('search-text').value;
            const caseSensitive = document.getElementById('search-case-sensitive').checked;
            
            if (!searchStr) {
                toast('請輸入搜尋文字', 'error');
                return;
            }
            
            state.searchMatches = [];
            
            state.regions.forEach((region, index) => {
                const text = caseSensitive ? region.text : region.text.toLowerCase();
                const search = caseSensitive ? searchStr : searchStr.toLowerCase();
                
                if (text.includes(search)) {
                    state.searchMatches.push(index);
                }
            });
            
            if (state.searchMatches.length === 0) {
                document.getElementById('search-results').innerHTML = '<span style="color:#f87171;">找不到符合的文字</span>';
            } else {
                state.searchIndex = 0;
                highlightSearchMatch();
                document.getElementById('search-results').innerHTML = 
                    `<span style="color:#22c55e;">找到 ${state.searchMatches.length} 個符合項目</span>`;
            }
        }
        
        function highlightSearchMatch() {
            if (state.searchMatches.length === 0) return;
            
            const regionIndex = state.searchMatches[state.searchIndex];
            state.activeRegion = state.regions[regionIndex];
            renderRegions();
            updatePanel();
            
            // 滾動到該區域
            const region = state.activeRegion;
            const container = document.getElementById('canvas-wrapper');
            container.scrollTo({
                left: region.x * state.displayScale - container.clientWidth / 2,
                top: region.y * state.displayScale - container.clientHeight / 2,
                behavior: 'smooth'
            });
        }
        
        function replaceNext() {
            const searchStr = document.getElementById('search-text').value;
            const replaceStr = document.getElementById('replace-text').value;
            const caseSensitive = document.getElementById('search-case-sensitive').checked;
            
            if (state.searchMatches.length === 0) {
                searchText();
                return;
            }
            
            const regionIndex = state.searchMatches[state.searchIndex];
            const region = state.regions[regionIndex];
            
            if (caseSensitive) {
                region.text = region.text.replace(searchStr, replaceStr);
            } else {
                const regex = new RegExp(searchStr, 'gi');
                region.text = region.text.replace(regex, replaceStr);
            }
            
            region.edited = true;
            redrawRegion(region);
            
            // 移到下一個
            state.searchIndex = (state.searchIndex + 1) % state.searchMatches.length;
            highlightSearchMatch();
            
            toast('已取代 1 項', 'success');
        }
        
        function replaceAll() {
            const searchStr = document.getElementById('search-text').value;
            const replaceStr = document.getElementById('replace-text').value;
            const caseSensitive = document.getElementById('search-case-sensitive').checked;
            
            if (!searchStr) {
                toast('請輸入搜尋文字', 'error');
                return;
            }
            
            let count = 0;
            
            state.regions.forEach(region => {
                const text = caseSensitive ? region.text : region.text.toLowerCase();
                const search = caseSensitive ? searchStr : searchStr.toLowerCase();
                
                if (text.includes(search)) {
                    if (caseSensitive) {
                        region.text = region.text.split(searchStr).join(replaceStr);
                    } else {
                        const regex = new RegExp(searchStr, 'gi');
                        region.text = region.text.replace(regex, replaceStr);
                    }
                    region.edited = true;
                    redrawRegion(region);
                    count++;
                }
            });
            
            if (count > 0) {
                saveHistory('批次取代文字');
                toast(`已取代 ${count} 項`, 'success');
                closeSearchReplace();
            } else {
                toast('找不到符合的文字', 'error');
            }
        }
        
        // ============ 輔助線 ============
        
        // 儲存固定的輔助線
        let fixedGuides = [];
        
        function toggleGuides() {
            state.guidesVisible = !state.guidesVisible;
            const container = document.getElementById('guides-container');
            const btn = document.getElementById('btn-guides');
            
            if (state.guidesVisible) {
                container.classList.remove('hidden');
                btn.classList.add('active');
                // 移動輔助線容器到 canvas-container 內
                document.getElementById('canvas-container').appendChild(container);
                // 設置 guides-container 尺寸與 canvas 相同
                container.style.width = canvas.width + 'px';
                container.style.height = canvas.height + 'px';
                // 設置十字線尺寸
                document.getElementById('guide-cursor-h').style.width = canvas.width + 'px';
                document.getElementById('guide-cursor-v').style.height = canvas.height + 'px';
                // 設置對齊線和中心線尺寸
                document.getElementById('guide-snap-h').style.width = canvas.width + 'px';
                document.getElementById('guide-snap-v').style.height = canvas.height + 'px';
                document.getElementById('guide-center-h').style.width = canvas.width + 'px';
                document.getElementById('guide-center-v').style.height = canvas.height + 'px';
                // 添加事件到 canvas-container
                const canvasContainer = document.getElementById('canvas-container');
                canvasContainer.addEventListener('mousemove', updateGuides);
                canvasContainer.addEventListener('mouseleave', hideGuideCursor);
                canvasContainer.addEventListener('click', onGuideClick);
                // 更新中心線位置
                updateCenterLines();
                toast('輔助線已開啟 - 點擊可固定線條', 'success');
            } else {
                container.classList.add('hidden');
                btn.classList.remove('active');
                // 移除事件
                const canvasContainer = document.getElementById('canvas-container');
                canvasContainer.removeEventListener('mousemove', updateGuides);
                canvasContainer.removeEventListener('mouseleave', hideGuideCursor);
                canvasContainer.removeEventListener('click', onGuideClick);
                // 清除所有固定線
                clearAllFixedGuides();
                toast('輔助線已關閉', 'info');
            }
        }
        
        function updateCenterLines() {
            if (!canvas.width || !canvas.height) return;
            const centerH = document.getElementById('guide-center-h');
            const centerV = document.getElementById('guide-center-v');
            // 直接使用 canvas 的尺寸（不需乘以 scale，因為輔助線在 container 內會被一起縮放）
            centerH.style.top = (canvas.height / 2) + 'px';
            centerV.style.left = (canvas.width / 2) + 'px';
            centerH.classList.add('active');
            centerV.classList.add('active');
        }
        
        function updateGuides(e) {
            if (!state.guidesVisible || !state.image) return;
            
            const container = document.getElementById('canvas-container');
            const containerRect = container.getBoundingClientRect();
            
            // 計算滑鼠相對於 canvas-container 縮放後的位置
            const scaledX = e.clientX - containerRect.left;
            const scaledY = e.clientY - containerRect.top;
            
            // 因為 canvas-container 使用 transform: scale()
            // 需要將座標除以 displayScale 得到內部座標
            const mouseX = scaledX / state.displayScale;
            const mouseY = scaledY / state.displayScale;
            
            // 確保在有效範圍內
            if (mouseX < 0 || mouseY < 0 || mouseX > canvas.width || mouseY > canvas.height) {
                hideGuideCursor();
                return;
            }
            
            // 實際圖片座標（與 mouseX/mouseY 相同，因為 canvas 內部沒有額外縮放）
            const realX = mouseX;
            const realY = mouseY;
            
            // 更新十字線位置（使用內部座標，因為輔助線也在 container 內會被縮放）
            const cursorH = document.getElementById('guide-cursor-h');
            const cursorV = document.getElementById('guide-cursor-v');
            cursorH.style.top = mouseY + 'px';
            cursorV.style.left = mouseX + 'px';
            
            // 更新座標顯示
            const coord = document.getElementById('guide-coord');
            coord.textContent = `X: ${Math.round(realX)}  Y: ${Math.round(realY)}`;
            // 座標框位置
            const coordX = Math.min(mouseX + 15, canvas.width - 120);
            const coordY = Math.max(mouseY - 30, 10);
            coord.style.left = coordX + 'px';
            coord.style.top = coordY + 'px';
            coord.style.display = 'block';
            
            // 檢測與區域的對齊
            checkAlignment(realX, realY);
        }
        
        function hideGuideCursor() {
            // 隱藏對齊線和座標
            document.getElementById('guide-snap-h').classList.remove('active', 'snap');
            document.getElementById('guide-snap-v').classList.remove('active', 'snap');
            document.getElementById('guide-coord').style.display = 'none';
        }
        
        function checkAlignment(x, y) {
            const threshold = 5; // 對齊閾值（像素）
            
            // 收集所有對齊點
            const hPoints = []; // 水平對齊點（y 座標）
            const vPoints = []; // 垂直對齊點（x 座標）
            
            // 畫布中心點
            hPoints.push({ y: canvas.height / 2, label: '中心' });
            vPoints.push({ x: canvas.width / 2, label: '中心' });
            
            // 畫布邊界
            hPoints.push({ y: 0, label: '頂部' });
            hPoints.push({ y: canvas.height, label: '底部' });
            vPoints.push({ x: 0, label: '左側' });
            vPoints.push({ x: canvas.width, label: '右側' });
            
            // 所有區域的邊界和中心
            state.regions.forEach((r, i) => {
                hPoints.push({ y: r.y, label: `區域${i+1}上` });
                hPoints.push({ y: r.y + r.h, label: `區域${i+1}下` });
                hPoints.push({ y: r.y + r.h / 2, label: `區域${i+1}中` });
                vPoints.push({ x: r.x, label: `區域${i+1}左` });
                vPoints.push({ x: r.x + r.w, label: `區域${i+1}右` });
                vPoints.push({ x: r.x + r.w / 2, label: `區域${i+1}中` });
            });
            
            // 固定的輔助線
            fixedGuides.forEach((g, i) => {
                if (g.type === 'h') {
                    hPoints.push({ y: g.pos, label: `固定線${i+1}` });
                } else {
                    vPoints.push({ x: g.pos, label: `固定線${i+1}` });
                }
            });
            
            // 檢測水平對齊
            let hSnap = null;
            let minHDist = threshold;
            hPoints.forEach(p => {
                const dist = Math.abs(y - p.y);
                if (dist < minHDist) {
                    minHDist = dist;
                    hSnap = p;
                }
            });
            
            // 檢測垂直對齊
            let vSnap = null;
            let minVDist = threshold;
            vPoints.forEach(p => {
                const dist = Math.abs(x - p.x);
                if (dist < minVDist) {
                    minVDist = dist;
                    vSnap = p;
                }
            });
            
            // 更新對齊線顯示（直接使用內部座標，不需乘以 scale）
            const snapH = document.getElementById('guide-snap-h');
            const snapV = document.getElementById('guide-snap-v');
            
            if (hSnap) {
                snapH.style.top = hSnap.y + 'px';
                snapH.classList.add('active', 'snap');
            } else {
                snapH.classList.remove('active', 'snap');
            }
            
            if (vSnap) {
                snapV.style.left = vSnap.x + 'px';
                snapV.classList.add('active', 'snap');
            } else {
                snapV.classList.remove('active', 'snap');
            }
        }
        
        function onGuideClick(e) {
            if (!state.guidesVisible || !state.image) return;
            // 避免影響其他操作
            if (state.mode !== 'select') return;
            
            const container = document.getElementById('canvas-container');
            const containerRect = container.getBoundingClientRect();
            
            // 計算內部座標（考慮 transform scale）
            const scaledX = e.clientX - containerRect.left;
            const scaledY = e.clientY - containerRect.top;
            const mouseX = scaledX / state.displayScale;
            const mouseY = scaledY / state.displayScale;
            
            // 確保在有效範圍內
            if (mouseX < 0 || mouseY < 0 || mouseX > canvas.width || mouseY > canvas.height) {
                return;
            }
            
            // 添加水平和垂直固定線（使用內部座標）
            addFixedGuide('h', mouseY);
            addFixedGuide('v', mouseX);
            
            updateFixedGuideCount();
        }
        
        function addFixedGuide(type, pos) {
            const container = document.getElementById('guide-fixed-lines');
            
            const line = document.createElement('div');
            line.className = `guide-fixed guide-${type === 'h' ? 'h' : 'v'}`;
            
            if (type === 'h') {
                line.style.top = pos + 'px';
                line.style.width = canvas.width + 'px';
            } else {
                line.style.left = pos + 'px';
                line.style.height = canvas.height + 'px';
            }
            
            container.appendChild(line);
            fixedGuides.push({ type, pos, element: line });
        }
        
        function updateFixedGuideCount() {
            const countEl = document.getElementById('guide-fixed-count');
            const count = fixedGuides.length;
            
            if (count > 0) {
                countEl.textContent = `已固定 ${count / 2} 組輔助線（關閉輔助線可清除）`;
                countEl.style.display = 'block';
            } else {
                countEl.style.display = 'none';
            }
        }
        
        function clearAllFixedGuides() {
            const container = document.getElementById('guide-fixed-lines');
            container.innerHTML = '';
            fixedGuides = [];
            updateFixedGuideCount();
        }
        
        async function applyWatermark() {
            if (!state.watermark || !state.image) {
                toast('請先選擇浮水印圖片', 'error');
                return;
            }
            
            // 檢查是否套用到所有頁面
            const scope = document.querySelector('input[name="watermark-scope"]:checked')?.value || 'current';
            const applyToAll = scope === 'all' && state.pdfPages.length > 1;
            
            if (applyToAll) {
                // 套用到所有頁面
                showLoading('套用浮水印到所有頁面...');
                
                try {
                    // 先保存當前頁面的編輯狀態（使用 JPEG 減少記憶體）
                    state.pdfPages[state.currentPdfPage].editedData = canvas.toDataURL('image/jpeg', 0.92);
                    state.pdfPages[state.currentPdfPage].regions = JSON.parse(JSON.stringify(state.regions));
                    
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');
                    
                    for (let i = 0; i < state.pdfPages.length; i++) {
                        setProgress(Math.round((i / state.pdfPages.length) * 100));
                        
                        const pageData = state.pdfPages[i];
                        const pageImg = await loadImageFromUrl(pageData.editedData || pageData.dataUrl);
                        
                        tempCanvas.width = pageImg.width;
                        tempCanvas.height = pageImg.height;
                        tempCtx.drawImage(pageImg, 0, 0);
                        
                        // 計算相對位置（根據頁面大小調整）
                        let wmX = state.watermarkX;
                        let wmY = state.watermarkY;
                        
                        // 如果是使用快速定位的相對位置，需要根據頁面大小重新計算
                        // 這裡使用簡單的比例計算
                        if (i !== state.currentPdfPage) {
                            // 檢查是否是靠右或靠下的位置
                            const currentPageWidth = canvas.width;
                            const currentPageHeight = canvas.height;
                            
                            // 計算相對於右邊和下邊的距離
                            const rightMargin = currentPageWidth - state.watermarkX - state.watermarkWidth;
                            const bottomMargin = currentPageHeight - state.watermarkY - state.watermarkHeight;
                            
                            // 如果靠右（右邊距小於左邊距），使用右對齊
                            if (rightMargin < state.watermarkX) {
                                wmX = pageImg.width - state.watermarkWidth - rightMargin;
                            }
                            
                            // 如果靠下（下邊距小於上邊距），使用下對齊
                            if (bottomMargin < state.watermarkY) {
                                wmY = pageImg.height - state.watermarkHeight - bottomMargin;
                            }
                            
                            // 確保不超出邊界
                            wmX = Math.max(0, Math.min(pageImg.width - state.watermarkWidth, wmX));
                            wmY = Math.max(0, Math.min(pageImg.height - state.watermarkHeight, wmY));
                        }
                        
                        // 繪製浮水印（帶旋轉）
                        tempCtx.globalAlpha = state.watermarkOpacity;
                        const rotation = state.watermarkRotation || 0;
                        
                        tempCtx.save();
                        tempCtx.translate(wmX + state.watermarkWidth / 2, wmY + state.watermarkHeight / 2);
                        tempCtx.rotate(rotation * Math.PI / 180);
                        tempCtx.drawImage(
                            state.watermark,
                            -state.watermarkWidth / 2,
                            -state.watermarkHeight / 2,
                            state.watermarkWidth,
                            state.watermarkHeight
                        );
                        tempCtx.restore();
                        tempCtx.globalAlpha = 1;
                        
                        // 更新頁面數據 - 使用 JPEG 格式減少記憶體使用
                        pageData.editedData = tempCanvas.toDataURL('image/jpeg', 0.92);
                        
                        // 釋放記憶體
                        await new Promise(resolve => setTimeout(resolve, 10));
                    }
                    
                    // 重新載入當前頁面
                    const currentImg = await loadImageFromUrl(state.pdfPages[state.currentPdfPage].editedData);
                    canvas.width = currentImg.width;
                    canvas.height = currentImg.height;
                    ctx.drawImage(currentImg, 0, 0);
                    
                    // 更新 state.image
                    state.image = currentImg;
                    
                    // 保存歷史
                    saveHistory('添加浮水印（所有頁面）');
                    
                    hideLoading();
                    updateUndoButton();
                    closeWatermarkDialog();
                    toast(`已為 ${state.pdfPages.length} 頁添加浮水印`, 'success');
                    
                } catch (e) {
                    console.error('Watermark error:', e);
                    hideLoading();
                    toast('套用浮水印失敗: ' + e.message, 'error');
                }
                
            } else {
                // 僅套用當前頁 - 改為添加可編輯的浮水印圖像區塊
                
                // 創建浮水印的圖像數據（不帶透明度，透明度由 opacity 屬性控制）
                const wmCanvas = document.createElement('canvas');
                wmCanvas.width = state.watermarkWidth;
                wmCanvas.height = state.watermarkHeight;
                const wmCtx = wmCanvas.getContext('2d');
                
                // 繪製原始浮水印（不帶透明度）
                wmCtx.drawImage(state.watermark, 0, 0, state.watermarkWidth, state.watermarkHeight);
                const originalData = wmCanvas.toDataURL('image/png');
                
                // 創建帶透明度的預覽版本
                wmCtx.clearRect(0, 0, wmCanvas.width, wmCanvas.height);
                wmCtx.globalAlpha = state.watermarkOpacity;
                wmCtx.drawImage(state.watermark, 0, 0, state.watermarkWidth, state.watermarkHeight);
                const previewData = wmCanvas.toDataURL('image/png');
                
                // 創建圖像區塊
                const watermarkRegion = {
                    id: Date.now(),
                    x: state.watermarkX,
                    y: state.watermarkY,
                    w: state.watermarkWidth,
                    h: state.watermarkHeight,
                    originalW: state.watermarkWidth,
                    originalH: state.watermarkHeight,
                    scale: 1,
                    rotation: state.watermarkRotation || 0,
                    imageData: previewData,           // 預覽用（帶透明度）
                    originalImageData: originalData,  // 原始數據（不帶透明度）
                    isWatermark: true,  // 標記為浮水印
                    opacity: state.watermarkOpacity,
                    layerIndex: activeLayerIndex,
                    bgColor: '#ffffff',
                    tolerance: 30,
                    transparentBg: false
                };
                
                // 添加到圖像區塊列表
                state.imageRegions = state.imageRegions || [];
                state.imageRegions.push(watermarkRegion);
                state.activeImageRegion = watermarkRegion;
                
                // 渲染圖像區塊
                renderImageRegions();
                updateImagePanel();
                
                closeWatermarkDialog();
                toast('浮水印已添加，可拖動調整位置、縮放和旋轉', 'success');
            }
        }
        
        // 套用浮水印到所有頁面（直接繪製）
        async function applyWatermarkToAllPages() {
            if (!state.watermark || !state.image) {
                toast('請先選擇浮水印圖片', 'error');
                return;
            }
            
            showLoading('套用浮水印到所有頁面...');
            
            try {
                // 先保存當前頁面的編輯狀態（使用 JPEG 減少記憶體）
                state.pdfPages[state.currentPdfPage].editedData = canvas.toDataURL('image/jpeg', 0.92);
                state.pdfPages[state.currentPdfPage].regions = JSON.parse(JSON.stringify(state.regions));
                
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                
                for (let i = 0; i < state.pdfPages.length; i++) {
                    setProgress(Math.round((i / state.pdfPages.length) * 100));
                    
                    const pageData = state.pdfPages[i];
                    const pageImg = await loadImageFromUrl(pageData.editedData || pageData.dataUrl);
                    
                    tempCanvas.width = pageImg.width;
                    tempCanvas.height = pageImg.height;
                    tempCtx.drawImage(pageImg, 0, 0);
                    
                    // 計算相對位置（根據頁面大小調整）
                    let wmX = state.watermarkX;
                    let wmY = state.watermarkY;
                    
                    if (i !== state.currentPdfPage) {
                        const currentPageWidth = canvas.width;
                        const currentPageHeight = canvas.height;
                        const rightMargin = currentPageWidth - state.watermarkX - state.watermarkWidth;
                        const bottomMargin = currentPageHeight - state.watermarkY - state.watermarkHeight;
                        
                        if (rightMargin < state.watermarkX) {
                            wmX = pageImg.width - state.watermarkWidth - rightMargin;
                        }
                        if (bottomMargin < state.watermarkY) {
                            wmY = pageImg.height - state.watermarkHeight - bottomMargin;
                        }
                        
                        wmX = Math.max(0, Math.min(pageImg.width - state.watermarkWidth, wmX));
                        wmY = Math.max(0, Math.min(pageImg.height - state.watermarkHeight, wmY));
                    }
                    
                    // 繪製浮水印（帶旋轉）
                    tempCtx.globalAlpha = state.watermarkOpacity;
                    const rotation = state.watermarkRotation || 0;
                    
                    tempCtx.save();
                    tempCtx.translate(wmX + state.watermarkWidth / 2, wmY + state.watermarkHeight / 2);
                    tempCtx.rotate(rotation * Math.PI / 180);
                    tempCtx.drawImage(
                        state.watermark,
                        -state.watermarkWidth / 2,
                        -state.watermarkHeight / 2,
                        state.watermarkWidth,
                        state.watermarkHeight
                    );
                    tempCtx.restore();
                    tempCtx.globalAlpha = 1;
                    
                    // 更新頁面數據 - 使用 JPEG 格式減少記憶體使用
                    pageData.editedData = tempCanvas.toDataURL('image/jpeg', 0.92);
                    
                    // 釋放記憶體
                    await new Promise(resolve => setTimeout(resolve, 10));
                }
                
                // 重新載入當前頁面
                const currentImg = await loadImageFromUrl(state.pdfPages[state.currentPdfPage].editedData);
                canvas.width = currentImg.width;
                canvas.height = currentImg.height;
                ctx.drawImage(currentImg, 0, 0);
                
                // 更新 state.image
                state.image = currentImg;
                
                // 保存歷史
                saveHistory('添加浮水印（所有頁面）');
                
                hideLoading();
                updateUndoButton();
                closeWatermarkDialog();
                toast(`已為 ${state.pdfPages.length} 頁添加浮水印`, 'success');
                
            } catch (e) {
                console.error('Watermark error:', e);
                hideLoading();
                toast('套用浮水印失敗: ' + e.message, 'error');
            }
        }

        // 分析文字樣式（字體、粗細）
        function analyzeTextStyle(imageData, text, bgColor) {
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;
            
            // 解析背景色
            const bgR = parseInt(bgColor.slice(1, 3), 16);
            const bgG = parseInt(bgColor.slice(3, 5), 16);
            const bgB = parseInt(bgColor.slice(5, 7), 16);
            
            // 計算文字像素的比例和平均筆畫寬度
            let textPixels = 0;
            let totalPixels = width * height;
            const threshold = 50;
            
            // 分析每一行的筆畫寬度
            let strokeWidths = [];
            
            // 建立二值化圖像用於邊緣分析
            const binaryMap = new Array(height).fill(null).map(() => new Array(width).fill(false));
            
            for (let y = 0; y < height; y++) {
                let lineTextPixels = 0;
                let inStroke = false;
                let strokeStart = 0;
                
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    const r = data[idx];
                    const g = data[idx + 1];
                    const b = data[idx + 2];
                    
                    const diff = Math.abs(r - bgR) + Math.abs(g - bgG) + Math.abs(b - bgB);
                    const isText = diff > threshold;
                    
                    binaryMap[y][x] = isText;
                    
                    if (isText) {
                        textPixels++;
                        lineTextPixels++;
                        if (!inStroke) {
                            inStroke = true;
                            strokeStart = x;
                        }
                    } else {
                        if (inStroke) {
                            const strokeW = x - strokeStart;
                            if (strokeW > 1 && strokeW < width / 2) {
                                strokeWidths.push(strokeW);
                            }
                            inStroke = false;
                        }
                    }
                }
            }
            
            // 計算平均筆畫寬度
            const avgStrokeWidth = strokeWidths.length > 0 
                ? strokeWidths.reduce((a, b) => a + b, 0) / strokeWidths.length 
                : 2;
            
            // 計算文字密度
            const textDensity = textPixels / totalPixels;
            
            // 檢測是否包含中文
            const hasChinese = /[\u4e00-\u9fff]/.test(text);
            const hasEnglish = /[a-zA-Z]/.test(text);
            
            // 根據筆畫寬度和高度比例判斷粗細
            const strokeRatio = avgStrokeWidth / height;
            let fontWeight = '400'; // 預設正常
            
            if (strokeRatio > 0.12 || avgStrokeWidth > 4) {
                fontWeight = '700'; // 粗體
            } else if (strokeRatio > 0.08 || avgStrokeWidth > 3) {
                fontWeight = '500'; // 中等
            }
            
            // 嘗試偵測襯線字體（筆畫端點有裝飾）
            // 簡化判斷：如果筆畫變化較大，可能是襯線字體
            let isSerif = false;
            if (strokeWidths.length > 10) {
                const sorted = [...strokeWidths].sort((a, b) => a - b);
                const minStroke = sorted[Math.floor(sorted.length * 0.1)];
                const maxStroke = sorted[Math.floor(sorted.length * 0.9)];
                if (maxStroke > minStroke * 2) {
                    isSerif = true;
                }
            }
            
            // 偵測圓角字體
            // 分析邊緣像素的曲率特徵
            let isRounded = false;
            let cornerCount = 0;
            let roundedCornerCount = 0;
            
            // 檢測角點和圓角
            for (let y = 2; y < height - 2; y++) {
                for (let x = 2; x < width - 2; x++) {
                    if (!binaryMap[y][x]) continue;
                    
                    // 檢查是否為邊緣像素
                    const neighbors = [
                        binaryMap[y-1][x], binaryMap[y+1][x],
                        binaryMap[y][x-1], binaryMap[y][x+1]
                    ];
                    const neighborCount = neighbors.filter(n => n).length;
                    
                    // 邊緣像素（不是完全被包圍）
                    if (neighborCount < 4 && neighborCount > 0) {
                        // 檢查是否為角點（對角線鄰居分析）
                        const diagonals = [
                            binaryMap[y-1][x-1], binaryMap[y-1][x+1],
                            binaryMap[y+1][x-1], binaryMap[y+1][x+1]
                        ];
                        const diagCount = diagonals.filter(d => d).length;
                        
                        // 檢查 3x3 區域的模式
                        const pattern = [
                            binaryMap[y-1][x-1], binaryMap[y-1][x], binaryMap[y-1][x+1],
                            binaryMap[y][x-1], binaryMap[y][x], binaryMap[y][x+1],
                            binaryMap[y+1][x-1], binaryMap[y+1][x], binaryMap[y+1][x+1]
                        ];
                        const patternSum = pattern.filter(p => p).length;
                        
                        // 角點特徵：對角有缺失
                        if (neighborCount === 2 && diagCount <= 2) {
                            cornerCount++;
                            
                            // 圓角特徵：周圍像素較多（填充較滿）
                            if (patternSum >= 5) {
                                roundedCornerCount++;
                            }
                        }
                    }
                }
            }
            
            // 如果圓角比例高，判定為圓角字體
            if (cornerCount > 5 && roundedCornerCount / cornerCount > 0.5) {
                isRounded = true;
            }
            
            // 也可以通過筆畫寬度的一致性來判斷
            // 圓角字體通常筆畫寬度更均勻
            if (strokeWidths.length > 5) {
                const mean = avgStrokeWidth;
                const variance = strokeWidths.reduce((sum, w) => sum + Math.pow(w - mean, 2), 0) / strokeWidths.length;
                const stdDev = Math.sqrt(variance);
                const coefficient = stdDev / mean; // 變異係數
                
                // 變異係數小表示筆畫均勻，可能是圓角字體
                if (coefficient < 0.3 && !isSerif) {
                    isRounded = true;
                }
            }
            
            // 選擇字體 - 根據分析結果
            let fontFamily = 'Inter';
            
            if (hasChinese) {
                if (isRounded) {
                    fontFamily = 'jf-openhuninn'; // 中文圓角字體
                } else if (isSerif) {
                    fontFamily = 'Noto Serif TC';
                } else {
                    fontFamily = 'Noto Sans TC';
                }
            } else {
                if (isRounded) {
                    fontFamily = 'Nunito'; // 英文圓角字體
                } else if (isSerif) {
                    fontFamily = 'Georgia';
                } else {
                    fontFamily = 'Inter';
                }
            }
            
            return {
                fontFamily,
                fontWeight,
                isSerif,
                isRounded,
                hasChinese,
                avgStrokeWidth,
                textDensity
            };
        }

        // 清理 OCR 文字：移除中文字之間的空白，保留英文單詞間的空白
        // ============ OCR 同行字組分割 ============
        // 根據 word 間距判斷是否為不同字組，大間距 / 特殊符號隔開則拆分
        // gapSensitivity: 1=極高(分更多組) ~ 5=極低(分更少組)，預設 3
        function splitLineIntoWordGroups(line, gapSensitivity) {
            gapSensitivity = gapSensitivity || 3;
            const gapMultiplier = [0.4, 0.6, 0.8, 1.2, 1.8][gapSensitivity - 1] || 0.8;
            const words = line.words;
            if (!words || words.length === 0) return [{ 
                text: line.text.trim(), 
                bbox: line.bbox 
            }];
            
            // 過濾掉空白 word
            const validWords = words.filter(w => w.text.trim());
            if (validWords.length === 0) return [];
            if (validWords.length === 1) return [{ 
                text: cleanOcrText(validWords[0].text.trim()), 
                bbox: validWords[0].bbox 
            }];
            
            // 計算行高
            const lineH = line.bbox.y1 - line.bbox.y0;
            
            // 計算所有相鄰 word 之間的間距
            const gaps = [];
            for (let i = 1; i < validWords.length; i++) {
                gaps.push(Math.max(0, validWords[i].bbox.x0 - validWords[i-1].bbox.x1));
            }
            
            // 計算平均字元寬度（作為基準）
            const totalTextWidth = validWords.reduce((sum, w) => sum + (w.bbox.x1 - w.bbox.x0), 0);
            const totalChars = validWords.reduce((sum, w) => sum + w.text.length, 0);
            const avgCharWidth = totalChars > 0 ? totalTextWidth / totalChars : lineH;
            
            // 計算中位間距（排除極端值後的正常間距基準）
            const sortedGaps = [...gaps].sort((a, b) => a - b);
            const medianGap = sortedGaps.length > 0 ? sortedGaps[Math.floor(sortedGaps.length / 2)] : 0;
            
            // 動態間距閾值：取以下三者的最小值
            // 1. 行高 × 0.8（適中的絕對閾值）
            // 2. 中位間距 × 3（相對閾值 — 比正常間距大 3 倍以上就分割）
            // 3. 平均字寬 × 2.5（以字元大小為基準）
            // 但至少 10px
            let gapThreshold;
            if (medianGap > 0 && gaps.length >= 2) {
                gapThreshold = Math.max(10, Math.min(
                    lineH * gapMultiplier,
                    medianGap * (1.5 + gapSensitivity * 0.5),
                    avgCharWidth * (1.5 + gapSensitivity * 0.4)
                ));
            } else {
                gapThreshold = Math.max(10, Math.min(lineH * gapMultiplier, avgCharWidth * (1.5 + gapSensitivity * 0.4)));
            }
            
            // 特殊分隔符號（出現時強制分割）
            const separatorRegex = /^[\|\│┃┆┇║┊┋▏▎▍▌▋▊▉█＝═─━┄┅┈┉…‥·•◦○●◎※★☆▪▫◆◇■□△▽☐☑✓✗✘⬛⬜／＼÷×±∞≠≡≤≥]+$/;
            
            const groups = [];
            let currentGroup = {
                words: [validWords[0]],
                x0: validWords[0].bbox.x0,
                y0: validWords[0].bbox.y0,
                x1: validWords[0].bbox.x1,
                y1: validWords[0].bbox.y1
            };
            
            for (let i = 1; i < validWords.length; i++) {
                const prevWord = validWords[i - 1];
                const currWord = validWords[i];
                const gap = currWord.bbox.x0 - prevWord.bbox.x1;
                const isSeparator = separatorRegex.test(currWord.text.trim());
                const prevIsSeparator = separatorRegex.test(prevWord.text.trim());
                
                // 條件：大間距 or 當前/前一個是分隔符號 → 開新群組
                if (gap > gapThreshold || isSeparator || prevIsSeparator) {
                    // 結束目前群組
                    if (currentGroup.words.length > 0) {
                        const groupText = currentGroup.words.map(w => w.text).join('');
                        const cleaned = cleanOcrText(groupText.trim());
                        // 跳過純分隔符號群組
                        if (cleaned && !separatorRegex.test(cleaned)) {
                            groups.push({
                                text: cleaned,
                                bbox: { 
                                    x0: currentGroup.x0, 
                                    y0: currentGroup.y0, 
                                    x1: currentGroup.x1, 
                                    y1: currentGroup.y1 
                                }
                            });
                        }
                    }
                    // 如果當前是分隔符，跳過它
                    if (isSeparator) {
                        // 重新開始下一群組（等下一個 word）
                        currentGroup = { words: [], x0: 0, y0: 0, x1: 0, y1: 0 };
                        continue;
                    }
                    // 開新群組
                    currentGroup = {
                        words: [currWord],
                        x0: currWord.bbox.x0,
                        y0: currWord.bbox.y0,
                        x1: currWord.bbox.x1,
                        y1: currWord.bbox.y1
                    };
                } else {
                    // 合併到目前群組
                    currentGroup.words.push(currWord);
                    currentGroup.x1 = Math.max(currentGroup.x1, currWord.bbox.x1);
                    currentGroup.y0 = Math.min(currentGroup.y0, currWord.bbox.y0);
                    currentGroup.y1 = Math.max(currentGroup.y1, currWord.bbox.y1);
                }
            }
            
            // 處理最後一個群組
            if (currentGroup.words.length > 0) {
                const groupText = currentGroup.words.map(w => w.text).join('');
                const cleaned = cleanOcrText(groupText.trim());
                if (cleaned && !separatorRegex.test(cleaned)) {
                    groups.push({
                        text: cleaned,
                        bbox: { 
                            x0: currentGroup.x0, 
                            y0: currentGroup.y0, 
                            x1: currentGroup.x1, 
                            y1: currentGroup.y1 
                        }
                    });
                }
            }
            
            // 如果分割結果為空或只有一組，回退到整行
            if (groups.length === 0) {
                const cleaned = cleanOcrText(line.text.trim());
                if (cleaned) return [{ text: cleaned, bbox: line.bbox }];
                return [];
            }
            
            return groups;
        }
        
        // 從字組建立可編輯 region
        function createRegionFromWordGroup(group, idSuffix, extraProps) {
            const bbox = group.bbox;
            const gx = bbox.x0;
            const gy = bbox.y0;
            const gw = Math.max(bbox.x1 - bbox.x0, 10);
            const gh = Math.max(bbox.y1 - bbox.y0, 10);
            
            // 防止超出畫布
            const safeX = Math.max(0, Math.min(gx, canvas.width - 5));
            const safeY = Math.max(0, Math.min(gy, canvas.height - 5));
            const safeW = Math.min(gw, canvas.width - safeX);
            const safeH = Math.min(gh, canvas.height - safeY);
            
            // 檢查是否已存在類似區域
            if (state.regions.some(r => Math.abs(r.x - safeX) < 15 && Math.abs(r.y - safeY) < 15)) {
                return null;
            }
            
            let regionData, colors, textInfo, fontSize, textStyle;
            try {
                regionData = ctx.getImageData(safeX, safeY, safeW, safeH);
                colors = analyzeColors(regionData);
                textInfo = analyzeTextHeight(regionData, colors.bgColor);
                fontSize = Math.max(12, Math.round(textInfo.textHeight * 0.85));
                textStyle = analyzeTextStyle(regionData, group.text, colors.bgColor);
            } catch (e) {
                colors = { textColor: '#000000', bgColor: '#ffffff' };
                fontSize = Math.max(12, Math.round(gh * 0.7));
                textStyle = { fontFamily: 'Noto Sans TC, sans-serif', fontWeight: '400' };
            }
            
            const region = {
                id: Date.now() + idSuffix,
                x: safeX, y: safeY, w: safeW, h: safeH,
                originalText: group.text,
                text: group.text,
                fontSize,
                fontFamily: textStyle.fontFamily,
                fontWeight: textStyle.fontWeight,
                scaleY: 1.0,
                color: colors.textColor,
                bgColor: colors.bgColor,
                transparentBg: true,
                padding: 5,
                textAlign: 'left',
                lineHeight: 1.2,
                letterSpacing: 0,
                strokeColor: '#000000',
                strokeWidth: 0,
                shadowColor: '#000000',
                shadowBlur: 0,
                shadowOffsetX: 0,
                shadowOffsetY: 0,
                rotation: 0,
                verticalPunctFix: true,
                gradientEnabled: false,
                gradientColor1: '#ff0000',
                gradientColor2: '#0000ff',
                gradientDirection: 'horizontal',
                curveEnabled: false,
                curveRadius: 100,
                curveStartAngle: 0,
                edited: false,
                layerIndex: activeLayerIndex,
                ...(extraProps || {})
            };
            
            return region;
        }

        function cleanOcrText(text) {
            if (!text) return '';
            
            // 移除中文字符之間的空格
            // 中文字符範圍：\u4e00-\u9fff (CJK統一漢字)
            // 也包括標點符號：\u3000-\u303f (CJK標點) \uff00-\uffef (全形字符)
            let result = text;
            
            // 移除中文字與中文字之間的空格
            result = result.replace(/([\u4e00-\u9fff\u3000-\u303f\uff00-\uffef])\s+([\u4e00-\u9fff\u3000-\u303f\uff00-\uffef])/g, '$1$2');
            
            // 重複執行以處理連續的情況
            result = result.replace(/([\u4e00-\u9fff\u3000-\u303f\uff00-\uffef])\s+([\u4e00-\u9fff\u3000-\u303f\uff00-\uffef])/g, '$1$2');
            
            // 移除中文字與英文/數字之間多餘的空格（保留一個）
            result = result.replace(/([\u4e00-\u9fff])\s{2,}([a-zA-Z0-9])/g, '$1 $2');
            result = result.replace(/([a-zA-Z0-9])\s{2,}([\u4e00-\u9fff])/g, '$1 $2');
            
            // 移除行首行尾的空格
            result = result.split('\n').map(line => line.trim()).join('\n');
            
            // 移除多餘的換行
            result = result.replace(/\n{3,}/g, '\n\n');
            
            return result.trim();
        }

        // 分析文字實際高度（從圖像像素判斷）
        function analyzeTextHeight(imageData, bgColor) {
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;
            
            // 解析背景色
            const bgR = parseInt(bgColor.slice(1, 3), 16);
            const bgG = parseInt(bgColor.slice(3, 5), 16);
            const bgB = parseInt(bgColor.slice(5, 7), 16);
            
            // 找出文字的上下邊界（非背景色的像素）
            let topY = height;
            let bottomY = 0;
            const threshold = 50; // 顏色差異閾值
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    const r = data[idx];
                    const g = data[idx + 1];
                    const b = data[idx + 2];
                    
                    // 計算與背景色的差異
                    const diff = Math.abs(r - bgR) + Math.abs(g - bgG) + Math.abs(b - bgB);
                    
                    if (diff > threshold) {
                        // 這是文字像素
                        if (y < topY) topY = y;
                        if (y > bottomY) bottomY = y;
                    }
                }
            }
            
            // 計算文字實際高度
            if (bottomY > topY) {
                const textHeight = bottomY - topY + 1;
                return {
                    textHeight,
                    topMargin: topY,
                    bottomMargin: height - bottomY - 1
                };
            }
            
            // 如果無法偵測，返回區域高度的 70%
            return {
                textHeight: Math.round(height * 0.7),
                topMargin: 0,
                bottomMargin: 0
            };
        }

        // 顏色分析
        function analyzeColors(imgData) {
            const d = imgData.data;
            const w = imgData.width;
            const h = imgData.height;
            
            const edgeColors = [];
            for (let x = 0; x < w; x += 3) {
                edgeColors.push(getPixel(d, w, x, 0));
                edgeColors.push(getPixel(d, w, x, h - 1));
            }
            for (let y = 0; y < h; y += 3) {
                edgeColors.push(getPixel(d, w, 0, y));
                edgeColors.push(getPixel(d, w, w - 1, y));
            }
            
            const centerColors = [];
            const cx = Math.floor(w / 2);
            const cy = Math.floor(h / 2);
            for (let dy = -5; dy <= 5; dy++) {
                for (let dx = -5; dx <= 5; dx++) {
                    if (cx + dx >= 0 && cx + dx < w && cy + dy >= 0 && cy + dy < h) {
                        centerColors.push(getPixel(d, w, cx + dx, cy + dy));
                    }
                }
            }
            
            const bgColor = mostCommon(edgeColors);
            const textColor = getContrastColor(centerColors, bgColor);
            
            return { bgColor, textColor };
        }

        function getPixel(d, w, x, y) {
            const i = (y * w + x) * 4;
            return { r: d[i], g: d[i+1], b: d[i+2] };
        }

        function mostCommon(colors) {
            const counts = {};
            colors.forEach(c => {
                const key = `${Math.round(c.r/16)*16},${Math.round(c.g/16)*16},${Math.round(c.b/16)*16}`;
                counts[key] = (counts[key] || 0) + 1;
            });
            
            let maxKey = Object.keys(counts)[0] || '255,255,255';
            let maxCount = 0;
            for (const key in counts) {
                if (counts[key] > maxCount) {
                    maxCount = counts[key];
                    maxKey = key;
                }
            }
            
            const [r, g, b] = maxKey.split(',').map(Number);
            return rgbToHex(r, g, b);
        }

        function getContrastColor(colors, bgHex) {
            const bgRgb = hexToRgb(bgHex);
            let maxDiff = 0;
            let result = { r: 0, g: 0, b: 0 };
            
            colors.forEach(c => {
                const diff = Math.abs(c.r - bgRgb.r) + Math.abs(c.g - bgRgb.g) + Math.abs(c.b - bgRgb.b);
                if (diff > maxDiff) {
                    maxDiff = diff;
                    result = c;
                }
            });
            
            return rgbToHex(result.r, result.g, result.b);
        }

        function analyzeWeight(imgData) {
            const d = imgData.data;
            let dark = 0, total = 0;
            
            for (let i = 0; i < d.length; i += 16) {
                const brightness = (d[i] + d[i+1] + d[i+2]) / 3;
                if (brightness < 128) dark++;
                total++;
            }
            
            return total > 0 && (dark / total) > 0.25;
        }

        function rgbToHex(r, g, b) {
            return '#' + [r, g, b].map(x => Math.min(255, Math.max(0, x)).toString(16).padStart(2, '0')).join('');
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 0, g: 0, b: 0 };
        }

        // 取得匯出用的畫布（含所有浮動物件）
        async function getExportCanvas() {
            // 建立臨時畫布，複製主畫布內容
            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = canvas.width;
            exportCanvas.height = canvas.height;
            const exportCtx = exportCanvas.getContext('2d');
            
            // 先繪製主畫布內容
            exportCtx.drawImage(canvas, 0, 0);
            
            // 過濾可見圖層的浮動物件
            const floatingRegions = state.regions.filter(r => 
                r.isFloating && r.floatingImage && isLayerVisible(r.layerIndex)
            );
            
            // 如果有浮動物件，依序繪製到匯出畫布
            if (floatingRegions.length > 0) {
                for (const r of floatingRegions) {
                    await new Promise((resolve, reject) => {
                        const img = new Image();
                        img.onload = () => {
                            const pad = r.padding || 5;
                            exportCtx.drawImage(img, r.x - pad, r.y - pad);
                            resolve();
                        };
                        img.onerror = () => {
                            console.warn('無法載入浮動物件圖片');
                            resolve(); // 即使失敗也繼續
                        };
                        img.src = r.floatingImage;
                    });
                }
            }
            
            // 繪製文字物件（textObjects — 文字輸入工具建立的物件）
            const visibleTextObjs = textObjects.filter(obj => isLayerVisible(obj.layerIndex));
            for (const obj of visibleTextObjs) {
                const padding = 15;
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = obj.width;
                tempCanvas.height = obj.height;
                const tctx = tempCanvas.getContext('2d');
                
                // 繪製背景
                if (obj.bgType !== 'none') {
                    tctx.fillStyle = obj.bgColor;
                    if (obj.bgType === 'rounded') {
                        tctx.beginPath();
                        tctx.roundRect(0, 0, obj.width, obj.height, 8);
                        tctx.fill();
                    } else {
                        tctx.fillRect(0, 0, obj.width, obj.height);
                    }
                }
                
                drawTextWithEffects(tctx, obj, padding);
                exportCtx.drawImage(tempCanvas, obj.x, obj.y);
            }
            
            return exportCanvas;
        }

        async function downloadImage() {
            if (!state.image) return;
            
            const format = state.exportFormat || 'png';
            const quality = state.exportQuality || 0.92;
            
            let mimeType, ext;
            switch (format) {
                case 'jpeg':
                    mimeType = 'image/jpeg';
                    ext = 'jpg';
                    break;
                case 'webp':
                    mimeType = 'image/webp';
                    ext = 'webp';
                    break;
                default:
                    mimeType = 'image/png';
                    ext = 'png';
            }
            
            // 取得包含浮動物件的匯出畫布
            const exportCanvas = await getExportCanvas();
            
            const link = document.createElement('a');
            link.download = `edited_${Date.now()}.${ext}`;
            link.href = exportCanvas.toDataURL(mimeType, quality);
            link.click();
            
            toast(`圖片已下載 (${format.toUpperCase()})`, 'success');
            closeDownloadMenu();
        }
        
        function toggleDownloadMenu() {
            const menu = document.getElementById('download-menu');
            menu.classList.toggle('show');
            
            // 點擊其他地方關閉選單
            if (menu.classList.contains('show')) {
                setTimeout(() => {
                    document.addEventListener('click', closeDownloadMenuOnClickOutside);
                }, 10);
            }
        }
        
        function closeDownloadMenu() {
            document.getElementById('download-menu').classList.remove('show');
            document.removeEventListener('click', closeDownloadMenuOnClickOutside);
        }
        
        function closeDownloadMenuOnClickOutside(e) {
            const dropdown = document.getElementById('download-dropdown');
            if (!dropdown.contains(e.target)) {
                closeDownloadMenu();
            }
        }
        
        async function downloadImageJpg() {
            if (!state.image) return;
            
            // 取得包含浮動物件的匯出畫布
            const exportCanvas = await getExportCanvas();
            
            const link = document.createElement('a');
            link.download = `edited_${Date.now()}.jpg`;
            link.href = exportCanvas.toDataURL('image/jpeg', 0.92);
            link.click();
            
            toast('圖片已下載 (JPG)', 'success');
            closeDownloadMenu();
        }
        
        // WebP 格式下載
        async function downloadImageWebp() {
            if (!state.image) return;
            
            // 檢查瀏覽器是否支援 WebP
            const testCanvas = document.createElement('canvas');
            testCanvas.width = 1;
            testCanvas.height = 1;
            const isWebpSupported = testCanvas.toDataURL('image/webp').indexOf('data:image/webp') === 0;
            
            if (!isWebpSupported) {
                toast('您的瀏覽器不支援 WebP 格式，請使用 Chrome 或 Firefox', 'error');
                return;
            }
            
            // 取得包含浮動物件的匯出畫布
            const exportCanvas = await getExportCanvas();
            
            const link = document.createElement('a');
            link.download = `edited_${Date.now()}.webp`;
            link.href = exportCanvas.toDataURL('image/webp', 0.9);
            link.click();
            
            toast('圖片已下載 (WebP)，檔案較小', 'success');
            closeDownloadMenu();
        }
        
        // SVG 向量格式下載
        function downloadImageSvg() {
            if (!state.image) return;
            
            // 統計可編輯元素數量
            const editedRegionCount = state.regions.filter(r => r.edited && r.text && r.text.trim() && !r.isFloating && isLayerVisible(r.layerIndex)).length;
            const floatingTextCount = state.regions.filter(r => r.isFloating && r.text && isLayerVisible(r.layerIndex)).length;
            const textObjCount = textObjects.filter(obj => isLayerVisible(obj.layerIndex)).length;
            const gradientCount = (typeof gradientObjects !== 'undefined' ? gradientObjects : []).filter(obj => isLayerVisible(obj.layerIndex)).length;
            const editableCount = editedRegionCount + floatingTextCount + textObjCount;
            
            const dialog = document.createElement('div');
            dialog.id = 'svg-export-dialog';
            dialog.style.cssText = `
                position: fixed;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                background: #1a1a1a;
                border: 1px solid #444;
                border-radius: 12px;
                padding: 20px;
                z-index: 10001;
                min-width: 500px;
                max-width: 600px;
                max-height: 90vh;
                overflow-y: auto;
                box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            `;
            
            dialog.innerHTML = `
                <h3 style="margin:0 0 15px 0;display:flex;justify-content:space-between;align-items:center;">
                    <span>📐 SVG 匯出選項</span>
                    <button onclick="document.getElementById('svg-export-dialog').remove()" 
                        style="background:none;border:none;color:#fff;font-size:20px;cursor:pointer;">×</button>
                </h3>
                <div style="margin-bottom:15px;">
                    <div style="display:flex;flex-direction:column;gap:8px;">
                        
                        <label style="display:flex;align-items:flex-start;gap:8px;cursor:pointer;padding:10px;background:#1a2e1a;border:1px solid #2a5a2a;border-radius:6px;">
                            <input type="radio" name="svg-type" value="pptx-compat" checked style="margin-top:3px;">
                            <div>
                                <div style="color:#6bf66b;font-weight:bold;">🟢 PowerPoint / Office 相容</div>
                                <div style="font-size:11px;color:#aaa;margin-top:2px;">純向量 SVG（無內嵌圖片）— 可在 PowerPoint 中「轉換為圖形」後編輯文字</div>
                                <div style="font-size:11px;color:#6366f1;margin-top:2px;">📦 會同時下載：背景圖片(.png) + 純文字向量(.svg)</div>
                                <div style="font-size:10px;color:#888;margin-top:4px;">💡 使用方式：先在 PPT 插入 PNG 背景 → 再插入 SVG → 右鍵「轉換為圖形」</div>
                            </div>
                        </label>
                        
                        <label style="display:flex;align-items:flex-start;gap:8px;cursor:pointer;padding:10px;background:#2a2a2a;border-radius:6px;">
                            <input type="radio" name="svg-type" value="editable" style="margin-top:3px;">
                            <div>
                                <div style="color:#fff;">📝 Inkscape / Illustrator 用</div>
                                <div style="font-size:11px;color:#888;">背景圖片內嵌 + 文字為 SVG 向量（適合專業向量編輯軟體）</div>
                            </div>
                        </label>
                        
                        <label style="display:flex;align-items:flex-start;gap:8px;cursor:pointer;padding:10px;background:#2a2a2a;border-radius:6px;">
                            <input type="radio" name="svg-type" value="embedded" style="margin-top:3px;">
                            <div>
                                <div style="color:#fff;">🖼️ 合併為單一圖片</div>
                                <div style="font-size:11px;color:#888;">全部合併為一張點陣圖（不可編輯）</div>
                            </div>
                        </label>
                    </div>
                </div>
                ${editableCount > 0 ? `
                <div style="background:#1a1a2e;border:1px solid #333;border-radius:8px;padding:8px 10px;margin-bottom:12px;font-size:11px;">
                    <span style="color:#8b8bf6;">📌 偵測到：</span>
                    <span style="color:#ccc;">${editableCount} 個文字元素</span>
                    ${gradientCount > 0 ? `<span style="color:#ccc;"> + ${gradientCount} 個漸層形狀</span>` : ''}
                </div>` : ''}
                <div style="display:flex;gap:8px;justify-content:flex-end;">
                    <button onclick="document.getElementById('svg-export-dialog').remove()" class="btn btn-outline">取消</button>
                    <button onclick="exportSvg()" class="btn btn-primary">⬇️ 匯出</button>
                </div>
            `;
            
            document.body.appendChild(dialog);
            closeDownloadMenu();
        }
        
        // 取得不含可編輯文字的背景畫布（供 SVG 背景用）
        // 做法比照 PPTX：用 bgColor 填掉已編輯的文字區域，再由 SVG <text> 元素重新呈現
        async function getBackgroundCanvasForSvg() {
            const bgCanvas = document.createElement('canvas');
            bgCanvas.width = canvas.width;
            bgCanvas.height = canvas.height;
            const bgCtx = bgCanvas.getContext('2d');
            
            // 繪製主畫布（含所有已 committed 的內容）
            bgCtx.drawImage(canvas, 0, 0);
            
            // 繪製浮動「圖像」區塊（套索/魔術棒等非文字的浮動選取）
            if (state.imageRegions && state.imageRegions.length > 0) {
                for (const ir of state.imageRegions) {
                    if (!isLayerVisible(ir.layerIndex) || !ir.imageData) continue;
                    await new Promise(resolve => {
                        const img = new Image();
                        img.onload = () => {
                            bgCtx.drawImage(img, ir.x, ir.y, ir.w, ir.h);
                            resolve();
                        };
                        img.onerror = () => resolve();
                        img.src = ir.imageData;
                    });
                }
            }
            
            // ★ 用 bgColor 擦除「非浮動已編輯區塊」的文字（烤進 canvas 的部分）
            //   這樣 SVG 背景就不會有重複的文字
            for (const r of state.regions) {
                if (r.edited && r.text && r.text.trim() && !r.isFloating && isLayerVisible(r.layerIndex)) {
                    const pad = r.padding || 5;
                    bgCtx.fillStyle = r.bgColor || '#ffffff';
                    bgCtx.fillRect(
                        Math.max(0, r.x - pad),
                        Math.max(0, r.y - pad),
                        r.w + pad * 2,
                        r.h + pad * 2
                    );
                }
            }
            
            // ★ 浮動文字區塊（isFloating）不繪製 — 由 SVG 元素表示
            // ★ 文字物件（textObjects）不繪製 — 由 SVG 元素表示
            
            return bgCanvas;
        }
        
        // 將文字區塊（浮動或非浮動已編輯）轉為 SVG 元素
        function regionToSvg(r) {
            let svgParts = '';
            const text = stripColorTags(r.text || '');
            if (!text.trim()) return '';
            
            const fontFamily = r.fontFamily || 'Noto Sans TC, sans-serif';
            const fontSize = r.fontSize || 16;
            const fontWeight = r.fontWeight || '400';
            const color = r.color || '#000000';
            const direction = r.direction || 'horizontal';
            const rotation = r.rotation || 0;
            
            // 群組開始
            const groupLabel = escapeXml(text.substring(0, 30));
            svgParts += `        <g id="region-${r.id}" inkscape:label="文字: ${groupLabel}"`;
            if (rotation !== 0) {
                const cx = r.x + r.w / 2;
                const cy = r.y + r.h / 2;
                svgParts += ` transform="rotate(${rotation}, ${cx}, ${cy})"`;
            }
            svgParts += `>\n`;
            
            // 背景矩形（若非透明背景）
            if (!r.transparentBg && r.bgColor) {
                const pad = r.padding || 5;
                svgParts += `            <rect x="${r.x - pad}" y="${r.y - pad}" width="${r.w + pad*2}" height="${r.h + pad*2}" fill="${r.bgColor}" opacity="1"/>\n`;
            }
            
            // 描邊屬性
            let strokeAttr = '';
            if (r.strokeWidth > 0) {
                strokeAttr = ` stroke="${r.strokeColor || '#000'}" stroke-width="${r.strokeWidth}" paint-order="stroke"`;
            }
            
            const lines = text.split('\n');
            
            if (direction === 'vertical') {
                const colWidth = fontSize * 1.5;
                const startX = r.x + r.w - colWidth / 2;
                lines.forEach((line, colIndex) => {
                    const chars = [...line];
                    const x = startX - colIndex * colWidth;
                    const totalHeight = chars.length * fontSize * 1.2;
                    const startY = r.y + (r.h - totalHeight) / 2 + fontSize / 2;
                    chars.forEach((char, ci) => {
                        const vertChar = r.verticalPunctFix !== false ? getVerticalChar(char) : char;
                        const cy = startY + ci * fontSize * 1.2;
                        svgParts += `            <text x="${x}" y="${cy + fontSize * 0.35}" font-family="${escapeXml(fontFamily)}" font-size="${fontSize}" font-weight="${fontWeight}" fill="${color}" text-anchor="middle"${strokeAttr}>${escapeXml(vertChar)}</text>\n`;
                    });
                });
            } else {
                const lineHeight = fontSize * (r.lineHeight || 1.2);
                const scaleY = r.scaleY || 1;
                const totalHeight = lines.length * lineHeight * scaleY;
                const startY = r.y + (r.h - totalHeight) / 2 + lineHeight * scaleY / 2;
                const textAlign = r.textAlign || 'left';
                
                lines.forEach((line, i) => {
                    const ly = startY + i * lineHeight * scaleY;
                    let tx, anchor;
                    switch (textAlign) {
                        case 'center':
                            tx = r.x + r.w / 2;
                            anchor = 'middle';
                            break;
                        case 'right':
                            tx = r.x + r.w - 4;
                            anchor = 'end';
                            break;
                        default:
                            tx = r.x + 4;
                            anchor = 'start';
                    }
                    svgParts += `            <text x="${tx}" y="${ly + fontSize * 0.35}" font-family="${escapeXml(fontFamily)}" font-size="${fontSize}" font-weight="${fontWeight}" fill="${color}" text-anchor="${anchor}"${strokeAttr}>${escapeXml(line)}</text>\n`;
                });
            }
            
            svgParts += `        </g>\n`;
            return svgParts;
        }
        
        // 將文字物件轉為 SVG 元素
        function textObjectToSvg(obj) {
            let svgParts = '';
            const text = obj.text || '';
            if (!text.trim()) return '';
            
            const fontFamily = obj.font || 'Noto Sans TC, sans-serif';
            const fontSize = obj.size || 16;
            const fontWeight = obj.weight || 'normal';
            const color = obj.color || '#000000';
            const direction = obj.direction || 'horizontal';
            const padding = 15;
            
            const groupLabel = escapeXml(text.substring(0, 30));
            svgParts += `        <g id="textobj-${obj.id}" inkscape:label="文字: ${groupLabel}">\n`;
            
            // 陰影/發光 filter（放在 group 內）
            let filterId = '';
            if (obj.shadow) {
                filterId = `shadow-${obj.id}`;
                svgParts += `            <defs><filter id="${filterId}" x="-20%" y="-20%" width="140%" height="140%"><feDropShadow dx="${obj.shadow.x}" dy="${obj.shadow.y}" stdDeviation="${obj.shadow.blur/2}" flood-color="${obj.shadow.color}"/></filter></defs>\n`;
            }
            if (obj.glow) {
                filterId = `glow-${obj.id}`;
                svgParts += `            <defs><filter id="${filterId}" x="-30%" y="-30%" width="160%" height="160%"><feGaussianBlur stdDeviation="${obj.glow.size/2}" result="blur"/><feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge></filter></defs>\n`;
            }
            const filterAttr = filterId ? ` filter="url(#${filterId})"` : '';
            
            // 背景
            if (obj.bgType && obj.bgType !== 'none') {
                if (obj.bgType === 'rounded') {
                    svgParts += `            <rect x="${obj.x}" y="${obj.y}" width="${obj.width}" height="${obj.height}" rx="8" fill="${obj.bgColor || '#ffffff'}"/>\n`;
                } else {
                    svgParts += `            <rect x="${obj.x}" y="${obj.y}" width="${obj.width}" height="${obj.height}" fill="${obj.bgColor || '#ffffff'}"/>\n`;
                }
            }
            
            // 描邊屬性
            let strokeAttr = '';
            if (obj.stroke > 0) {
                strokeAttr = ` stroke="${obj.strokeColor || '#000'}" stroke-width="${obj.stroke}" paint-order="stroke"`;
            }
            if (obj.outline) {
                strokeAttr = ` stroke="${obj.outline.color}" stroke-width="${obj.outline.width}" paint-order="stroke"`;
            }
            
            const lines = text.split('\n');
            const lineHeight = fontSize * 1.3;
            
            if (direction === 'vertical') {
                let colX = obj.x + obj.width - padding - fontSize;
                lines.forEach((line, lineIdx) => {
                    const chars = [...line];
                    chars.forEach((char, ci) => {
                        const charY = obj.y + padding + ci * fontSize * 1.2;
                        svgParts += `            <text x="${colX + fontSize/2}" y="${charY + fontSize}" font-family="${escapeXml(fontFamily)}" font-size="${fontSize}" font-weight="${fontWeight}" fill="${color}" text-anchor="middle"${strokeAttr}${filterAttr}>${escapeXml(char)}</text>\n`;
                    });
                    colX -= fontSize * 1.5;
                });
            } else {
                lines.forEach((line, i) => {
                    const lineY = obj.y + padding + i * lineHeight + fontSize;
                    svgParts += `            <text x="${obj.x + padding}" y="${lineY}" font-family="${escapeXml(fontFamily)}" font-size="${fontSize}" font-weight="${fontWeight}" fill="${color}"${strokeAttr}${filterAttr}>${escapeXml(line)}</text>\n`;
                });
            }
            
            svgParts += `        </g>\n`;
            return svgParts;
        }
        
        // 執行 SVG 匯出
        async function exportSvg() {
            const svgType = document.querySelector('input[name="svg-type"]:checked')?.value || 'pptx-compat';
            document.getElementById('svg-export-dialog')?.remove();
            
            showLoading('匯出 SVG 中...');
            
            try {
                const W = canvas.width;
                const H = canvas.height;
                const ts = Date.now();
                
                // 收集所有文字元素
                const editedRegions = state.regions.filter(r => 
                    r.edited && r.text && r.text.trim() && !r.isFloating && isLayerVisible(r.layerIndex)
                );
                const floatingTextRegions = state.regions.filter(r => 
                    r.isFloating && r.text && r.text.trim() && isLayerVisible(r.layerIndex)
                );
                const visibleTextObjs = textObjects.filter(obj => isLayerVisible(obj.layerIndex));
                const visibleGradients = (typeof gradientObjects !== 'undefined' ? gradientObjects : []).filter(obj => isLayerVisible(obj.layerIndex));
                
                // 生成文字圖層 SVG 內容（三種模式共用）
                let textLayerContent = '';
                editedRegions.forEach(r => { textLayerContent += regionToSvg(r); });
                floatingTextRegions.forEach(r => { textLayerContent += regionToSvg(r); });
                visibleTextObjs.forEach(obj => { textLayerContent += textObjectToSvg(obj); });
                
                // 漸層 defs + shapes
                let defsContent = '';
                let gradientShapes = '';
                visibleGradients.forEach((obj, idx) => {
                    const gradId = `grad${idx}`;
                    if (obj.type === 'radial') {
                        defsContent += `    <radialGradient id="${gradId}"><stop offset="0%" style="stop-color:${obj.color1};stop-opacity:${obj.opacity}"/><stop offset="100%" style="stop-color:${obj.color2};stop-opacity:${obj.opacity}"/></radialGradient>\n`;
                    } else {
                        defsContent += `    <linearGradient id="${gradId}" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" style="stop-color:${obj.color1};stop-opacity:${obj.opacity}"/><stop offset="100%" style="stop-color:${obj.color2};stop-opacity:${obj.opacity}"/></linearGradient>\n`;
                    }
                    switch (obj.shape) {
                        case 'circle':
                            const r = Math.min(obj.width, obj.height) / 2;
                            gradientShapes += `    <circle cx="${obj.x + obj.width/2}" cy="${obj.y + obj.height/2}" r="${r}" fill="url(#${gradId})"/>\n`;
                            break;
                        case 'ellipse':
                            gradientShapes += `    <ellipse cx="${obj.x + obj.width/2}" cy="${obj.y + obj.height/2}" rx="${obj.width/2}" ry="${obj.height/2}" fill="url(#${gradId})"/>\n`;
                            break;
                        case 'roundRect':
                            const cr = Math.min(obj.width, obj.height) * 0.15;
                            gradientShapes += `    <rect x="${obj.x}" y="${obj.y}" width="${obj.width}" height="${obj.height}" rx="${cr}" fill="url(#${gradId})"/>\n`;
                            break;
                        default:
                            gradientShapes += `    <rect x="${obj.x}" y="${obj.y}" width="${obj.width}" height="${obj.height}" fill="url(#${gradId})"/>\n`;
                    }
                });
                
                const textCount = (textLayerContent.match(/<text /g) || []).length;
                
                if (svgType === 'pptx-compat') {
                    // ========================================
                    // PowerPoint 相容模式
                    // 1. 下載背景 PNG
                    // 2. 下載純向量 SVG（無 <image>）
                    // ========================================
                    
                    // Step 1: 背景 PNG（含浮動圖片但不含文字）
                    const bgCanvas = await getBackgroundCanvasForSvg();
                    const bgLink = document.createElement('a');
                    bgLink.download = `background_${ts}.png`;
                    bgLink.href = bgCanvas.toDataURL('image/png');
                    bgLink.click();
                    
                    // 短暫延遲確保第一個下載啟動
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // Step 2: 純向量 SVG（僅文字 + 漸層，完全無 <image>）
                    //   PowerPoint 可以對這個 SVG 做「轉換為圖形」
                    
                    // ★ 清理所有 PPT 不支援的屬性：
                    //   - inkscape:*/sodipodi:* 命名空間屬性（無宣告=無效XML）
                    //   - paint-order（SVG 2.0）
                    //   - filter="url(...)" 和 <defs><filter>...（SVG filter 效果）
                    //   - <feDropShadow>（SVG 2.0）
                    function cleanForPptx(svgStr) {
                        return svgStr
                            .replace(/\s*inkscape:[a-z\-]+="[^"]*"/gi, '')
                            .replace(/\s*sodipodi:[a-z\-]+="[^"]*"/gi, '')
                            .replace(/\s*paint-order="[^"]*"/g, '')
                            .replace(/\s*filter="url\([^)]*\)"/g, '')
                            .replace(/<defs>\s*<filter[^]*?<\/filter>\s*<\/defs>\s*\n?/g, '');
                    }
                    
                    const cleanTextContent = cleanForPptx(textLayerContent);
                    const cleanGradientShapes = cleanForPptx(gradientShapes);
                    
                    const pureSvg = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" width="${W}" height="${H}" viewBox="0 0 ${W} ${H}">
${defsContent ? `  <defs>\n${defsContent}  </defs>\n` : ''}${cleanTextContent}${cleanGradientShapes}
</svg>`;
                    
                    const svgBlob = new Blob([pureSvg], { type: 'image/svg+xml;charset=utf-8' });
                    const svgUrl = URL.createObjectURL(svgBlob);
                    const svgLink = document.createElement('a');
                    svgLink.download = `text_layer_${ts}.svg`;
                    svgLink.href = svgUrl;
                    svgLink.click();
                    setTimeout(() => URL.revokeObjectURL(svgUrl), 3000);
                    
                    hideLoading();
                    toast(`已下載 2 個檔案：背景 PNG + 文字 SVG（${textCount} 個文字元素）\n▸ PPT 使用：先插入 PNG → 再插入 SVG → 右鍵「轉換為圖形」`, 'success', 6000);
                    
                } else if (svgType === 'embedded') {
                    // ========================================
                    // 合併為單一圖片
                    // ========================================
                    const exportCanvas = await getExportCanvas();
                    const dataUrl = exportCanvas.toDataURL('image/png');
                    const svgContent = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" 
     width="${W}" height="${H}" viewBox="0 0 ${W} ${H}">
    <image width="${W}" height="${H}" xlink:href="${dataUrl}"/>
</svg>`;
                    
                    const blob = new Blob([svgContent], { type: 'image/svg+xml;charset=utf-8' });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.download = `merged_${ts}.svg`;
                    link.href = url;
                    link.click();
                    setTimeout(() => URL.revokeObjectURL(url), 3000);
                    
                    hideLoading();
                    toast('SVG 已匯出（合併圖片，不可編輯）', 'success');
                    
                } else {
                    // ========================================
                    // Inkscape / Illustrator 用（含內嵌背景 + 文字分層）
                    // ========================================
                    const bgCanvas = await getBackgroundCanvasForSvg();
                    const bgDataUrl = bgCanvas.toDataURL('image/png');
                    
                    const svgContent = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" 
     xmlns:xlink="http://www.w3.org/1999/xlink"
     xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
     xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.0.dtd"
     width="${W}" height="${H}" viewBox="0 0 ${W} ${H}">
    <title>ECF Export - ${textCount} editable text</title>
${defsContent ? `    <defs>\n${defsContent}    </defs>\n` : ''}
    <g inkscape:groupmode="layer" inkscape:label="背景 Background" id="layer-bg" sodipodi:insensitive="true">
        <image id="bg-image" width="${W}" height="${H}" xlink:href="${bgDataUrl}"/>
    </g>
    <g inkscape:groupmode="layer" inkscape:label="文字 Text" id="layer-text">
${textLayerContent}    </g>
${gradientShapes ? `    <g inkscape:groupmode="layer" inkscape:label="漸層 Gradients" id="layer-grad">\n${gradientShapes}    </g>\n` : ''}
</svg>`;
                    
                    const blob = new Blob([svgContent], { type: 'image/svg+xml;charset=utf-8' });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.download = `editable_${ts}.svg`;
                    link.href = url;
                    link.click();
                    setTimeout(() => URL.revokeObjectURL(url), 3000);
                    
                    hideLoading();
                    toast(`SVG 已匯出（${textCount} 個可編輯文字）— 請用 Inkscape/Illustrator 開啟`, 'success');
                }
                
                console.log(`[SVG Export] mode=${svgType}, texts=${textCount}`);
                
            } catch (err) {
                hideLoading();
                console.error('[SVG Export Error]', err);
                toast(`SVG 匯出失敗: ${err.message}`, 'error');
            }
        }
        
        // XML 特殊字元跳脫
        function escapeXml(str) {
            return str.replace(/[<>&'"]/g, c => {
                switch (c) {
                    case '<': return '&lt;';
                    case '>': return '&gt;';
                    case '&': return '&amp;';
                    case "'": return '&apos;';
                    case '"': return '&quot;';
                }
            });
        }
        
        async function downloadAllImages() {
            if (state.pdfPages.length <= 1) {
                downloadImage();
                return;
            }
            
            // 取得包含浮動物件的匯出畫布
            const exportCanvas = await getExportCanvas();
            
            // 保存當前頁面編輯（使用 JPEG 減少記憶體）
            state.pdfPages[state.currentPdfPage].editedData = exportCanvas.toDataURL('image/jpeg', 0.92);
            state.pdfPages[state.currentPdfPage].regions = JSON.parse(JSON.stringify(state.regions));
            
            showLoading('準備下載所有頁面...');
            
            try {
                for (let i = 0; i < state.pdfPages.length; i++) {
                    setProgress(Math.round((i / state.pdfPages.length) * 100));
                    
                    const pageData = state.pdfPages[i];
                    const imgData = pageData.editedData || pageData.dataUrl;
                    
                    // 創建下載連結
                    const link = document.createElement('a');
                    link.download = `page_${i + 1}_${Date.now()}.png`;
                    link.href = imgData;
                    link.click();
                    
                    // 延遲避免瀏覽器阻擋多次下載
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
                
                hideLoading();
                toast(`已下載 ${state.pdfPages.length} 頁`, 'success');
                
            } catch (e) {
                // console.error(e);
                hideLoading();
                toast('下載失敗', 'error');
            }
            
            closeDownloadMenu();
        }
        
        async function downloadAsPdf() {
            if (!state.image) {
                toast('請先載入圖片', 'error');
                return;
            }
            
            showLoading('載入 PDF 引擎中...');
            
            // 延遲載入 jsPDF
            const loaded = await loadJsPDF();
            if (!loaded) {
                hideLoading();
                toast('無法載入 PDF 引擎', 'error');
                return;
            }
            
            showLoading('生成 PDF 中...');
            
            try {
                const { jsPDF } = window.jspdf;
                
                // 取得包含浮動物件的匯出畫布
                const exportCanvas = await getExportCanvas();
                
                // 如果有多頁 PDF
                if (state.pdfPages.length > 1) {
                    // 保存當前頁面編輯（包含浮動物件）
                    state.pdfPages[state.currentPdfPage].editedData = exportCanvas.toDataURL('image/jpeg', 0.92);
                    state.pdfPages[state.currentPdfPage].regions = JSON.parse(JSON.stringify(state.regions));
                    
                    // 使用第一頁決定方向
                    const firstPage = state.pdfPages[0];
                    const firstDataUrl = firstPage.editedData || firstPage.dataUrl;
                    const img = await loadImageFromUrl(firstDataUrl);
                    const orientation = img.width > img.height ? 'landscape' : 'portrait';
                    
                    const pdf = new jsPDF({
                        orientation: orientation,
                        unit: 'px',
                        format: [img.width, img.height],
                        compress: true
                    });
                    
                    for (let i = 0; i < state.pdfPages.length; i++) {
                        showLoading(`生成 PDF 中... (${i + 1}/${state.pdfPages.length})`);
                        setProgress(Math.round((i / state.pdfPages.length) * 100));
                        
                        const pageData = state.pdfPages[i];
                        
                        // 使用壓縮的 JPEG 格式減少數據量
                        let pageDataUrl = pageData.editedData || pageData.dataUrl;
                        
                        // 如果是 PNG 格式，轉換為 JPEG 以減少大小
                        if (pageDataUrl.indexOf('image/png') > -1) {
                            const tempImg = await loadImageFromUrl(pageDataUrl);
                            const tempCanvas = document.createElement('canvas');
                            tempCanvas.width = tempImg.width;
                            tempCanvas.height = tempImg.height;
                            const tempCtx = tempCanvas.getContext('2d');
                            tempCtx.fillStyle = '#ffffff';
                            tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                            tempCtx.drawImage(tempImg, 0, 0);
                            pageDataUrl = tempCanvas.toDataURL('image/jpeg', 0.92);
                        }
                        
                        const pageImg = await loadImageFromUrl(pageDataUrl);
                        
                        if (i > 0) {
                            pdf.addPage([pageImg.width, pageImg.height], pageImg.width > pageImg.height ? 'landscape' : 'portrait');
                        }
                        
                        // 使用 addImage 並指定壓縮
                        pdf.addImage(
                            pageImg,  // 使用 Image 對象而不是 DataURL 字符串
                            'JPEG',
                            0, 0,
                            pageImg.width,
                            pageImg.height,
                            undefined,
                            'FAST'  // 使用快速壓縮
                        );
                        
                        // 釋放記憶體
                        await new Promise(resolve => setTimeout(resolve, 10));
                    }
                    
                    showLoading('儲存 PDF 中...');
                    pdf.save(`document_${Date.now()}.pdf`);
                    
                } else {
                    // 單頁
                    // 單頁 - 使用已取得的 exportCanvas
                    const orientation = exportCanvas.width > exportCanvas.height ? 'landscape' : 'portrait';
                    
                    const pdf = new jsPDF({
                        orientation: orientation,
                        unit: 'px',
                        format: [exportCanvas.width, exportCanvas.height],
                        compress: true
                    });
                    
                    // 轉換為 JPEG 減少大小
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = exportCanvas.width;
                    tempCanvas.height = exportCanvas.height;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.fillStyle = '#ffffff';
                    tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                    tempCtx.drawImage(exportCanvas, 0, 0);
                    
                    const imgData = tempCanvas.toDataURL('image/jpeg', 0.92);
                    const img = await loadImageFromUrl(imgData);
                    
                    pdf.addImage(
                        img,
                        'JPEG',
                        0, 0,
                        exportCanvas.width,
                        exportCanvas.height,
                        undefined,
                        'FAST'
                    );
                    
                    pdf.save(`image_${Date.now()}.pdf`);
                }
                
                hideLoading();
                toast('PDF 已下載', 'success');
                
            } catch (e) {
                console.error('PDF export error:', e);
                hideLoading();
                toast('PDF 生成失敗: ' + e.message, 'error');
            }
            
            closeDownloadMenu();
        }
        
        function updateDownloadOptions() {
            const hasMultiPages = state.pdfPages.length > 1;
            
            document.getElementById('btn-download-all').style.display = hasMultiPages ? 'block' : 'none';
            document.getElementById('btn-download-pdf').style.display = 'block'; // 始終顯示 PDF 選項
            document.getElementById('pdf-export-divider').style.display = hasMultiPages ? 'block' : 'none';
        }
        
        async function downloadCurrentPage() {
            if (!state.image) return;
            
            // 取得包含浮動物件的匯出畫布
            const exportCanvas = await getExportCanvas();
            
            // 保存當前頁面編輯狀態（使用 JPEG 減少記憶體）
            if (state.pdfPages.length > 1) {
                state.pdfPages[state.currentPdfPage].editedData = exportCanvas.toDataURL('image/jpeg', 0.92);
                state.pdfPages[state.currentPdfPage].regions = JSON.parse(JSON.stringify(state.regions));
            }
            
            const pageNum = state.currentPdfPage + 1;
            const link = document.createElement('a');
            link.download = `page_${pageNum}_${Date.now()}.png`;
            link.href = exportCanvas.toDataURL('image/png');
            link.click();
            
            toast(`第 ${pageNum} 頁已下載`, 'success');
        }

        function openUpload() {
            document.getElementById('upload-modal').classList.remove('hidden');
        }

        function showLoading(text) {
            document.getElementById('loading-text').textContent = text;
            document.getElementById('loading-bar').style.width = '0%';
            document.getElementById('loading').classList.remove('hidden');
        }

        function hideLoading() {
            document.getElementById('loading').classList.add('hidden');
        }

        function setProgress(p) {
            document.getElementById('loading-bar').style.width = p + '%';
        }
        
        // 使對話框可拖拉
        function makeDraggable(dialog, handleSelector) {
            const handle = handleSelector ? dialog.querySelector(handleSelector) : dialog.querySelector('h3');
            if (!handle) return;
            
            handle.style.cursor = 'move';
            handle.style.userSelect = 'none';
            
            let isDragging = false;
            let startX, startY, startLeft, startTop;
            
            handle.addEventListener('mousedown', (e) => {
                // 不處理按鈕點擊
                if (e.target.tagName === 'BUTTON') return;
                
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                
                const rect = dialog.getBoundingClientRect();
                startLeft = rect.left;
                startTop = rect.top;
                
                // 改為絕對定位
                dialog.style.position = 'fixed';
                dialog.style.left = startLeft + 'px';
                dialog.style.top = startTop + 'px';
                dialog.style.transform = 'none';
                dialog.style.margin = '0';
                
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                
                let newLeft = startLeft + dx;
                let newTop = startTop + dy;
                
                // 限制在視窗內
                const maxLeft = window.innerWidth - dialog.offsetWidth;
                const maxTop = window.innerHeight - dialog.offsetHeight;
                
                newLeft = Math.max(0, Math.min(maxLeft, newLeft));
                newTop = Math.max(0, Math.min(maxTop, newTop));
                
                dialog.style.left = newLeft + 'px';
                dialog.style.top = newTop + 'px';
            });
            
            document.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            // 添加拖拉提示圖標
            const dragIcon = document.createElement('span');
            dragIcon.innerHTML = '⋮⋮';
            dragIcon.style.cssText = `
                margin-right: 8px;
                color: #666;
                font-size: 14px;
                cursor: move;
            `;
            handle.insertBefore(dragIcon, handle.firstChild);
        }

        function toast(msg, type = 'success') {
            const wrap = document.getElementById('toasts');
            const t = document.createElement('div');
            t.className = 'toast ' + type;
            t.textContent = msg;
            wrap.appendChild(t);
            setTimeout(() => { t.style.opacity = '0'; setTimeout(() => t.remove(), 200); }, 2500);
        }
        
        // ============ 圖層管理系統 ============
        
        // 圖層數據結構
        let layers = [];
        let activeLayerIndex = 0;
        let layerSystemInitialized = false;
        let isPreviewMode = false; // 是否正在預覽多圖層合成
        
        // 檢查物件所屬圖層是否可見
        function isLayerVisible(layerIndex) {
            // 如果圖層系統未初始化，或者沒有圖層，預設可見
            if (!layerSystemInitialized || layers.length === 0) return true;
            // 如果沒有指定圖層索引，預設可見
            if (layerIndex === undefined || layerIndex === null) return true;
            // 如果圖層索引超出範圍，預設可見
            if (layerIndex < 0 || layerIndex >= layers.length) return true;
            // 返回圖層的可見狀態
            return layers[layerIndex].visible;
        }
        
        // 圖層拖拉相關
        let layerDragMode = false;
        let draggingLayerIndex = -1;
        let layerDragStart = { x: 0, y: 0 };
        let layerOriginalOffset = { x: 0, y: 0 };
        let layerDragScale = { x: 1, y: 1 };
        
        // 開啟/關閉圖層拖拉模式
        function toggleLayerDragMode() {
            layerDragMode = !layerDragMode;
            
            if (layerDragMode) {
                // 進入拖拉模式，先確保在預覽模式
                if (!isPreviewMode) {
                    const visibleCount = layers.filter(l => l.visible).length;
                    if (visibleCount > 1) {
                        syncCanvasToCurrentLayer();
                        renderAllVisibleLayers();
                    } else {
                        toast('需要至少2個可見圖層才能使用拖拉功能', 'warning');
                        layerDragMode = false;
                        return;
                    }
                }
                canvas.style.cursor = 'move';
                toast('🖐️ 拖拉模式已開啟：點擊並拖動圖層來調整位置', 'info');
            } else {
                canvas.style.cursor = 'crosshair';
                toast('拖拉模式已關閉', 'info');
            }
            
            updateLayerPanel();
        }
        
        // 圖層拖拉開始
        function startLayerDrag(e) {
            if (!layerDragMode || !isPreviewMode) return false;
            
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;
            
            // 計算當前合成的偏移補償
            const size = calculateMergedSize();
            const baseOffsetX = size.offsetX || 0;
            const baseOffsetY = size.offsetY || 0;
            
            // 從頂層往底層找，看點擊到哪個圖層
            for (let i = layers.length - 1; i >= 0; i--) {
                const layer = layers[i];
                if (!layer.visible) continue;
                
                // 圖層在合成畫布中的實際位置
                const drawX = (layer.offsetX || 0) - baseOffsetX;
                const drawY = (layer.offsetY || 0) - baseOffsetY;
                
                if (x >= drawX && x <= drawX + layer.width && y >= drawY && y <= drawY + layer.height) {
                    draggingLayerIndex = i;
                    layerDragStart = { x: e.clientX, y: e.clientY };
                    layerOriginalOffset = { x: layer.offsetX || 0, y: layer.offsetY || 0 };
                    // 記錄縮放比例
                    layerDragScale = { x: scaleX, y: scaleY };
                    canvas.style.cursor = 'grabbing';
                    toast(`開始拖動: ${layer.name}`, 'info');
                    return true;
                }
            }
            
            return false;
        }
        
        // 圖層拖拉中
        function doLayerDrag(e) {
            if (!layerDragMode || draggingLayerIndex < 0) return false;
            
            // 使用記錄的縮放比例
            const dx = (e.clientX - layerDragStart.x) * layerDragScale.x;
            const dy = (e.clientY - layerDragStart.y) * layerDragScale.y;
            
            layers[draggingLayerIndex].offsetX = Math.round(layerOriginalOffset.x + dx);
            layers[draggingLayerIndex].offsetY = Math.round(layerOriginalOffset.y + dy);
            
            // 即時重新渲染
            renderAllVisibleLayers();
            
            return true;
        }
        
        // 圖層拖拉結束
        function endLayerDrag() {
            if (draggingLayerIndex >= 0) {
                const layer = layers[draggingLayerIndex];
                toast(`${layer.name} 位置: (${layer.offsetX || 0}, ${layer.offsetY || 0})`, 'success');
                draggingLayerIndex = -1;
                canvas.style.cursor = 'move';
                updateLayerPanel();
            }
        }
        
        // 初始化圖層系統
        function initLayerSystem() {
            if (layerSystemInitialized) return;
            if (!canvas.width || !canvas.height) return;
            
            // 創建背景圖層並複製當前畫布
            const bgCanvas = document.createElement('canvas');
            bgCanvas.width = canvas.width;
            bgCanvas.height = canvas.height;
            const bgCtx = bgCanvas.getContext('2d');
            bgCtx.drawImage(canvas, 0, 0);
            
            layers = [{
                id: Date.now(),
                name: '圖層 1',
                canvas: bgCanvas,
                width: canvas.width,
                height: canvas.height,
                visible: true,
                opacity: 1,
                offsetX: 0,
                offsetY: 0
            }];
            activeLayerIndex = 0;
            layerSystemInitialized = true;
            isPreviewMode = false;
            updateLayerPanel();
        }
        
        // 切換圖層面板
        function toggleLayerPanel() {
            const panel = document.getElementById('layer-panel');
            panel.classList.toggle('show');
            
            if (panel.classList.contains('show')) {
                if (!layerSystemInitialized && state.image) {
                    initLayerSystem();
                }
                // 只有非預覽模式才同步
                if (!isPreviewMode) {
                    syncCanvasToCurrentLayer();
                }
                updateLayerPanel();
            }
        }
        
        // 同步主畫布內容到當前圖層（僅在編輯模式下）
        function syncCanvasToCurrentLayer() {
            // 如果正在預覽多圖層，不要同步（避免覆蓋圖層內容）
            if (isPreviewMode) return;
            
            if (layers.length === 0 || activeLayerIndex < 0) return;
            const layer = layers[activeLayerIndex];
            if (!layer) return;
            
            // 只有當畫布尺寸與圖層尺寸相同時才同步
            // 避免在預覽合成後的畫布覆蓋原始圖層
            if (canvas.width === layer.width && canvas.height === layer.height) {
                const layerCtx = layer.canvas.getContext('2d');
                layerCtx.clearRect(0, 0, layer.canvas.width, layer.canvas.height);
                layerCtx.drawImage(canvas, 0, 0);
            }
        }
        
        // 更新圖層面板顯示
        function updateLayerPanel() {
            const list = document.getElementById('layer-list');
            
            if (layers.length === 0) {
                list.innerHTML = '<div style="padding:20px;text-align:center;color:#666;">請先載入圖片</div>';
                return;
            }
            
            // 更新拖拉按鈕狀態
            const dragBtn = document.getElementById('layer-drag-btn');
            if (dragBtn) {
                if (layerDragMode) {
                    dragBtn.classList.remove('btn-outline');
                    dragBtn.classList.add('btn-primary');
                    dragBtn.textContent = '🖐️ 拖拉中';
                } else {
                    dragBtn.classList.remove('btn-primary');
                    dragBtn.classList.add('btn-outline');
                    dragBtn.textContent = '🖐️ 拖拉';
                }
            }
            
            // 反向顯示（頂層在上面，底層在下面）
            const reversedLayers = [...layers].reverse();
            const reversedIndices = layers.map((_, i) => layers.length - 1 - i);
            
            list.innerHTML = `
                <div style="font-size:10px;color:#666;padding:4px 8px;border-bottom:1px solid #333;">
                    ⬆️ 頂層（覆蓋在上面）${isPreviewMode ? ' - 預覽模式' : ''}${layerDragMode ? ' - 🖐️拖拉模式' : ''}
                </div>
            ` + reversedLayers.map((layer, displayIndex) => {
                const realIndex = reversedIndices[displayIndex];
                const offsetX = layer.offsetX || 0;
                const offsetY = layer.offsetY || 0;
                const hasOffset = offsetX !== 0 || offsetY !== 0;
                return `
                <div class="layer-item ${realIndex === activeLayerIndex ? 'active' : ''}" onclick="selectLayer(${realIndex})">
                    <div class="layer-item-preview">
                        <canvas id="layer-preview-${realIndex}" width="50" height="50"></canvas>
                    </div>
                    <div class="layer-item-info">
                        <div class="layer-item-name">${layer.name} ${realIndex === activeLayerIndex ? '✏️' : ''}</div>
                        <div style="font-size:10px;color:#888;">
                            ${layer.width} × ${layer.height} px
                            ${hasOffset ? `<span style="color:#6cf;"> 位置(${offsetX},${offsetY})</span>` : ''}
                        </div>
                        <div style="display:flex;align-items:center;gap:4px;margin-top:2px;">
                            <span style="font-size:10px;color:#aaa;">透明度:</span>
                            <input type="range" min="0" max="100" value="${Math.round(layer.opacity * 100)}" 
                                style="width:60px;height:4px;" 
                                onclick="event.stopPropagation()"
                                oninput="setLayerOpacity(${realIndex}, this.value/100)">
                            <span style="font-size:10px;color:#aaa;width:28px;">${Math.round(layer.opacity * 100)}%</span>
                        </div>
                    </div>
                    <div class="layer-item-actions">
                        <button onclick="event.stopPropagation();toggleLayerVisibility(${realIndex})" 
                            title="${layer.visible ? '隱藏' : '顯示'}" 
                            style="background:${layer.visible ? '#4a4' : '#666'}">${layer.visible ? '👁️' : '🚫'}</button>
                        <button onclick="event.stopPropagation();scaleLayer(${realIndex})" 
                            title="縮放">🔍</button>
                        <button onclick="event.stopPropagation();rotateLayer(${realIndex})" 
                            title="旋轉">🔄</button>
                        <button onclick="event.stopPropagation();removeLayerBackground(${realIndex})" 
                            title="去背" style="${layer.hasTransparency ? 'background:#6a6' : ''}">✂️</button>
                        <button onclick="event.stopPropagation();resetLayerOffset(${realIndex})" 
                            title="重置位置" style="${hasOffset ? 'background:#c66' : ''}">📍</button>
                        <button onclick="event.stopPropagation();showLayerMenu(event,${realIndex})" 
                            title="更多選項">⋯</button>
                    </div>
                </div>
            `}).join('') + `
                <div style="font-size:10px;color:#666;padding:4px 8px;border-top:1px solid #333;">
                    ⬇️ 底層（被覆蓋在下面）
                </div>
            `;
            
            // 繪製縮圖（保持原始比例）
            setTimeout(() => {
                layers.forEach((layer, index) => {
                    const previewCanvas = document.getElementById(`layer-preview-${index}`);
                    if (previewCanvas && layer.canvas && layer.canvas.width > 0) {
                        const pctx = previewCanvas.getContext('2d');
                        // 棋盤格背景表示透明
                        pctx.fillStyle = '#444';
                        pctx.fillRect(0, 0, 50, 50);
                        for (let y = 0; y < 50; y += 5) {
                            for (let x = 0; x < 50; x += 5) {
                                if ((x + y) % 10 === 0) {
                                    pctx.fillStyle = '#555';
                                    pctx.fillRect(x, y, 5, 5);
                                }
                            }
                        }
                        // 保持原始比例繪製縮圖
                        const scale = Math.min(50 / layer.canvas.width, 50 / layer.canvas.height);
                        const w = layer.canvas.width * scale;
                        const h = layer.canvas.height * scale;
                        pctx.drawImage(layer.canvas, (50 - w) / 2, (50 - h) / 2, w, h);
                    }
                });
            }, 10);
        }
        
        // 重置圖層位置
        function resetLayerOffset(index) {
            layers[index].offsetX = 0;
            layers[index].offsetY = 0;
            
            // 如果在預覽模式，重新渲染
            if (isPreviewMode) {
                renderAllVisibleLayers();
            }
            
            updateLayerPanel();
            toast(`${layers[index].name} 位置已重置`, 'info');
        }
        
        // 圖層縮放功能
        function scaleLayer(index) {
            const layer = layers[index];
            if (!layer || !layer.canvas) {
                toast('圖層無效', 'error');
                return;
            }
            
            const currentW = layer.width;
            const currentH = layer.height;
            
            const scaleOption = prompt(
                `目前尺寸: ${currentW} × ${currentH}\n\n` +
                '請選擇縮放方式：\n' +
                '1. 輸入百分比（如 50 或 150）\n' +
                '2. 輸入新寬度（如 w800）\n' +
                '3. 輸入新高度（如 h600）\n' +
                '4. 輸入新尺寸（如 800x600）\n' +
                '5. 輸入 fit:寬x高 等比縮放至範圍內（如 fit:500x500）',
                '100'
            );
            
            if (!scaleOption) return;
            
            let newWidth, newHeight;
            
            if (scaleOption.startsWith('w')) {
                // 按寬度縮放
                newWidth = parseInt(scaleOption.slice(1));
                newHeight = Math.round(currentH * (newWidth / currentW));
            } else if (scaleOption.startsWith('h')) {
                // 按高度縮放
                newHeight = parseInt(scaleOption.slice(1));
                newWidth = Math.round(currentW * (newHeight / currentH));
            } else if (scaleOption.includes('x')) {
                // 指定尺寸
                const parts = scaleOption.replace('fit:', '').split('x');
                const targetW = parseInt(parts[0]);
                const targetH = parseInt(parts[1]);
                
                if (scaleOption.startsWith('fit:')) {
                    // 等比縮放至範圍內
                    const scale = Math.min(targetW / currentW, targetH / currentH);
                    newWidth = Math.round(currentW * scale);
                    newHeight = Math.round(currentH * scale);
                } else {
                    // 直接指定尺寸（可能變形）
                    newWidth = targetW;
                    newHeight = targetH;
                }
            } else {
                // 百分比縮放
                const percent = parseInt(scaleOption);
                if (percent <= 0 || percent > 1000) {
                    toast('縮放比例需在 1-1000% 之間', 'warning');
                    return;
                }
                newWidth = Math.round(currentW * percent / 100);
                newHeight = Math.round(currentH * percent / 100);
            }
            
            if (!newWidth || !newHeight || newWidth < 1 || newHeight < 1) {
                toast('無效的尺寸', 'error');
                return;
            }
            
            toast('正在縮放...', 'info');
            
            setTimeout(() => {
                try {
                    // 創建新的畫布
                    const newCanvas = document.createElement('canvas');
                    newCanvas.width = newWidth;
                    newCanvas.height = newHeight;
                    const newCtx = newCanvas.getContext('2d');
                    
                    // 使用高品質縮放
                    newCtx.imageSmoothingEnabled = true;
                    newCtx.imageSmoothingQuality = 'high';
                    
                    // 繪製縮放後的圖像
                    newCtx.drawImage(layer.canvas, 0, 0, newWidth, newHeight);
                    
                    // 更新圖層
                    layer.canvas = newCanvas;
                    layer.width = newWidth;
                    layer.height = newHeight;
                    
                    // 如果在預覽模式，重新渲染
                    if (isPreviewMode) {
                        renderAllVisibleLayers();
                    } else if (index === activeLayerIndex) {
                        // 如果是當前編輯的圖層，更新主畫布
                        canvas.width = newWidth;
                        canvas.height = newHeight;
                        ctx.drawImage(newCanvas, 0, 0);
                        state.image = { width: newWidth, height: newHeight };
                    }
                    
                    updateLayerPanel();
                    toast(`${layer.name} 已縮放至 ${newWidth}×${newHeight}`, 'success');
                    
                } catch (err) {
                    toast('縮放失敗: ' + err.message, 'error');
                }
            }, 100);
        }
        
        // 圖層旋轉功能
        function rotateLayer(index) {
            const layer = layers[index];
            if (!layer || !layer.canvas) {
                toast('圖層無效', 'error');
                return;
            }
            
            const angle = prompt(
                '請輸入旋轉角度：\n' +
                '• 正數為順時針（如 90）\n' +
                '• 負數為逆時針（如 -90）\n' +
                '• 常用: 90, 180, 270, -90',
                '90'
            );
            
            if (!angle) return;
            
            const degrees = parseFloat(angle);
            if (isNaN(degrees)) {
                toast('請輸入有效的角度', 'warning');
                return;
            }
            
            toast('正在旋轉...', 'info');
            
            setTimeout(() => {
                try {
                    const radians = degrees * Math.PI / 180;
                    const cos = Math.abs(Math.cos(radians));
                    const sin = Math.abs(Math.sin(radians));
                    
                    // 計算旋轉後的尺寸
                    const newWidth = Math.round(layer.width * cos + layer.height * sin);
                    const newHeight = Math.round(layer.width * sin + layer.height * cos);
                    
                    // 創建新畫布
                    const newCanvas = document.createElement('canvas');
                    newCanvas.width = newWidth;
                    newCanvas.height = newHeight;
                    const newCtx = newCanvas.getContext('2d');
                    
                    // 移動到中心，旋轉，再移回
                    newCtx.translate(newWidth / 2, newHeight / 2);
                    newCtx.rotate(radians);
                    newCtx.drawImage(layer.canvas, -layer.width / 2, -layer.height / 2);
                    
                    // 更新圖層
                    layer.canvas = newCanvas;
                    layer.width = newWidth;
                    layer.height = newHeight;
                    
                    // 更新顯示
                    if (isPreviewMode) {
                        renderAllVisibleLayers();
                    } else if (index === activeLayerIndex) {
                        canvas.width = newWidth;
                        canvas.height = newHeight;
                        ctx.drawImage(newCanvas, 0, 0);
                        state.image = { width: newWidth, height: newHeight };
                    }
                    
                    updateLayerPanel();
                    toast(`${layer.name} 已旋轉 ${degrees}°`, 'success');
                    
                } catch (err) {
                    toast('旋轉失敗: ' + err.message, 'error');
                }
            }, 100);
        }
        
        // 圖層翻轉功能
        function flipLayer(index, direction) {
            const layer = layers[index];
            if (!layer || !layer.canvas) {
                toast('圖層無效', 'error');
                return;
            }
            
            try {
                const newCanvas = document.createElement('canvas');
                newCanvas.width = layer.width;
                newCanvas.height = layer.height;
                const newCtx = newCanvas.getContext('2d');
                
                if (direction === 'h') {
                    // 水平翻轉
                    newCtx.translate(layer.width, 0);
                    newCtx.scale(-1, 1);
                } else {
                    // 垂直翻轉
                    newCtx.translate(0, layer.height);
                    newCtx.scale(1, -1);
                }
                
                newCtx.drawImage(layer.canvas, 0, 0);
                layer.canvas = newCanvas;
                
                // 更新顯示
                if (isPreviewMode) {
                    renderAllVisibleLayers();
                } else if (index === activeLayerIndex) {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(newCanvas, 0, 0);
                }
                
                updateLayerPanel();
                toast(`${layer.name} 已${direction === 'h' ? '水平' : '垂直'}翻轉`, 'success');
                
            } catch (err) {
                toast('翻轉失敗: ' + err.message, 'error');
            }
        }
        
        // 顯示圖層選項菜單
        function showLayerMenu(event, index) {
            event.stopPropagation();
            
            // 移除已存在的菜單
            const existingMenu = document.getElementById('layer-context-menu');
            if (existingMenu) existingMenu.remove();
            
            const layer = layers[index];
            
            // 創建菜單
            const menu = document.createElement('div');
            menu.id = 'layer-context-menu';
            menu.style.cssText = `
                position: fixed;
                left: ${event.clientX}px;
                top: ${event.clientY}px;
                background: #2a2a2a;
                border: 1px solid #444;
                border-radius: 8px;
                padding: 8px 0;
                min-width: 160px;
                z-index: 10000;
                box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            `;
            
            const menuItems = [
                { icon: '▲', text: '上移圖層', action: () => moveLayerUp(index), disabled: index >= layers.length - 1 },
                { icon: '▼', text: '下移圖層', action: () => moveLayerDown(index), disabled: index <= 0 },
                { type: 'divider' },
                { icon: '🔍', text: '縮放大小', action: () => scaleLayer(index) },
                { icon: '🔄', text: '旋轉角度', action: () => rotateLayer(index) },
                { icon: '↔️', text: '水平翻轉', action: () => flipLayer(index, 'h') },
                { icon: '↕️', text: '垂直翻轉', action: () => flipLayer(index, 'v') },
                { type: 'divider' },
                { icon: '✂️', text: '去除背景', action: () => removeLayerBackground(index) },
                { icon: '🌫️', text: '羽化邊緣', action: () => featherLayerEdge(index) },
                { icon: '📍', text: '重置位置', action: () => resetLayerOffset(index) },
                { type: 'divider' },
                { icon: '📝', text: '重新命名', action: () => renameLayer(index) },
                { icon: '📋', text: '複製圖層', action: () => duplicateLayer(index) },
                { icon: '🗑️', text: '刪除圖層', action: () => deleteLayer(index), style: 'color:#f66' }
            ];
            
            menuItems.forEach(item => {
                if (item.type === 'divider') {
                    const divider = document.createElement('div');
                    divider.style.cssText = 'height:1px;background:#444;margin:6px 0;';
                    menu.appendChild(divider);
                } else {
                    const btn = document.createElement('div');
                    btn.style.cssText = `
                        padding: 8px 16px;
                        cursor: ${item.disabled ? 'not-allowed' : 'pointer'};
                        display: flex;
                        align-items: center;
                        gap: 10px;
                        font-size: 13px;
                        opacity: ${item.disabled ? '0.4' : '1'};
                        ${item.style || ''}
                    `;
                    btn.innerHTML = `<span style="width:20px;text-align:center;">${item.icon}</span>${item.text}`;
                    
                    if (!item.disabled) {
                        btn.onmouseover = () => btn.style.background = '#3a3a3a';
                        btn.onmouseout = () => btn.style.background = 'transparent';
                        btn.onclick = () => {
                            menu.remove();
                            item.action();
                        };
                    }
                    menu.appendChild(btn);
                }
            });
            
            document.body.appendChild(menu);
            
            // 點擊其他地方關閉菜單
            setTimeout(() => {
                document.addEventListener('click', function closeMenu() {
                    menu.remove();
                    document.removeEventListener('click', closeMenu);
                });
            }, 10);
        }
        
        // 重新命名圖層
        function renameLayer(index) {
            const layer = layers[index];
            const newName = prompt('請輸入新的圖層名稱:', layer.name);
            if (newName && newName.trim()) {
                layer.name = newName.trim();
                updateLayerPanel();
                toast(`圖層已重新命名為: ${layer.name}`, 'success');
            }
        }
        
        // 複製圖層
        function duplicateLayer(index) {
            const layer = layers[index];
            
            // 複製畫布
            const newCanvas = document.createElement('canvas');
            newCanvas.width = layer.width;
            newCanvas.height = layer.height;
            newCanvas.getContext('2d').drawImage(layer.canvas, 0, 0);
            
            // 創建新圖層
            const newLayer = {
                id: Date.now(),
                name: layer.name + ' 副本',
                canvas: newCanvas,
                width: layer.width,
                height: layer.height,
                visible: true,
                opacity: layer.opacity,
                offsetX: (layer.offsetX || 0) + 20,
                offsetY: (layer.offsetY || 0) + 20,
                hasTransparency: layer.hasTransparency
            };
            
            // 插入到原圖層上方
            layers.splice(index + 1, 0, newLayer);
            
            // 更新活動索引
            if (activeLayerIndex > index) {
                activeLayerIndex++;
            }
            
            // 如果在預覽模式，重新渲染
            if (isPreviewMode) {
                renderAllVisibleLayers();
            }
            
            updateLayerPanel();
            toast(`已複製圖層: ${newLayer.name}`, 'success');
        }
        
        // 圖層去背功能
        function removeLayerBackground(index) {
            const layer = layers[index];
            if (!layer || !layer.canvas) {
                toast('圖層無效', 'error');
                return;
            }
            
            // 顯示選項
            const bgColor = prompt(
                '請選擇去背方式：\n' +
                '1. 輸入 "auto" 自動偵測背景色（從四角取樣）\n' +
                '2. 輸入 "white" 去除白色背景\n' +
                '3. 輸入 "black" 去除黑色背景\n' +
                '4. 輸入顏色代碼（如 #ffffff）去除指定顏色\n\n' +
                '容差值設定：在顏色後加數字（如 white 20 或 auto 40）\n' +
                '數值越大，去除範圍越廣（預設25）',
                'auto'
            );
            
            if (!bgColor) return;
            
            // 解析容差值
            let tolerance = 25;
            const parts = bgColor.trim().split(/\s+/);
            const colorPart = parts[0].toLowerCase();
            if (parts[1]) {
                const tol = parseInt(parts[1]);
                if (tol >= 1 && tol <= 100) {
                    tolerance = tol;
                }
            }
            
            toast('正在處理去背...', 'info');
            
            setTimeout(() => {
                try {
                    const layerCtx = layer.canvas.getContext('2d');
                    const imageData = layerCtx.getImageData(0, 0, layer.canvas.width, layer.canvas.height);
                    const data = imageData.data;
                    
                    let bgR, bgG, bgB;
                    
                    if (colorPart === 'auto') {
                        // 從四角和邊緣取樣
                        const w = layer.canvas.width;
                        const h = layer.canvas.height;
                        const samplePoints = [
                            { x: 0, y: 0 },
                            { x: w - 1, y: 0 },
                            { x: 0, y: h - 1 },
                            { x: w - 1, y: h - 1 },
                            { x: Math.floor(w/2), y: 0 },
                            { x: Math.floor(w/2), y: h - 1 },
                            { x: 0, y: Math.floor(h/2) },
                            { x: w - 1, y: Math.floor(h/2) }
                        ];
                        
                        const colorCounts = {};
                        samplePoints.forEach(c => {
                            const idx = (c.y * w + c.x) * 4;
                            const key = `${data[idx]},${data[idx+1]},${data[idx+2]}`;
                            colorCounts[key] = (colorCounts[key] || 0) + 1;
                        });
                        
                        const bgKey = Object.keys(colorCounts).reduce((a, b) => 
                            colorCounts[a] > colorCounts[b] ? a : b
                        );
                        [bgR, bgG, bgB] = bgKey.split(',').map(Number);
                        
                    } else if (colorPart === 'white') {
                        bgR = bgG = bgB = 255;
                    } else if (colorPart === 'black') {
                        bgR = bgG = bgB = 0;
                    } else if (colorPart.startsWith('#')) {
                        bgR = parseInt(colorPart.slice(1, 3), 16);
                        bgG = parseInt(colorPart.slice(3, 5), 16);
                        bgB = parseInt(colorPart.slice(5, 7), 16);
                    } else {
                        // 預設白色
                        bgR = bgG = bgB = 255;
                    }
                    
                    let removedCount = 0;
                    const maxDistance = tolerance * 4.41; // 色彩空間最大距離約441
                    
                    for (let i = 0; i < data.length; i += 4) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        
                        const distance = Math.sqrt(
                            Math.pow(r - bgR, 2) +
                            Math.pow(g - bgG, 2) +
                            Math.pow(b - bgB, 2)
                        );
                        
                        if (distance <= maxDistance) {
                            // 完全透明（不使用漸變，避免灰色邊緣）
                            data[i + 3] = 0;
                            removedCount++;
                        }
                    }
                    
                    layerCtx.putImageData(imageData, 0, 0);
                    
                    // 標記圖層已去背
                    layer.hasTransparency = true;
                    
                    // 如果是當前活動圖層，同步更新主畫布
                    if (index === activeLayerIndex && !isPreviewMode) {
                        // 清空主畫布並重繪（保持透明）
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        // 繪製去背後的圖層（不填充白色背景，保留透明度）
                        ctx.drawImage(layer.canvas, 0, 0);
                    }
                    
                    // 如果在預覽模式，重新渲染
                    if (isPreviewMode) {
                        renderAllVisibleLayers();
                    }
                    
                    updateLayerPanel();
                    toast(`${layer.name} 去背完成（容差${tolerance}），移除 ${removedCount} 個像素`, 'success');
                    
                } catch (err) {
                    toast('去背處理失敗: ' + err.message, 'error');
                }
            }, 100);
        }
        
        // 圖層羽化邊緣（讓去背更自然）
        function featherLayerEdge(index) {
            const layer = layers[index];
            if (!layer || !layer.canvas) return;
            
            const radius = parseInt(prompt('請輸入羽化半徑 (1-20 像素):', '3'));
            if (!radius || radius < 1 || radius > 20) return;
            
            toast('正在羽化邊緣...', 'info');
            
            setTimeout(() => {
                const layerCtx = layer.canvas.getContext('2d');
                const imageData = layerCtx.getImageData(0, 0, layer.canvas.width, layer.canvas.height);
                const data = imageData.data;
                const w = layer.canvas.width;
                const h = layer.canvas.height;
                
                // 複製 alpha 通道
                const alphaOriginal = new Uint8Array(w * h);
                for (let i = 0; i < w * h; i++) {
                    alphaOriginal[i] = data[i * 4 + 3];
                }
                
                // 對 alpha 通道進行模糊
                for (let y = 0; y < h; y++) {
                    for (let x = 0; x < w; x++) {
                        const idx = y * w + x;
                        
                        // 只處理邊緣（半透明區域附近）
                        if (alphaOriginal[idx] > 0 && alphaOriginal[idx] < 255) {
                            let sum = 0;
                            let count = 0;
                            
                            for (let dy = -radius; dy <= radius; dy++) {
                                for (let dx = -radius; dx <= radius; dx++) {
                                    const nx = x + dx;
                                    const ny = y + dy;
                                    if (nx >= 0 && nx < w && ny >= 0 && ny < h) {
                                        sum += alphaOriginal[ny * w + nx];
                                        count++;
                                    }
                                }
                            }
                            
                            data[idx * 4 + 3] = Math.round(sum / count);
                        }
                    }
                }
                
                layerCtx.putImageData(imageData, 0, 0);
                
                // 標記圖層有透明度
                layer.hasTransparency = true;
                
                // 如果是當前活動圖層，同步更新主畫布
                if (index === activeLayerIndex && !isPreviewMode) {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    // 不填充白色背景，保留透明度
                    ctx.drawImage(layer.canvas, 0, 0);
                }
                
                if (isPreviewMode) {
                    renderAllVisibleLayers();
                }
                
                updateLayerPanel();
                toast(`${layer.name} 邊緣已羽化`, 'success');
            }, 100);
        }
        
        // 選擇圖層 - 切換到該圖層的實際尺寸
        function selectLayer(index) {
            if (index === activeLayerIndex && !isPreviewMode) return;
            if (index < 0 || index >= layers.length) return;
            
            // 1. 如果不在預覽模式，保存當前畫布到當前圖層
            if (!isPreviewMode) {
                syncCanvasToCurrentLayer();
            }
            
            // 2. 退出預覽模式
            isPreviewMode = false;
            
            // 3. 切換活動圖層
            activeLayerIndex = index;
            
            // 4. 載入新圖層 - 使用該圖層的實際尺寸
            const layer = layers[index];
            
            // 調整畫布為該圖層的尺寸
            canvas.width = layer.width;
            canvas.height = layer.height;
            
            // 清除畫布（保持透明）
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 如果圖層沒有透明度（未去背），先填充白色背景
            if (!layer.hasTransparency) {
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            // 繪製圖層內容
            if (layer.canvas && layer.canvas.width > 0) {
                ctx.drawImage(layer.canvas, 0, 0);
            }
            
            // 更新狀態
            state.image = { width: layer.width, height: layer.height };
            
            updateLayerPanel();
            toast(`已切換到: ${layer.name} (${layer.width}×${layer.height})`, 'success');
        }
        
        // 切換圖層可見性 - 即時顯示疊圖效果
        function toggleLayerVisibility(index) {
            // 如果不在預覽模式，先保存當前編輯中的圖層
            if (!isPreviewMode) {
                syncCanvasToCurrentLayer();
            }
            
            // 切換可見性
            layers[index].visible = !layers[index].visible;
            
            // 計算可見圖層數量
            const visibleLayers = layers.filter(l => l.visible);
            
            if (visibleLayers.length === 0) {
                // 沒有可見圖層，清空畫布
                isPreviewMode = false;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                toast('所有圖層已隱藏', 'warning');
            } else if (visibleLayers.length === 1) {
                // 只有一個可見圖層，退出預覽模式，直接顯示該圖層
                isPreviewMode = false;
                const layer = visibleLayers[0];
                canvas.width = layer.width;
                canvas.height = layer.height;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                // 如果圖層沒有透明度（未去背），先填充白色背景
                if (!layer.hasTransparency) {
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
                if (layer.canvas && layer.canvas.width > 0) {
                    ctx.globalAlpha = layer.opacity;
                    ctx.drawImage(layer.canvas, 0, 0);
                    ctx.globalAlpha = 1;
                }
                state.image = { width: layer.width, height: layer.height };
                toast(layers[index].visible ? '圖層已顯示' : '圖層已隱藏', 'info');
            } else {
                // 多個可見圖層，進入預覽模式並合成顯示
                renderAllVisibleLayers();
                toast(`正在顯示 ${visibleLayers.length} 個圖層疊加效果`, 'info');
            }
            
            updateLayerPanel();
            
            // 重新渲染所有物件（根據圖層可見性過濾）
            renderRegions();
            renderImageRegions();
            renderTextObjects();
            renderGradientObjects();
        }
        
        // 計算所有可見圖層的合併尺寸
        function calculateMergedSize() {
            let minX = 0, minY = 0;
            let maxX = 0, maxY = 0;
            
            layers.forEach(layer => {
                if (layer.visible) {
                    const lx = layer.offsetX || 0;
                    const ly = layer.offsetY || 0;
                    
                    minX = Math.min(minX, lx);
                    minY = Math.min(minY, ly);
                    maxX = Math.max(maxX, lx + layer.width);
                    maxY = Math.max(maxY, ly + layer.height);
                }
            });
            
            return { 
                width: Math.max(1, maxX - minX) || canvas.width || 800, 
                height: Math.max(1, maxY - minY) || canvas.height || 600,
                offsetX: minX,
                offsetY: minY
            };
        }
        
        // 合成並顯示所有可見圖層（即時疊圖預覽）
        function renderAllVisibleLayers() {
            // 設置預覽模式，防止 syncCanvasToCurrentLayer 覆蓋圖層
            isPreviewMode = true;
            
            // 獲取所有可見圖層
            const visibleLayers = layers.filter(l => l.visible);
            if (visibleLayers.length === 0) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                return;
            }
            
            // 計算合併後的尺寸（包含偏移）
            const size = calculateMergedSize();
            
            // 調整畫布大小
            canvas.width = size.width;
            canvas.height = size.height;
            
            // 白色背景
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 從底層(索引0)到頂層(索引最大)依序繪製所有可見圖層
            for (let i = 0; i < layers.length; i++) {
                const layer = layers[i];
                if (layer.visible && layer.canvas && layer.canvas.width > 0) {
                    ctx.globalAlpha = layer.opacity;
                    // 使用圖層的偏移位置繪製，並補償整體偏移
                    const drawX = (layer.offsetX || 0) - (size.offsetX || 0);
                    const drawY = (layer.offsetY || 0) - (size.offsetY || 0);
                    ctx.drawImage(layer.canvas, drawX, drawY);
                }
            }
            ctx.globalAlpha = 1;
            
            // 更新狀態
            state.image = { width: size.width, height: size.height };
        }
        
        // 設置圖層透明度 - 即時預覽疊圖效果
        function setLayerOpacity(index, opacity) {
            layers[index].opacity = Math.max(0, Math.min(1, opacity));
            
            // 更新顯示的百分比
            const spans = document.querySelectorAll('.layer-item');
            if (spans[layers.length - 1 - index]) {
                const span = spans[layers.length - 1 - index].querySelector('span:last-of-type');
                if (span) span.textContent = Math.round(opacity * 100) + '%';
            }
            
            // 如果有多個可見圖層，即時預覽疊圖效果
            const visibleCount = layers.filter(l => l.visible).length;
            if (visibleCount > 1) {
                renderAllVisibleLayers();
            }
        }
        
        // 上移圖層（往頂層移動，會覆蓋在其他圖層上面）
        function moveLayerUp(index) {
            if (index >= layers.length - 1) return; // 已經是最頂層
            
            // 如果不在預覽模式，保存當前圖層
            if (!isPreviewMode) {
                syncCanvasToCurrentLayer();
            }
            
            // 交換位置（往上 = 往陣列尾端 = 頂層）
            [layers[index], layers[index + 1]] = [layers[index + 1], layers[index]];
            
            // 更新活動圖層索引
            if (activeLayerIndex === index) activeLayerIndex++;
            else if (activeLayerIndex === index + 1) activeLayerIndex--;
            
            updateLayerPanel();
            
            // 如果有多個可見圖層，即時預覽疊圖效果
            const visibleCount = layers.filter(l => l.visible).length;
            if (visibleCount > 1) {
                renderAllVisibleLayers();
            }
            
            toast('圖層已上移（更靠近頂層）', 'info');
        }
        
        // 下移圖層（往底層移動，會被其他圖層覆蓋）
        function moveLayerDown(index) {
            if (index <= 0) return; // 已經是最底層
            
            // 如果不在預覽模式，保存當前圖層
            if (!isPreviewMode) {
                syncCanvasToCurrentLayer();
            }
            
            // 交換位置（往下 = 往陣列前端 = 底層）
            [layers[index], layers[index - 1]] = [layers[index - 1], layers[index]];
            
            // 更新活動圖層索引
            if (activeLayerIndex === index) activeLayerIndex--;
            else if (activeLayerIndex === index - 1) activeLayerIndex++;
            
            updateLayerPanel();
            
            // 如果有多個可見圖層，即時預覽疊圖效果
            const visibleCount = layers.filter(l => l.visible).length;
            if (visibleCount > 1) {
                renderAllVisibleLayers();
            }
            
            toast('圖層已下移（更靠近底層）', 'info');
        }
        
        // 刪除圖層
        function deleteLayer(index) {
            if (layers.length <= 1) {
                toast('至少需要保留一個圖層', 'warning');
                return;
            }
            
            // 刪除屬於該圖層的所有圖像區塊
            if (state.imageRegions) {
                state.imageRegions = state.imageRegions.filter(r => r.layerIndex !== index);
                // 更新其他圖層的索引（比刪除的圖層大的索引都要減1）
                state.imageRegions.forEach(r => {
                    if (r.layerIndex > index) {
                        r.layerIndex--;
                    }
                });
            }
            
            // 刪除屬於該圖層的所有文字物件
            textObjects = textObjects.filter(t => t.layerIndex !== index);
            textObjects.forEach(t => {
                if (t.layerIndex > index) {
                    t.layerIndex--;
                }
            });
            
            // 刪除屬於該圖層的所有漸層物件
            gradientObjects = gradientObjects.filter(g => g.layerIndex !== index);
            gradientObjects.forEach(g => {
                if (g.layerIndex > index) {
                    g.layerIndex--;
                }
            });
            
            // 刪除屬於該圖層的所有 OCR 區塊
            state.regions = state.regions.filter(r => r.layerIndex !== index);
            state.regions.forEach(r => {
                if (r.layerIndex > index) {
                    r.layerIndex--;
                }
            });
            
            // 清除活動狀態
            if (state.activeImageRegion && state.activeImageRegion.layerIndex === index) {
                state.activeImageRegion = null;
            }
            if (state.activeRegion && state.activeRegion.layerIndex === index) {
                state.activeRegion = null;
            }
            
            layers.splice(index, 1);
            
            if (activeLayerIndex >= layers.length) {
                activeLayerIndex = layers.length - 1;
            } else if (activeLayerIndex > index) {
                activeLayerIndex--;
            }
            
            // 載入當前圖層
            const layer = layers[activeLayerIndex];
            canvas.width = layer.width;
            canvas.height = layer.height;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            if (layer.canvas && layer.canvas.width > 0) {
                ctx.drawImage(layer.canvas, 0, 0);
            }
            state.image = { width: layer.width, height: layer.height };
            
            // 重新渲染物件
            renderImageRegions();
            renderTextObjects();
            renderGradientObjects();
            renderRegions();
            
            updateLayerPanel();
            updatePanel();
            toast('圖層已刪除（包含相關物件）', 'success');
        }
        
        // 新增圖層（從檔案）
        function addNewLayer() {
            // 創建隱藏的 file input
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const img = new Image();
                img.onload = () => {
                    // 保存當前圖層
                    syncCanvasToCurrentLayer();
                    
                    // 創建新圖層
                    const newCanvas = document.createElement('canvas');
                    newCanvas.width = img.width;
                    newCanvas.height = img.height;
                    newCanvas.getContext('2d').drawImage(img, 0, 0);
                    
                    layers.push({
                        id: Date.now(),
                        name: `圖層 ${layers.length + 1}`,
                        canvas: newCanvas,
                        width: img.width,
                        height: img.height,
                        visible: true,
                        opacity: 1,
                        offsetX: 0,
                        offsetY: 0
                    });
                    
                    // 切換到新圖層
                    activeLayerIndex = layers.length - 1;
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);
                    state.image = { width: img.width, height: img.height };
                    
                    updateLayerPanel();
                    toast(`已新增圖層: ${img.width}×${img.height}`, 'success');
                };
                img.src = URL.createObjectURL(file);
            };
            input.click();
        }
        
        // 新增空白圖層
        function addEmptyLayer() {
            if (!state.image) {
                toast('請先載入圖片', 'warning');
                return;
            }
            
            syncCanvasToCurrentLayer();
            
            // 使用當前畫布尺寸
            const newCanvas = document.createElement('canvas');
            newCanvas.width = canvas.width;
            newCanvas.height = canvas.height;
            
            layers.push({
                id: Date.now(),
                name: `空白圖層 ${layers.length + 1}`,
                canvas: newCanvas,
                width: canvas.width,
                height: canvas.height,
                visible: true,
                opacity: 1,
                offsetX: 0,
                offsetY: 0
            });
            
            activeLayerIndex = layers.length - 1;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            updateLayerPanel();
            toast('已新增空白圖層', 'success');
        }
        
        // 合併所有圖層 - 可選擇尺寸模式
        function mergeAllLayers() {
            if (layers.length <= 1) {
                toast('只有一個圖層，無需合併', 'info');
                return;
            }
            
            // 如果不在預覽模式，先保存當前圖層
            if (!isPreviewMode) {
                syncCanvasToCurrentLayer();
            }
            
            // 詢問合併方式
            const visibleLayers = layers.filter(l => l.visible);
            if (visibleLayers.length === 0) {
                toast('沒有可見的圖層可合併', 'warning');
                return;
            }
            
            // 建立選項
            let options = '請選擇合併尺寸：\n';
            options += '1. 使用最大尺寸（包含所有圖層及位置）\n';
            layers.forEach((layer, i) => {
                if (layer.visible) {
                    options += `${i + 2}. 以「${layer.name}」為主 (${layer.width}×${layer.height})\n`;
                }
            });
            
            const choice = prompt(options, '1');
            if (!choice) return;
            
            // 詢問背景選項
            const bgChoice = prompt(
                '請選擇背景：\n' +
                '1. 白色背景\n' +
                '2. 透明背景（PNG格式）\n' +
                '3. 自訂顏色（輸入色碼如 #ff0000）',
                '1'
            );
            if (!bgChoice) return;
            
            const choiceNum = parseInt(choice);
            let targetWidth, targetHeight, baseOffsetX = 0, baseOffsetY = 0;
            
            if (choiceNum === 1) {
                // 使用最大尺寸（包含偏移）
                const size = calculateMergedSize();
                targetWidth = size.width;
                targetHeight = size.height;
                baseOffsetX = size.offsetX || 0;
                baseOffsetY = size.offsetY || 0;
            } else {
                // 以特定圖層為主
                const visibleIndex = choiceNum - 2;
                let count = 0;
                for (let i = 0; i < layers.length; i++) {
                    if (layers[i].visible) {
                        if (count === visibleIndex) {
                            targetWidth = layers[i].width;
                            targetHeight = layers[i].height;
                            break;
                        }
                        count++;
                    }
                }
            }
            
            if (!targetWidth || !targetHeight) {
                const size = calculateMergedSize();
                targetWidth = size.width;
                targetHeight = size.height;
                baseOffsetX = size.offsetX || 0;
                baseOffsetY = size.offsetY || 0;
            }
            
            saveHistory('合併圖層');
            
            // 合成所有可見圖層
            const mergedCanvas = document.createElement('canvas');
            mergedCanvas.width = targetWidth;
            mergedCanvas.height = targetHeight;
            const mergedCtx = mergedCanvas.getContext('2d');
            
            // 根據選擇設定背景
            if (bgChoice === '1') {
                mergedCtx.fillStyle = '#ffffff';
                mergedCtx.fillRect(0, 0, targetWidth, targetHeight);
            } else if (bgChoice === '2') {
                // 透明背景，不需要填充
            } else if (bgChoice.startsWith('#')) {
                mergedCtx.fillStyle = bgChoice;
                mergedCtx.fillRect(0, 0, targetWidth, targetHeight);
            } else {
                mergedCtx.fillStyle = '#ffffff';
                mergedCtx.fillRect(0, 0, targetWidth, targetHeight);
            }
            
            // 從底層到頂層依序繪製，補償基準偏移
            layers.forEach(layer => {
                if (layer.visible && layer.canvas && layer.canvas.width > 0) {
                    mergedCtx.globalAlpha = layer.opacity;
                    const drawX = (layer.offsetX || 0) - baseOffsetX;
                    const drawY = (layer.offsetY || 0) - baseOffsetY;
                    mergedCtx.drawImage(layer.canvas, drawX, drawY);
                }
            });
            mergedCtx.globalAlpha = 1;
            
            // 重置為單一圖層
            layers = [{
                id: Date.now(),
                name: '合併後圖層',
                canvas: mergedCanvas,
                width: targetWidth,
                height: targetHeight,
                visible: true,
                opacity: 1,
                offsetX: 0,
                offsetY: 0,
                hasTransparency: bgChoice === '2'
            }];
            activeLayerIndex = 0;
            layerSystemInitialized = true;
            isPreviewMode = false;
            layerDragMode = false;
            
            // 更新主畫布
            canvas.width = targetWidth;
            canvas.height = targetHeight;
            ctx.drawImage(mergedCanvas, 0, 0);
            state.image = { width: targetWidth, height: targetHeight };
            
            updateLayerPanel();
            toast(`已合併為 ${targetWidth}×${targetHeight}`, 'success');
        }
        
        // 預覽所有圖層合成結果
        function previewAllLayers() {
            if (layers.length === 0) {
                toast('尚無圖層', 'warning');
                return;
            }
            
            const visibleCount = layers.filter(l => l.visible).length;
            if (visibleCount === 0) {
                toast('沒有可見的圖層', 'warning');
                return;
            }
            
            // 如果不在預覽模式，先保存當前圖層
            if (!isPreviewMode) {
                syncCanvasToCurrentLayer();
            }
            
            renderAllVisibleLayers();
            const size = calculateMergedSize();
            toast(`預覽 ${visibleCount} 個圖層疊加效果: ${size.width}×${size.height}`, 'info');
        }
        
        // 返回編輯當前圖層
        function editCurrentLayer() {
            if (layers.length === 0) return;
            
            // 退出預覽模式
            isPreviewMode = false;
            
            const layer = layers[activeLayerIndex];
            canvas.width = layer.width;
            canvas.height = layer.height;
            
            // 白色背景
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 繪製圖層內容
            if (layer.canvas && layer.canvas.width > 0) {
                ctx.drawImage(layer.canvas, 0, 0);
            }
            state.image = { width: layer.width, height: layer.height };
            
            toast(`返回編輯: ${layer.name} (${layer.width}×${layer.height})`, 'info');
        }
        
        // ============ 克隆圖章工具 ============
        
        let cloneSource = null; // { x, y, set: false }
        let cloneOffset = { x: 0, y: 0 };
        
        function initCloneStamp(e) {
            if (!state.image) return;
            
            const rect = canvasContainer.getBoundingClientRect();
            const x = Math.round((e.clientX - rect.left) / state.displayScale);
            const y = Math.round((e.clientY - rect.top) / state.displayScale);
            
            const cloneSize = state.cloneSize || 30;
            const markerSize = cloneSize * state.displayScale;
            
            if (e.altKey) {
                // Alt + 點擊設定來源點
                cloneSource = { x, y, set: true };
                
                // 顯示來源標記（大小與筆刷同步）
                const marker = document.getElementById('clone-source-marker');
                marker.style.display = 'block';
                marker.style.left = (rect.left + x * state.displayScale - markerSize / 2) + 'px';
                marker.style.top = (rect.top + y * state.displayScale - markerSize / 2) + 'px';
                marker.style.width = markerSize + 'px';
                marker.style.height = markerSize + 'px';
                
                toast(`已設定克隆來源點 (${x}, ${y})，筆刷大小: ${cloneSize}px`, 'success');
            } else if (cloneSource && cloneSource.set) {
                // 開始繪製前保存歷史
                saveHistory('克隆圖章');
                // 計算偏移
                cloneOffset = { x: cloneSource.x - x, y: cloneSource.y - y };
                state.isDrawing = true;
            } else {
                toast('請先按住 Alt 鍵點擊設定來源點', 'warning');
            }
        }
        
        function doCloneStamp(e) {
            if (!state.isDrawing || !cloneSource || !cloneSource.set) return;
            
            const rect = canvasContainer.getBoundingClientRect();
            const x = Math.round((e.clientX - rect.left) / state.displayScale);
            const y = Math.round((e.clientY - rect.top) / state.displayScale);
            
            const sourceX = x + cloneOffset.x;
            const sourceY = y + cloneOffset.y;
            
            const cloneSize = state.cloneSize || 30;
            const markerSize = cloneSize * state.displayScale;
            
            // 更新來源標記位置和大小
            const marker = document.getElementById('clone-source-marker');
            if (marker) {
                marker.style.left = (rect.left + sourceX * state.displayScale - markerSize / 2) + 'px';
                marker.style.top = (rect.top + sourceY * state.displayScale - markerSize / 2) + 'px';
                marker.style.width = markerSize + 'px';
                marker.style.height = markerSize + 'px';
            }
            
            // 複製像素
            const halfSize = cloneSize / 2;
            
            try {
                // 確保來源範圍在畫布內
                const srcX = Math.max(0, Math.min(canvas.width - cloneSize, sourceX - halfSize));
                const srcY = Math.max(0, Math.min(canvas.height - cloneSize, sourceY - halfSize));
                
                const sourceData = ctx.getImageData(srcX, srcY, cloneSize, cloneSize);
                
                // 使用圓形筆刷
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = cloneSize;
                tempCanvas.height = cloneSize;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.putImageData(sourceData, 0, 0);
                
                ctx.save();
                ctx.beginPath();
                ctx.arc(x, y, halfSize, 0, Math.PI * 2);
                ctx.clip();
                ctx.drawImage(tempCanvas, x - halfSize, y - halfSize);
                ctx.restore();
            } catch (err) {
                // 超出邊界
            }
        }
        
        function endCloneStamp() {
            if (state.isDrawing) {
                state.isDrawing = false;
                updateUndoButton();
            }
        }
        
        // 設置克隆圖章大小
        function setCloneSize(size) {
            state.cloneSize = Math.max(5, Math.min(200, size));
            document.getElementById('clone-size-value').textContent = state.cloneSize + 'px';
            
            // 如果已有來源點，更新標記大小
            if (cloneSource && cloneSource.set) {
                const rect = canvasContainer.getBoundingClientRect();
                const marker = document.getElementById('clone-source-marker');
                const markerSize = state.cloneSize * state.displayScale;
                if (marker && marker.style.display !== 'none') {
                    const currentLeft = parseFloat(marker.style.left);
                    const currentTop = parseFloat(marker.style.top);
                    const currentSize = parseFloat(marker.style.width);
                    const centerX = currentLeft + currentSize / 2;
                    const centerY = currentTop + currentSize / 2;
                    marker.style.left = (centerX - markerSize / 2) + 'px';
                    marker.style.top = (centerY - markerSize / 2) + 'px';
                    marker.style.width = markerSize + 'px';
                    marker.style.height = markerSize + 'px';
                }
            }
        }
        
        // ============ 文字工具 ============
        
        function openTextTool(x, y) {
            // 創建文字輸入對話框
            const dialog = document.createElement('div');
            dialog.id = 'text-tool-dialog';
            dialog.style.cssText = `
                position: fixed;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                background: #1a1a1a;
                border: 1px solid #444;
                border-radius: 12px;
                padding: 20px;
                z-index: 10000;
                min-width: 500px;
                max-height: 90vh;
                overflow-y: auto;
                box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            `;
            
            dialog.innerHTML = `
                <h3 style="margin:0 0 15px 0;display:flex;justify-content:space-between;align-items:center;">
                    <span>✏️ 文字工具</span>
                    <button onclick="document.getElementById('text-tool-dialog').remove()" 
                        style="background:none;border:none;color:#fff;font-size:20px;cursor:pointer;">×</button>
                </h3>
                <div style="margin-bottom:12px;">
                    <label style="display:block;margin-bottom:4px;font-size:12px;color:#aaa;">文字內容</label>
                    <textarea id="text-input" rows="3" style="width:100%;padding:8px;background:#2a2a2a;border:1px solid #444;border-radius:6px;color:#fff;font-size:14px;resize:vertical;" placeholder="輸入文字..."></textarea>
                </div>
                <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:12px;margin-bottom:12px;">
                    <div>
                        <label style="display:block;margin-bottom:4px;font-size:12px;color:#aaa;">字型</label>
                        <select id="text-font" style="width:100%;padding:8px;background:#2a2a2a;border:1px solid #444;border-radius:6px;color:#fff;">
                            <option value="Inter">Inter</option>
                            <option value="Arial">Arial</option>
                            <option value="Helvetica">Helvetica</option>
                            <option value="Times New Roman">Times New Roman</option>
                            <option value="Georgia">Georgia</option>
                            <option value="Verdana">Verdana</option>
                            <option value="Microsoft JhengHei">微軟正黑體</option>
                            <option value="PingFang TC">蘋方-繁</option>
                            <option value="Noto Sans TC">Noto Sans TC</option>
                            <option value="serif">襯線體</option>
                            <option value="sans-serif">無襯線體</option>
                            <option value="monospace">等寬字體</option>
                            <option value="cursive">手寫體</option>
                        </select>
                    </div>
                    <div>
                        <label style="display:block;margin-bottom:4px;font-size:12px;color:#aaa;">字體大小</label>
                        <input type="number" id="text-size" value="24" min="8" max="200" style="width:100%;padding:8px;background:#2a2a2a;border:1px solid #444;border-radius:6px;color:#fff;">
                    </div>
                    <div>
                        <label style="display:block;margin-bottom:4px;font-size:12px;color:#aaa;">排列方向</label>
                        <select id="text-direction" style="width:100%;padding:8px;background:#2a2a2a;border:1px solid #444;border-radius:6px;color:#fff;">
                            <option value="horizontal">橫書 →</option>
                            <option value="vertical">直書 ↓</option>
                        </select>
                    </div>
                </div>
                <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:12px;margin-bottom:12px;">
                    <div>
                        <label style="display:block;margin-bottom:4px;font-size:12px;color:#aaa;">文字顏色</label>
                        <input type="color" id="text-color" value="#000000" style="width:100%;height:36px;border:none;border-radius:6px;cursor:pointer;">
                    </div>
                    <div>
                        <label style="display:block;margin-bottom:4px;font-size:12px;color:#aaa;">背景顏色</label>
                        <input type="color" id="text-bg-color" value="#ffffff" style="width:100%;height:36px;border:none;border-radius:6px;cursor:pointer;">
                    </div>
                    <div>
                        <label style="display:block;margin-bottom:4px;font-size:12px;color:#aaa;">背景</label>
                        <select id="text-bg-type" style="width:100%;padding:8px;background:#2a2a2a;border:1px solid #444;border-radius:6px;color:#fff;">
                            <option value="none">無背景</option>
                            <option value="solid">實色背景</option>
                            <option value="rounded">圓角背景</option>
                        </select>
                    </div>
                </div>
                <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:12px;margin-bottom:12px;">
                    <div>
                        <label style="display:block;margin-bottom:4px;font-size:12px;color:#aaa;">粗體</label>
                        <select id="text-weight" style="width:100%;padding:8px;background:#2a2a2a;border:1px solid #444;border-radius:6px;color:#fff;">
                            <option value="normal">正常</option>
                            <option value="bold">粗體</option>
                            <option value="100">細 100</option>
                            <option value="300">輕 300</option>
                            <option value="500">中 500</option>
                            <option value="700">粗 700</option>
                            <option value="900">黑 900</option>
                        </select>
                    </div>
                    <div>
                        <label style="display:block;margin-bottom:4px;font-size:12px;color:#aaa;">描邊寬度</label>
                        <input type="number" id="text-stroke" value="0" min="0" max="20" style="width:100%;padding:8px;background:#2a2a2a;border:1px solid #444;border-radius:6px;color:#fff;">
                    </div>
                    <div>
                        <label style="display:block;margin-bottom:4px;font-size:12px;color:#aaa;">描邊顏色</label>
                        <input type="color" id="text-stroke-color" value="#ffffff" style="width:100%;height:36px;border:none;border-radius:6px;cursor:pointer;">
                    </div>
                </div>
                
                <!-- 文字變形 -->
                <div style="border-top:1px solid #333;padding-top:12px;margin-bottom:12px;">
                    <label style="display:block;margin-bottom:8px;font-size:12px;color:#4a90d9;font-weight:bold;">🔄 文字變形</label>
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;">
                        <div>
                            <label style="display:block;margin-bottom:4px;font-size:12px;color:#aaa;">變形效果</label>
                            <select id="text-transform" style="width:100%;padding:8px;background:#2a2a2a;border:1px solid #444;border-radius:6px;color:#fff;">
                                <option value="none">無變形</option>
                                <option value="arc">弧形 ⌒</option>
                                <option value="arc-down">下弧形 ⌓</option>
                                <option value="wave">波浪 〰</option>
                                <option value="bulge">膨脹 ◯</option>
                                <option value="pinch">收縮 ◇</option>
                                <option value="flag">旗幟 🏴</option>
                                <option value="fish">魚形 🐟</option>
                            </select>
                        </div>
                        <div>
                            <label style="display:block;margin-bottom:4px;font-size:12px;color:#aaa;">變形強度: <span id="text-transform-value">50%</span></label>
                            <input type="range" id="text-transform-amount" min="0" max="100" value="50" 
                                oninput="document.getElementById('text-transform-value').textContent=this.value+'%'"
                                style="width:100%;">
                        </div>
                    </div>
                </div>
                
                <!-- 文字特效 -->
                <div style="border-top:1px solid #333;padding-top:12px;margin-bottom:12px;">
                    <label style="display:block;margin-bottom:8px;font-size:12px;color:#4a90d9;font-weight:bold;">✨ 文字特效</label>
                    <div style="display:grid;grid-template-columns:1fr 1fr 1fr 1fr;gap:8px;margin-bottom:10px;">
                        <label style="display:flex;align-items:center;gap:4px;font-size:12px;color:#ccc;cursor:pointer;">
                            <input type="checkbox" id="text-shadow-enable" onchange="document.getElementById('text-shadow-options').style.display=this.checked?'grid':'none'"> 陰影
                        </label>
                        <label style="display:flex;align-items:center;gap:4px;font-size:12px;color:#ccc;cursor:pointer;">
                            <input type="checkbox" id="text-glow-enable" onchange="document.getElementById('text-glow-options').style.display=this.checked?'grid':'none'"> 發光
                        </label>
                        <label style="display:flex;align-items:center;gap:4px;font-size:12px;color:#ccc;cursor:pointer;">
                            <input type="checkbox" id="text-outline-enable" onchange="document.getElementById('text-outline-options').style.display=this.checked?'grid':'none'"> 外框
                        </label>
                        <label style="display:flex;align-items:center;gap:4px;font-size:12px;color:#ccc;cursor:pointer;">
                            <input type="checkbox" id="text-3d-enable" onchange="document.getElementById('text-3d-options').style.display=this.checked?'grid':'none'"> 3D
                        </label>
                    </div>
                    
                    <!-- 陰影選項 -->
                    <div id="text-shadow-options" style="display:none;grid-template-columns:1fr 1fr 1fr 1fr;gap:8px;margin-bottom:8px;padding:8px;background:#252525;border-radius:6px;">
                        <div>
                            <label style="font-size:11px;color:#888;">X偏移</label>
                            <input type="number" id="text-shadow-x" value="3" style="width:100%;padding:4px;background:#333;border:1px solid #444;border-radius:4px;color:#fff;font-size:12px;">
                        </div>
                        <div>
                            <label style="font-size:11px;color:#888;">Y偏移</label>
                            <input type="number" id="text-shadow-y" value="3" style="width:100%;padding:4px;background:#333;border:1px solid #444;border-radius:4px;color:#fff;font-size:12px;">
                        </div>
                        <div>
                            <label style="font-size:11px;color:#888;">模糊</label>
                            <input type="number" id="text-shadow-blur" value="5" min="0" style="width:100%;padding:4px;background:#333;border:1px solid #444;border-radius:4px;color:#fff;font-size:12px;">
                        </div>
                        <div>
                            <label style="font-size:11px;color:#888;">顏色</label>
                            <input type="color" id="text-shadow-color" value="#000000" style="width:100%;height:26px;border:none;border-radius:4px;">
                        </div>
                    </div>
                    
                    <!-- 發光選項 -->
                    <div id="text-glow-options" style="display:none;grid-template-columns:1fr 1fr;gap:8px;margin-bottom:8px;padding:8px;background:#252525;border-radius:6px;">
                        <div>
                            <label style="font-size:11px;color:#888;">發光強度</label>
                            <input type="number" id="text-glow-size" value="10" min="1" max="50" style="width:100%;padding:4px;background:#333;border:1px solid #444;border-radius:4px;color:#fff;font-size:12px;">
                        </div>
                        <div>
                            <label style="font-size:11px;color:#888;">發光顏色</label>
                            <input type="color" id="text-glow-color" value="#ffff00" style="width:100%;height:26px;border:none;border-radius:4px;">
                        </div>
                    </div>
                    
                    <!-- 外框選項 -->
                    <div id="text-outline-options" style="display:none;grid-template-columns:1fr 1fr;gap:8px;margin-bottom:8px;padding:8px;background:#252525;border-radius:6px;">
                        <div>
                            <label style="font-size:11px;color:#888;">外框寬度</label>
                            <input type="number" id="text-outline-width" value="3" min="1" max="20" style="width:100%;padding:4px;background:#333;border:1px solid #444;border-radius:4px;color:#fff;font-size:12px;">
                        </div>
                        <div>
                            <label style="font-size:11px;color:#888;">外框顏色</label>
                            <input type="color" id="text-outline-color" value="#ffffff" style="width:100%;height:26px;border:none;border-radius:4px;">
                        </div>
                    </div>
                    
                    <!-- 3D選項 -->
                    <div id="text-3d-options" style="display:none;grid-template-columns:1fr 1fr 1fr;gap:8px;margin-bottom:8px;padding:8px;background:#252525;border-radius:6px;">
                        <div>
                            <label style="font-size:11px;color:#888;">深度</label>
                            <input type="number" id="text-3d-depth" value="5" min="1" max="20" style="width:100%;padding:4px;background:#333;border:1px solid #444;border-radius:4px;color:#fff;font-size:12px;">
                        </div>
                        <div>
                            <label style="font-size:11px;color:#888;">角度</label>
                            <select id="text-3d-angle" style="width:100%;padding:4px;background:#333;border:1px solid #444;border-radius:4px;color:#fff;font-size:12px;">
                                <option value="br">右下 ↘</option>
                                <option value="bl">左下 ↙</option>
                                <option value="tr">右上 ↗</option>
                                <option value="tl">左上 ↖</option>
                            </select>
                        </div>
                        <div>
                            <label style="font-size:11px;color:#888;">陰影顏色</label>
                            <input type="color" id="text-3d-color" value="#666666" style="width:100%;height:26px;border:none;border-radius:4px;">
                        </div>
                    </div>
                </div>
                
                <div style="background:#2a2a2a;padding:10px;border-radius:6px;margin-bottom:12px;">
                    <div style="font-size:11px;color:#888;margin-bottom:5px;">💡 提示：文字添加後可以拖拉移動位置，點擊 ✏️ 可編輯，點擊 × 可刪除</div>
                </div>
                <div style="display:flex;gap:8px;margin-bottom:12px;">
                    <button onclick="copyFontStyleFromTextDialog('text')" class="btn btn-outline" style="flex:1;font-size:11px;">🔤 複製字體樣式</button>
                    <button onclick="pasteFontStyleToTextDialog('text')" class="btn btn-outline" style="flex:1;font-size:11px;" ${state.copiedFontStyle ? '' : 'disabled'}>🔤 貼上字體樣式</button>
                </div>
                ${state.copiedFontStyle ? '<div style="margin-bottom:12px;padding:6px 10px;background:#1a1a2e;border:1px solid #6366f1;border-radius:6px;font-size:11px;color:#8b8bf6;">📌 已複製字體: ' + state.copiedFontStyle.fontFamily + ' / ' + state.copiedFontStyle.fontSize + 'px / ' + state.copiedFontStyle.color + '</div>' : ''}
                <div style="display:flex;gap:10px;justify-content:flex-end;">
                    <button onclick="document.getElementById('text-tool-dialog').remove()" class="btn btn-outline">取消</button>
                    <button onclick="createTextObject(${x}, ${y})" class="btn btn-primary">確定</button>
                </div>
            `;
            
            document.body.appendChild(dialog);
            makeDraggable(dialog);
            document.getElementById('text-input').focus();
        }
        
        // 文字物件陣列
        let textObjects = [];
        let activeTextObject = null;
        let textDragOffset = null;
        
        // 漸層物件陣列
        let gradientObjects = [];
        let activeGradientObject = null;
        let gradientDragOffset = null;
        
        // 創建文字物件（可拖拉）
        function createTextObject(x, y) {
            const text = document.getElementById('text-input').value;
            if (!text.trim()) {
                toast('請輸入文字', 'warning');
                return;
            }
            
            const textObj = {
                id: Date.now(),
                text: text,
                x: x,
                y: y,
                font: document.getElementById('text-font').value,
                size: parseInt(document.getElementById('text-size').value),
                color: document.getElementById('text-color').value,
                bgColor: document.getElementById('text-bg-color').value,
                bgType: document.getElementById('text-bg-type').value,
                weight: document.getElementById('text-weight').value,
                stroke: parseInt(document.getElementById('text-stroke').value),
                strokeColor: document.getElementById('text-stroke-color').value,
                // 新增：排列方向
                direction: document.getElementById('text-direction').value,
                // 新增：文字變形
                transform: document.getElementById('text-transform').value,
                transformAmount: parseInt(document.getElementById('text-transform-amount').value),
                // 新增：文字特效
                shadow: document.getElementById('text-shadow-enable').checked ? {
                    x: parseInt(document.getElementById('text-shadow-x').value),
                    y: parseInt(document.getElementById('text-shadow-y').value),
                    blur: parseInt(document.getElementById('text-shadow-blur').value),
                    color: document.getElementById('text-shadow-color').value
                } : null,
                glow: document.getElementById('text-glow-enable').checked ? {
                    size: parseInt(document.getElementById('text-glow-size').value),
                    color: document.getElementById('text-glow-color').value
                } : null,
                outline: document.getElementById('text-outline-enable').checked ? {
                    width: parseInt(document.getElementById('text-outline-width').value),
                    color: document.getElementById('text-outline-color').value
                } : null,
                effect3d: document.getElementById('text-3d-enable').checked ? {
                    depth: parseInt(document.getElementById('text-3d-depth').value),
                    angle: document.getElementById('text-3d-angle').value,
                    color: document.getElementById('text-3d-color').value
                } : null,
                layerIndex: activeLayerIndex // 記錄所屬圖層
            };
            
            // 計算文字尺寸
            ctx.font = `${textObj.weight} ${textObj.size}px "${textObj.font}"`;
            const lines = text.split('\n');
            let maxWidth = 0;
            lines.forEach(line => {
                const w = ctx.measureText(line).width;
                if (w > maxWidth) maxWidth = w;
            });
            
            // 根據排列方向計算尺寸
            if (textObj.direction === 'vertical') {
                // 直書：寬度為行數 * 字體大小，高度為最長行的字數 * 字體大小
                const maxChars = Math.max(...lines.map(l => l.length));
                textObj.width = lines.length * textObj.size * 1.5 + 16;
                textObj.height = maxChars * textObj.size * 1.2 + 16;
            } else {
                textObj.width = maxWidth + 16;
                textObj.height = lines.length * textObj.size * 1.3 + 16;
            }
            
            // 考慮特效需要的額外空間
            if (textObj.shadow || textObj.glow || textObj.effect3d) {
                textObj.width += 30;
                textObj.height += 30;
            }
            
            textObjects.push(textObj);
            document.getElementById('text-tool-dialog').remove();
            
            renderTextObjects();
            toast('文字已添加，可拖拉移動或點擊 × 刪除', 'success');
        }
        
        // 渲染所有文字物件
        function renderTextObjects() {
            // 移除舊的文字覆蓋層
            document.querySelectorAll('.text-object-overlay').forEach(el => el.remove());
            
            // 過濾只顯示可見圖層的物件
            textObjects.filter(obj => isLayerVisible(obj.layerIndex)).forEach(obj => {
                const overlay = document.createElement('div');
                overlay.className = 'text-object-overlay';
                overlay.dataset.id = obj.id;
                overlay.style.cssText = `
                    position: absolute;
                    left: ${obj.x}px;
                    top: ${obj.y}px;
                    cursor: move;
                    user-select: none;
                    border: 2px dashed transparent;
                    padding: 2px;
                    transition: border-color 0.2s;
                    z-index: 50;
                    pointer-events: auto;
                `;
                
                // 創建文字 canvas
                const textCanvas = document.createElement('canvas');
                const padding = 15;
                textCanvas.width = obj.width;
                textCanvas.height = obj.height;
                const tctx = textCanvas.getContext('2d');
                
                // 繪製背景
                if (obj.bgType !== 'none') {
                    tctx.fillStyle = obj.bgColor;
                    if (obj.bgType === 'rounded') {
                        tctx.beginPath();
                        tctx.roundRect(0, 0, obj.width, obj.height, 8);
                        tctx.fill();
                    } else {
                        tctx.fillRect(0, 0, obj.width, obj.height);
                    }
                }
                
                // 繪製文字（帶特效）
                drawTextWithEffects(tctx, obj, padding);
                
                overlay.appendChild(textCanvas);
                
                // 刪除按鈕
                const deleteBtn = document.createElement('button');
                deleteBtn.innerHTML = '×';
                deleteBtn.style.cssText = `
                    position: absolute;
                    top: -12px;
                    right: -12px;
                    width: 24px;
                    height: 24px;
                    border-radius: 50%;
                    background: #ff4444;
                    color: white;
                    border: 2px solid white;
                    cursor: pointer;
                    font-size: 14px;
                    font-weight: bold;
                    display: none;
                    align-items: center;
                    justify-content: center;
                    z-index: 100;
                    pointer-events: auto;
                `;
                deleteBtn.onmousedown = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                };
                deleteBtn.onclick = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    deleteTextObject(obj.id);
                };
                deleteBtn.ondblclick = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                };
                overlay.appendChild(deleteBtn);
                
                // 編輯按鈕
                const editBtn = document.createElement('button');
                editBtn.innerHTML = '✏️';
                editBtn.style.cssText = `
                    position: absolute;
                    top: -12px;
                    left: -12px;
                    width: 24px;
                    height: 24px;
                    border-radius: 50%;
                    background: #4a90d9;
                    color: white;
                    border: 2px solid white;
                    cursor: pointer;
                    font-size: 12px;
                    display: none;
                    align-items: center;
                    justify-content: center;
                    z-index: 100;
                    pointer-events: auto;
                `;
                editBtn.onmousedown = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                };
                editBtn.onclick = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    editTextObject(obj.id);
                };
                editBtn.ondblclick = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                };
                overlay.appendChild(editBtn);
                
                // 滑鼠事件
                overlay.onmouseenter = () => {
                    overlay.style.borderColor = '#4a90d9';
                    deleteBtn.style.display = 'flex';
                    editBtn.style.display = 'flex';
                };
                overlay.onmouseleave = () => {
                    if (activeTextObject !== obj.id) {
                        overlay.style.borderColor = 'transparent';
                        deleteBtn.style.display = 'none';
                        editBtn.style.display = 'none';
                    }
                };
                
                // 拖拉事件
                overlay.onmousedown = (e) => {
                    if (e.target === deleteBtn || e.target === editBtn) return;
                    e.preventDefault();
                    activeTextObject = obj.id;
                    textDragOffset = {
                        x: e.clientX - overlay.offsetLeft * state.displayScale,
                        y: e.clientY - overlay.offsetTop * state.displayScale
                    };
                    overlay.style.borderColor = '#4a90d9';
                    overlay.style.zIndex = '100';
                };
                
                // 雙擊編輯（排除按鈕）
                overlay.ondblclick = (e) => {
                    if (e.target === deleteBtn || e.target === editBtn) return;
                    e.preventDefault();
                    e.stopPropagation();
                    editTextObject(obj.id);
                };
                
                canvasContainer.appendChild(overlay);
            });
        }
        
        // 繪製帶特效的文字
        function drawTextWithEffects(tctx, obj, padding) {
            tctx.font = `${obj.weight} ${obj.size}px "${obj.font}"`;
            tctx.textBaseline = 'top';
            
            const lines = obj.text.split('\n');
            const lineHeight = obj.size * 1.3;
            const direction = obj.direction || 'horizontal';
            const transform = obj.transform || 'none';
            const transformAmount = (obj.transformAmount || 50) / 100;
            
            // 繪製單個字元（用於變形和直書）
            function drawChar(char, x, y, charIndex, totalChars) {
                let finalX = x;
                let finalY = y;
                let scale = 1;
                let rotation = 0;
                
                // 應用變形效果
                if (transform !== 'none') {
                    const progress = charIndex / Math.max(totalChars - 1, 1);
                    const center = 0.5;
                    const distFromCenter = Math.abs(progress - center);
                    
                    switch (transform) {
                        case 'arc':
                            const arcAngle = (progress - 0.5) * Math.PI * transformAmount;
                            finalY += Math.cos(arcAngle) * obj.size * transformAmount * 0.5 - obj.size * transformAmount * 0.5;
                            rotation = arcAngle * 0.3;
                            break;
                        case 'arc-down':
                            const arcDownAngle = (progress - 0.5) * Math.PI * transformAmount;
                            finalY -= Math.cos(arcDownAngle) * obj.size * transformAmount * 0.5 - obj.size * transformAmount * 0.5;
                            rotation = -arcDownAngle * 0.3;
                            break;
                        case 'wave':
                            finalY += Math.sin(progress * Math.PI * 4) * obj.size * transformAmount * 0.3;
                            break;
                        case 'bulge':
                            scale = 1 + (1 - distFromCenter * 2) * transformAmount * 0.5;
                            break;
                        case 'pinch':
                            scale = 0.5 + distFromCenter * transformAmount;
                            break;
                        case 'flag':
                            finalY += Math.sin(progress * Math.PI * 2) * obj.size * transformAmount * 0.4;
                            scale = 1 + Math.sin(progress * Math.PI * 2) * transformAmount * 0.2;
                            break;
                        case 'fish':
                            const fishScale = 1 - distFromCenter * transformAmount * 0.6;
                            scale = Math.max(0.3, fishScale);
                            finalY += (1 - fishScale) * obj.size * 0.3;
                            break;
                    }
                }
                
                tctx.save();
                tctx.translate(finalX, finalY);
                if (rotation) tctx.rotate(rotation);
                if (scale !== 1) tctx.scale(scale, scale);
                
                // 3D 效果
                if (obj.effect3d) {
                    const depth = obj.effect3d.depth;
                    let dx = 1, dy = 1;
                    switch (obj.effect3d.angle) {
                        case 'bl': dx = -1; dy = 1; break;
                        case 'tr': dx = 1; dy = -1; break;
                        case 'tl': dx = -1; dy = -1; break;
                    }
                    tctx.fillStyle = obj.effect3d.color;
                    for (let i = depth; i > 0; i--) {
                        tctx.fillText(char, dx * i, dy * i);
                    }
                }
                
                // 發光效果
                if (obj.glow) {
                    tctx.shadowColor = obj.glow.color;
                    tctx.shadowBlur = obj.glow.size;
                    tctx.shadowOffsetX = 0;
                    tctx.shadowOffsetY = 0;
                }
                
                // 陰影效果
                if (obj.shadow && !obj.glow) {
                    tctx.shadowColor = obj.shadow.color;
                    tctx.shadowBlur = obj.shadow.blur;
                    tctx.shadowOffsetX = obj.shadow.x;
                    tctx.shadowOffsetY = obj.shadow.y;
                }
                
                // 外框效果
                if (obj.outline) {
                    tctx.strokeStyle = obj.outline.color;
                    tctx.lineWidth = obj.outline.width;
                    tctx.lineJoin = 'round';
                    tctx.strokeText(char, 0, 0);
                }
                
                // 原本的描邊
                if (obj.stroke > 0) {
                    tctx.strokeStyle = obj.strokeColor;
                    tctx.lineWidth = obj.stroke;
                    tctx.strokeText(char, 0, 0);
                }
                
                // 填充文字
                tctx.fillStyle = obj.color;
                tctx.fillText(char, 0, 0);
                
                tctx.restore();
            }
            
            if (direction === 'vertical') {
                // 直書模式
                let colX = obj.width - padding - obj.size;
                lines.forEach((line, lineIdx) => {
                    const chars = [...line];
                    chars.forEach((char, charIdx) => {
                        const charY = padding + charIdx * obj.size * 1.2;
                        drawChar(char, colX, charY, charIdx, chars.length);
                    });
                    colX -= obj.size * 1.5;
                });
            } else if (transform !== 'none') {
                // 變形模式：逐字繪製
                lines.forEach((line, lineIdx) => {
                    const chars = [...line];
                    let charX = padding;
                    const lineY = padding + lineIdx * lineHeight;
                    
                    chars.forEach((char, charIdx) => {
                        const charWidth = tctx.measureText(char).width;
                        drawChar(char, charX, lineY, charIdx, chars.length);
                        charX += charWidth;
                    });
                });
            } else {
                // 一般模式：整行繪製（效率較高）
                lines.forEach((line, i) => {
                    const lineY = padding + i * lineHeight;
                    
                    tctx.save();
                    
                    // 3D 效果
                    if (obj.effect3d) {
                        const depth = obj.effect3d.depth;
                        let dx = 1, dy = 1;
                        switch (obj.effect3d.angle) {
                            case 'bl': dx = -1; dy = 1; break;
                            case 'tr': dx = 1; dy = -1; break;
                            case 'tl': dx = -1; dy = -1; break;
                        }
                        tctx.fillStyle = obj.effect3d.color;
                        for (let j = depth; j > 0; j--) {
                            tctx.fillText(line, padding + dx * j, lineY + dy * j);
                        }
                    }
                    
                    // 發光效果
                    if (obj.glow) {
                        tctx.shadowColor = obj.glow.color;
                        tctx.shadowBlur = obj.glow.size;
                        tctx.shadowOffsetX = 0;
                        tctx.shadowOffsetY = 0;
                    }
                    
                    // 陰影效果
                    if (obj.shadow && !obj.glow) {
                        tctx.shadowColor = obj.shadow.color;
                        tctx.shadowBlur = obj.shadow.blur;
                        tctx.shadowOffsetX = obj.shadow.x;
                        tctx.shadowOffsetY = obj.shadow.y;
                    }
                    
                    // 外框效果
                    if (obj.outline) {
                        tctx.strokeStyle = obj.outline.color;
                        tctx.lineWidth = obj.outline.width;
                        tctx.lineJoin = 'round';
                        tctx.strokeText(line, padding, lineY);
                    }
                    
                    // 原本的描邊
                    if (obj.stroke > 0) {
                        tctx.strokeStyle = obj.strokeColor;
                        tctx.lineWidth = obj.stroke;
                        tctx.strokeText(line, padding, lineY);
                    }
                    
                    // 填充文字
                    tctx.fillStyle = obj.color;
                    tctx.fillText(line, padding, lineY);
                    
                    tctx.restore();
                });
            }
        }
        
        // 文字拖拉處理
        document.addEventListener('mousemove', (e) => {
            if (activeTextObject !== null && textDragOffset) {
                const obj = textObjects.find(t => t.id === activeTextObject);
                if (obj) {
                    const containerRect = canvasContainer.getBoundingClientRect();
                    obj.x = (e.clientX - containerRect.left) / state.displayScale - obj.width / 2;
                    obj.y = (e.clientY - containerRect.top) / state.displayScale - obj.height / 2;
                    
                    // 邊界限制
                    obj.x = Math.max(0, Math.min(canvas.width - obj.width, obj.x));
                    obj.y = Math.max(0, Math.min(canvas.height - obj.height, obj.y));
                    
                    const overlay = document.querySelector(`.text-object-overlay[data-id="${obj.id}"]`);
                    if (overlay) {
                        overlay.style.left = obj.x + 'px';
                        overlay.style.top = obj.y + 'px';
                    }
                }
            }
        });
        
        document.addEventListener('mouseup', () => {
            if (activeTextObject !== null) {
                const overlay = document.querySelector(`.text-object-overlay[data-id="${activeTextObject}"]`);
                if (overlay) {
                    overlay.style.zIndex = '';
                }
                activeTextObject = null;
                textDragOffset = null;
            }
        });
        
        // 刪除文字物件
        function deleteTextObject(id) {
            textObjects = textObjects.filter(t => t.id !== id);
            renderTextObjects();
            toast('文字已刪除', 'info');
        }
        
        // 編輯文字物件
        function editTextObject(id) {
            const obj = textObjects.find(t => t.id === id);
            if (!obj) return;
            
            // 圓角字體列表
            const roundedFonts = ['jf-openhuninn', 'Kosugi Maru', 'M PLUS Rounded 1c', 'Nunito', 'Quicksand', 'Comfortaa', 'Arial Rounded MT Bold'];
            const isRounded = roundedFonts.includes(obj.font);
            
            const dialog = document.createElement('div');
            dialog.id = 'text-edit-dialog';
            dialog.style.cssText = `
                position: fixed;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                background: #1a1a1a;
                border: 1px solid #444;
                border-radius: 12px;
                padding: 20px;
                z-index: 10001;
                min-width: 500px;
                max-height: 90vh;
                overflow-y: auto;
                box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            `;
            
            dialog.innerHTML = `
                <h3 style="margin:0 0 15px 0;display:flex;justify-content:space-between;align-items:center;">
                    <span>✏️ 編輯文字</span>
                    <button onclick="document.getElementById('text-edit-dialog').remove()" 
                        style="background:none;border:none;color:#fff;font-size:20px;cursor:pointer;">×</button>
                </h3>
                <div style="margin-bottom:12px;">
                    <label style="display:block;margin-bottom:4px;font-size:12px;color:#aaa;">文字內容</label>
                    <textarea id="edit-text-input" rows="3" style="width:100%;padding:8px;background:#2a2a2a;border:1px solid #444;border-radius:6px;color:#fff;font-size:14px;resize:vertical;">${obj.text}</textarea>
                </div>
                <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:12px;margin-bottom:12px;">
                    <div>
                        <label style="display:block;margin-bottom:4px;font-size:12px;color:#aaa;">字型</label>
                        <select id="edit-text-font" style="width:100%;padding:8px;background:#2a2a2a;border:1px solid #444;border-radius:6px;color:#fff;">
                            <option value="Inter" ${obj.font === 'Inter' ? 'selected' : ''}>Inter</option>
                            <option value="Arial" ${obj.font === 'Arial' ? 'selected' : ''}>Arial</option>
                            <option value="Helvetica" ${obj.font === 'Helvetica' ? 'selected' : ''}>Helvetica</option>
                            <option value="Times New Roman" ${obj.font === 'Times New Roman' ? 'selected' : ''}>Times New Roman</option>
                            <option value="Georgia" ${obj.font === 'Georgia' ? 'selected' : ''}>Georgia</option>
                            <option value="Verdana" ${obj.font === 'Verdana' ? 'selected' : ''}>Verdana</option>
                            <option value="Microsoft JhengHei" ${obj.font === 'Microsoft JhengHei' ? 'selected' : ''}>微軟正黑體</option>
                            <option value="PingFang TC" ${obj.font === 'PingFang TC' ? 'selected' : ''}>蘋方-繁</option>
                            <option value="Noto Sans TC" ${obj.font === 'Noto Sans TC' ? 'selected' : ''}>Noto Sans TC</option>
                            <option value="jf-openhuninn" ${obj.font === 'jf-openhuninn' ? 'selected' : ''}>jf open 粉圓</option>
                            <option value="Nunito" ${obj.font === 'Nunito' ? 'selected' : ''}>Nunito (圓角)</option>
                            <option value="Quicksand" ${obj.font === 'Quicksand' ? 'selected' : ''}>Quicksand (圓角)</option>
                            <option value="Comfortaa" ${obj.font === 'Comfortaa' ? 'selected' : ''}>Comfortaa (圓角)</option>
                            <option value="M PLUS Rounded 1c" ${obj.font === 'M PLUS Rounded 1c' ? 'selected' : ''}>M+ 圓體</option>
                            <option value="Kosugi Maru" ${obj.font === 'Kosugi Maru' ? 'selected' : ''}>小杉圓體</option>
                            <option value="serif" ${obj.font === 'serif' ? 'selected' : ''}>襯線體</option>
                            <option value="sans-serif" ${obj.font === 'sans-serif' ? 'selected' : ''}>無襯線體</option>
                            <option value="monospace" ${obj.font === 'monospace' ? 'selected' : ''}>等寬字體</option>
                            <option value="cursive" ${obj.font === 'cursive' ? 'selected' : ''}>手寫體</option>
                        </select>
                    </div>
                    <div>
                        <label style="display:block;margin-bottom:4px;font-size:12px;color:#aaa;">字體大小</label>
                        <input type="number" id="edit-text-size" value="${obj.size}" min="8" max="200" style="width:100%;padding:8px;background:#2a2a2a;border:1px solid #444;border-radius:6px;color:#fff;">
                    </div>
                    <div>
                        <label style="display:block;margin-bottom:4px;font-size:12px;color:#aaa;">排列方向</label>
                        <select id="edit-text-direction" style="width:100%;padding:8px;background:#2a2a2a;border:1px solid #444;border-radius:6px;color:#fff;">
                            <option value="horizontal" ${obj.direction === 'horizontal' || !obj.direction ? 'selected' : ''}>橫書 →</option>
                            <option value="vertical" ${obj.direction === 'vertical' ? 'selected' : ''}>直書 ↓</option>
                        </select>
                    </div>
                </div>
                <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:12px;margin-bottom:12px;">
                    <div>
                        <label style="display:block;margin-bottom:4px;font-size:12px;color:#aaa;">文字顏色</label>
                        <input type="color" id="edit-text-color" value="${obj.color}" style="width:100%;height:36px;border:none;border-radius:6px;cursor:pointer;">
                    </div>
                    <div>
                        <label style="display:block;margin-bottom:4px;font-size:12px;color:#aaa;">背景顏色</label>
                        <input type="color" id="edit-text-bg-color" value="${obj.bgColor || '#ffffff'}" style="width:100%;height:36px;border:none;border-radius:6px;cursor:pointer;">
                    </div>
                    <div>
                        <label style="display:block;margin-bottom:4px;font-size:12px;color:#aaa;">背景</label>
                        <select id="edit-text-bg-type" style="width:100%;padding:8px;background:#2a2a2a;border:1px solid #444;border-radius:6px;color:#fff;">
                            <option value="none" ${obj.bgType === 'none' ? 'selected' : ''}>無背景</option>
                            <option value="solid" ${obj.bgType === 'solid' ? 'selected' : ''}>實色背景</option>
                            <option value="rounded" ${obj.bgType === 'rounded' ? 'selected' : ''}>圓角背景</option>
                        </select>
                    </div>
                </div>
                <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:12px;margin-bottom:12px;">
                    <div>
                        <label style="display:block;margin-bottom:4px;font-size:12px;color:#aaa;">粗體</label>
                        <select id="edit-text-weight" style="width:100%;padding:8px;background:#2a2a2a;border:1px solid #444;border-radius:6px;color:#fff;">
                            <option value="normal" ${obj.weight === 'normal' ? 'selected' : ''}>正常</option>
                            <option value="bold" ${obj.weight === 'bold' ? 'selected' : ''}>粗體</option>
                            <option value="100" ${obj.weight === '100' ? 'selected' : ''}>細 100</option>
                            <option value="300" ${obj.weight === '300' ? 'selected' : ''}>輕 300</option>
                            <option value="500" ${obj.weight === '500' ? 'selected' : ''}>中 500</option>
                            <option value="700" ${obj.weight === '700' ? 'selected' : ''}>粗 700</option>
                            <option value="900" ${obj.weight === '900' ? 'selected' : ''}>黑 900</option>
                        </select>
                    </div>
                    <div>
                        <label style="display:block;margin-bottom:4px;font-size:12px;color:#aaa;">描邊寬度</label>
                        <input type="number" id="edit-text-stroke" value="${obj.stroke || 0}" min="0" max="20" style="width:100%;padding:8px;background:#2a2a2a;border:1px solid #444;border-radius:6px;color:#fff;">
                    </div>
                    <div>
                        <label style="display:block;margin-bottom:4px;font-size:12px;color:#aaa;">描邊顏色</label>
                        <input type="color" id="edit-text-stroke-color" value="${obj.strokeColor || '#ffffff'}" style="width:100%;height:36px;border:none;border-radius:6px;cursor:pointer;">
                    </div>
                </div>
                
                <!-- 文字變形 -->
                <div style="border-top:1px solid #333;padding-top:12px;margin-bottom:12px;">
                    <label style="display:block;margin-bottom:8px;font-size:12px;color:#4a90d9;font-weight:bold;">🔄 文字變形</label>
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;">
                        <div>
                            <label style="display:block;margin-bottom:4px;font-size:12px;color:#aaa;">變形效果</label>
                            <select id="edit-text-transform" style="width:100%;padding:8px;background:#2a2a2a;border:1px solid #444;border-radius:6px;color:#fff;">
                                <option value="none" ${!obj.transform || obj.transform === 'none' ? 'selected' : ''}>無變形</option>
                                <option value="arc" ${obj.transform === 'arc' ? 'selected' : ''}>弧形 ⌒</option>
                                <option value="arc-down" ${obj.transform === 'arc-down' ? 'selected' : ''}>下弧形 ⌓</option>
                                <option value="wave" ${obj.transform === 'wave' ? 'selected' : ''}>波浪 〰</option>
                                <option value="bulge" ${obj.transform === 'bulge' ? 'selected' : ''}>膨脹 ◯</option>
                                <option value="pinch" ${obj.transform === 'pinch' ? 'selected' : ''}>收縮 ◇</option>
                                <option value="flag" ${obj.transform === 'flag' ? 'selected' : ''}>旗幟 🏴</option>
                                <option value="fish" ${obj.transform === 'fish' ? 'selected' : ''}>魚形 🐟</option>
                            </select>
                        </div>
                        <div>
                            <label style="display:block;margin-bottom:4px;font-size:12px;color:#aaa;">變形強度: <span id="edit-text-transform-value">${obj.transformAmount || 50}%</span></label>
                            <input type="range" id="edit-text-transform-amount" min="0" max="100" value="${obj.transformAmount || 50}" 
                                oninput="document.getElementById('edit-text-transform-value').textContent=this.value+'%'"
                                style="width:100%;">
                        </div>
                    </div>
                </div>
                
                <!-- 文字特效 -->
                <div style="border-top:1px solid #333;padding-top:12px;margin-bottom:12px;">
                    <label style="display:block;margin-bottom:8px;font-size:12px;color:#4a90d9;font-weight:bold;">✨ 文字特效</label>
                    <div style="display:grid;grid-template-columns:1fr 1fr 1fr 1fr;gap:8px;margin-bottom:10px;">
                        <label style="display:flex;align-items:center;gap:4px;font-size:12px;color:#ccc;cursor:pointer;">
                            <input type="checkbox" id="edit-text-shadow-enable" ${obj.shadow ? 'checked' : ''} onchange="document.getElementById('edit-text-shadow-options').style.display=this.checked?'grid':'none'"> 陰影
                        </label>
                        <label style="display:flex;align-items:center;gap:4px;font-size:12px;color:#ccc;cursor:pointer;">
                            <input type="checkbox" id="edit-text-glow-enable" ${obj.glow ? 'checked' : ''} onchange="document.getElementById('edit-text-glow-options').style.display=this.checked?'grid':'none'"> 發光
                        </label>
                        <label style="display:flex;align-items:center;gap:4px;font-size:12px;color:#ccc;cursor:pointer;">
                            <input type="checkbox" id="edit-text-outline-enable" ${obj.outline ? 'checked' : ''} onchange="document.getElementById('edit-text-outline-options').style.display=this.checked?'grid':'none'"> 外框
                        </label>
                        <label style="display:flex;align-items:center;gap:4px;font-size:12px;color:#ccc;cursor:pointer;">
                            <input type="checkbox" id="edit-text-3d-enable" ${obj.effect3d ? 'checked' : ''} onchange="document.getElementById('edit-text-3d-options').style.display=this.checked?'grid':'none'"> 3D
                        </label>
                    </div>
                    
                    <!-- 陰影選項 -->
                    <div id="edit-text-shadow-options" style="display:${obj.shadow ? 'grid' : 'none'};grid-template-columns:1fr 1fr 1fr 1fr;gap:8px;margin-bottom:8px;padding:8px;background:#252525;border-radius:6px;">
                        <div>
                            <label style="font-size:11px;color:#888;">X偏移</label>
                            <input type="number" id="edit-text-shadow-x" value="${obj.shadow?.x || 3}" style="width:100%;padding:4px;background:#333;border:1px solid #444;border-radius:4px;color:#fff;font-size:12px;">
                        </div>
                        <div>
                            <label style="font-size:11px;color:#888;">Y偏移</label>
                            <input type="number" id="edit-text-shadow-y" value="${obj.shadow?.y || 3}" style="width:100%;padding:4px;background:#333;border:1px solid #444;border-radius:4px;color:#fff;font-size:12px;">
                        </div>
                        <div>
                            <label style="font-size:11px;color:#888;">模糊</label>
                            <input type="number" id="edit-text-shadow-blur" value="${obj.shadow?.blur || 5}" min="0" style="width:100%;padding:4px;background:#333;border:1px solid #444;border-radius:4px;color:#fff;font-size:12px;">
                        </div>
                        <div>
                            <label style="font-size:11px;color:#888;">顏色</label>
                            <input type="color" id="edit-text-shadow-color" value="${obj.shadow?.color || '#000000'}" style="width:100%;height:26px;border:none;border-radius:4px;">
                        </div>
                    </div>
                    
                    <!-- 發光選項 -->
                    <div id="edit-text-glow-options" style="display:${obj.glow ? 'grid' : 'none'};grid-template-columns:1fr 1fr;gap:8px;margin-bottom:8px;padding:8px;background:#252525;border-radius:6px;">
                        <div>
                            <label style="font-size:11px;color:#888;">發光強度</label>
                            <input type="number" id="edit-text-glow-size" value="${obj.glow?.size || 10}" min="1" max="50" style="width:100%;padding:4px;background:#333;border:1px solid #444;border-radius:4px;color:#fff;font-size:12px;">
                        </div>
                        <div>
                            <label style="font-size:11px;color:#888;">發光顏色</label>
                            <input type="color" id="edit-text-glow-color" value="${obj.glow?.color || '#ffff00'}" style="width:100%;height:26px;border:none;border-radius:4px;">
                        </div>
                    </div>
                    
                    <!-- 外框選項 -->
                    <div id="edit-text-outline-options" style="display:${obj.outline ? 'grid' : 'none'};grid-template-columns:1fr 1fr;gap:8px;margin-bottom:8px;padding:8px;background:#252525;border-radius:6px;">
                        <div>
                            <label style="font-size:11px;color:#888;">外框寬度</label>
                            <input type="number" id="edit-text-outline-width" value="${obj.outline?.width || 3}" min="1" max="20" style="width:100%;padding:4px;background:#333;border:1px solid #444;border-radius:4px;color:#fff;font-size:12px;">
                        </div>
                        <div>
                            <label style="font-size:11px;color:#888;">外框顏色</label>
                            <input type="color" id="edit-text-outline-color" value="${obj.outline?.color || '#ffffff'}" style="width:100%;height:26px;border:none;border-radius:4px;">
                        </div>
                    </div>
                    
                    <!-- 3D選項 -->
                    <div id="edit-text-3d-options" style="display:${obj.effect3d ? 'grid' : 'none'};grid-template-columns:1fr 1fr 1fr;gap:8px;margin-bottom:8px;padding:8px;background:#252525;border-radius:6px;">
                        <div>
                            <label style="font-size:11px;color:#888;">深度</label>
                            <input type="number" id="edit-text-3d-depth" value="${obj.effect3d?.depth || 5}" min="1" max="20" style="width:100%;padding:4px;background:#333;border:1px solid #444;border-radius:4px;color:#fff;font-size:12px;">
                        </div>
                        <div>
                            <label style="font-size:11px;color:#888;">角度</label>
                            <select id="edit-text-3d-angle" style="width:100%;padding:4px;background:#333;border:1px solid #444;border-radius:4px;color:#fff;font-size:12px;">
                                <option value="br" ${obj.effect3d?.angle === 'br' || !obj.effect3d?.angle ? 'selected' : ''}>右下 ↘</option>
                                <option value="bl" ${obj.effect3d?.angle === 'bl' ? 'selected' : ''}>左下 ↙</option>
                                <option value="tr" ${obj.effect3d?.angle === 'tr' ? 'selected' : ''}>右上 ↗</option>
                                <option value="tl" ${obj.effect3d?.angle === 'tl' ? 'selected' : ''}>左上 ↖</option>
                            </select>
                        </div>
                        <div>
                            <label style="font-size:11px;color:#888;">陰影顏色</label>
                            <input type="color" id="edit-text-3d-color" value="${obj.effect3d?.color || '#666666'}" style="width:100%;height:26px;border:none;border-radius:4px;">
                        </div>
                    </div>
                </div>
                
                <div style="display:flex;gap:8px;margin-bottom:12px;">
                    <button onclick="copyFontStyleFromTextDialog('edit-text')" class="btn btn-outline" style="flex:1;font-size:11px;">🔤 複製字體樣式</button>
                    <button onclick="pasteFontStyleToTextDialog('edit-text')" class="btn btn-outline" style="flex:1;font-size:11px;" ${state.copiedFontStyle ? '' : 'disabled'}>🔤 貼上字體樣式</button>
                </div>
                ${state.copiedFontStyle ? '<div style="margin-bottom:12px;padding:6px 10px;background:#1a1a2e;border:1px solid #6366f1;border-radius:6px;font-size:11px;color:#8b8bf6;">📌 已複製字體: ' + state.copiedFontStyle.fontFamily + ' / ' + state.copiedFontStyle.fontSize + 'px / ' + state.copiedFontStyle.color + '</div>' : ''}
                <div style="display:flex;gap:10px;justify-content:flex-end;">
                    <button onclick="document.getElementById('text-edit-dialog').remove()" class="btn btn-outline">取消</button>
                    <button onclick="updateTextObject(${id})" class="btn btn-primary">更新</button>
                </div>
            `;
            
            document.body.appendChild(dialog);
            makeDraggable(dialog);
            document.getElementById('edit-text-input').focus();
            document.getElementById('edit-text-input').select();
        }
        
        // 更新文字物件
        function updateTextObject(id) {
            const obj = textObjects.find(t => t.id === id);
            if (!obj) return;
            
            obj.text = document.getElementById('edit-text-input').value;
            obj.font = document.getElementById('edit-text-font').value;
            obj.size = parseInt(document.getElementById('edit-text-size').value);
            obj.color = document.getElementById('edit-text-color').value;
            obj.bgColor = document.getElementById('edit-text-bg-color').value;
            obj.bgType = document.getElementById('edit-text-bg-type').value;
            obj.weight = document.getElementById('edit-text-weight').value;
            obj.stroke = parseInt(document.getElementById('edit-text-stroke').value);
            obj.strokeColor = document.getElementById('edit-text-stroke-color').value;
            
            // 排列方向
            obj.direction = document.getElementById('edit-text-direction').value;
            
            // 文字變形
            obj.transform = document.getElementById('edit-text-transform').value;
            obj.transformAmount = parseInt(document.getElementById('edit-text-transform-amount').value);
            
            // 文字特效
            obj.shadow = document.getElementById('edit-text-shadow-enable').checked ? {
                x: parseInt(document.getElementById('edit-text-shadow-x').value),
                y: parseInt(document.getElementById('edit-text-shadow-y').value),
                blur: parseInt(document.getElementById('edit-text-shadow-blur').value),
                color: document.getElementById('edit-text-shadow-color').value
            } : null;
            
            obj.glow = document.getElementById('edit-text-glow-enable').checked ? {
                size: parseInt(document.getElementById('edit-text-glow-size').value),
                color: document.getElementById('edit-text-glow-color').value
            } : null;
            
            obj.outline = document.getElementById('edit-text-outline-enable').checked ? {
                width: parseInt(document.getElementById('edit-text-outline-width').value),
                color: document.getElementById('edit-text-outline-color').value
            } : null;
            
            obj.effect3d = document.getElementById('edit-text-3d-enable').checked ? {
                depth: parseInt(document.getElementById('edit-text-3d-depth').value),
                angle: document.getElementById('edit-text-3d-angle').value,
                color: document.getElementById('edit-text-3d-color').value
            } : null;
            
            // 重新計算尺寸
            ctx.font = `${obj.weight} ${obj.size}px "${obj.font}"`;
            const lines = obj.text.split('\n');
            let maxWidth = 0;
            lines.forEach(line => {
                const w = ctx.measureText(line).width;
                if (w > maxWidth) maxWidth = w;
            });
            
            // 根據排列方向計算尺寸
            if (obj.direction === 'vertical') {
                const maxChars = Math.max(...lines.map(l => l.length));
                obj.width = lines.length * obj.size * 1.5 + 16;
                obj.height = maxChars * obj.size * 1.2 + 16;
            } else {
                obj.width = maxWidth + 16;
                obj.height = lines.length * obj.size * 1.3 + 16;
            }
            
            // 考慮特效需要的額外空間
            if (obj.shadow || obj.glow || obj.effect3d) {
                obj.width += 30;
                obj.height += 30;
            }
            
            document.getElementById('text-edit-dialog').remove();
            renderTextObjects();
            toast('文字已更新', 'success');
        }
        
        // 將所有文字物件繪製到畫布上
        function flattenTextObjects() {
            if (textObjects.length === 0) return;
            
            saveHistory('合併文字');
            
            textObjects.forEach(obj => {
                const padding = 8;
                
                // 繪製背景
                if (obj.bgType !== 'none') {
                    ctx.fillStyle = obj.bgColor;
                    if (obj.bgType === 'rounded') {
                        ctx.beginPath();
                        ctx.roundRect(obj.x, obj.y, obj.width, obj.height, 8);
                        ctx.fill();
                    } else {
                        ctx.fillRect(obj.x, obj.y, obj.width, obj.height);
                    }
                }
                
                // 繪製文字
                ctx.font = `${obj.weight} ${obj.size}px "${obj.font}"`;
                ctx.textBaseline = 'top';
                ctx.fillStyle = obj.color;
                
                const lines = obj.text.split('\n');
                const lineHeight = obj.size * 1.3;
                
                lines.forEach((line, i) => {
                    const lineY = obj.y + padding + i * lineHeight;
                    
                    if (obj.stroke > 0) {
                        ctx.strokeStyle = obj.strokeColor;
                        ctx.lineWidth = obj.stroke;
                        ctx.strokeText(line, obj.x + padding, lineY);
                    }
                    
                    ctx.fillText(line, obj.x + padding, lineY);
                });
            });
            
            // 清除文字物件
            textObjects = [];
            renderTextObjects();
            
            toast('文字已合併到圖片', 'success');
            updateUndoButton();
        }
        
        // 舊版直接繪製函數（保留相容性）
        function applyTextTool(x, y) {
            createTextObject(x, y);
        }
        
        // ============ 橡皮擦工具 ============
        
        // 橡皮擦模式切換
        function onEraserModeChange(mode) {
            state.eraserMode = mode;
            const colorPicker = document.getElementById('eraser-color-picker');
            const pickHint = document.getElementById('eraser-pick-hint');
            
            if (mode === 'color') {
                colorPicker.style.display = 'flex';
                pickHint.style.display = 'none';
            } else if (mode === 'pick') {
                colorPicker.style.display = 'flex';
                pickHint.style.display = 'block';
            } else {
                colorPicker.style.display = 'none';
                pickHint.style.display = 'none';
            }
        }
        
        // 橡皮擦取色
        function pickEraserColor() {
            toast('點擊圖片取色', 'info');
            state.eraserPickingColor = true;
            canvas.style.cursor = 'crosshair';
        }
        
        // 橡皮擦取色處理（在 onMouseDown 中調用）
        function handleEraserColorPick(x, y) {
            const pixel = ctx.getImageData(Math.round(x), Math.round(y), 1, 1).data;
            const color = '#' + [pixel[0], pixel[1], pixel[2]].map(v => v.toString(16).padStart(2, '0')).join('');
            
            state.eraserColor = color;
            document.getElementById('eraser-color').value = color;
            state.eraserPickingColor = false;
            canvas.style.cursor = '';
            
            toast(`已取色: ${color}`, 'success');
        }
        
        function doEraser(x, y) {
            const size = state.eraserSize || 20;
            const mode = state.eraserMode || 'white';
            
            ctx.save();
            ctx.beginPath();
            ctx.arc(x, y, size / 2, 0, Math.PI * 2);
            ctx.clip();
            
            if (mode === 'transparent') {
                // 真正的透明（適用於有 alpha 通道的圖層）
                ctx.clearRect(x - size / 2, y - size / 2, size, size);
            } else if (mode === 'color' || mode === 'pick') {
                // 使用自訂顏色
                ctx.fillStyle = state.eraserColor || '#ffffff';
                ctx.fillRect(x - size / 2, y - size / 2, size, size);
            } else {
                // 預設白色
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(x - size / 2, y - size / 2, size, size);
            }
            
            ctx.restore();
        }
        
        // ============ 油漆桶填充 ============
        
        function doFloodFill(startX, startY) {
            if (startX < 0 || startX >= canvas.width || startY < 0 || startY >= canvas.height) return;
            
            const fillColor = state.fillColor || '#ff0000';
            const tolerance = state.fillTolerance || 32;
            
            toast('正在填充...', 'info');
            
            setTimeout(() => {
                try {
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;
                    const width = canvas.width;
                    const height = canvas.height;
                    
                    // 取得起始點顏色
                    const startIdx = (startY * width + startX) * 4;
                    const startR = data[startIdx];
                    const startG = data[startIdx + 1];
                    const startB = data[startIdx + 2];
                    const startA = data[startIdx + 3];
                    
                    // 解析填充顏色
                    const fillR = parseInt(fillColor.slice(1, 3), 16);
                    const fillG = parseInt(fillColor.slice(3, 5), 16);
                    const fillB = parseInt(fillColor.slice(5, 7), 16);
                    
                    // 如果起始顏色和填充顏色相同，跳過
                    if (Math.abs(startR - fillR) < 5 && Math.abs(startG - fillG) < 5 && Math.abs(startB - fillB) < 5) {
                        toast('起始顏色與填充顏色相同', 'info');
                        return;
                    }
                    
                    // 檢查顏色是否相似
                    function colorMatch(idx) {
                        const r = data[idx];
                        const g = data[idx + 1];
                        const b = data[idx + 2];
                        const a = data[idx + 3];
                        
                        return Math.abs(r - startR) <= tolerance &&
                               Math.abs(g - startG) <= tolerance &&
                               Math.abs(b - startB) <= tolerance &&
                               Math.abs(a - startA) <= tolerance;
                    }
                    
                    // BFS 填充
                    const visited = new Set();
                    const queue = [[startX, startY]];
                    let filledCount = 0;
                    
                    while (queue.length > 0 && filledCount < width * height) {
                        const [x, y] = queue.shift();
                        const key = y * width + x;
                        
                        if (x < 0 || x >= width || y < 0 || y >= height) continue;
                        if (visited.has(key)) continue;
                        
                        const idx = key * 4;
                        if (!colorMatch(idx)) continue;
                        
                        visited.add(key);
                        
                        // 填充
                        data[idx] = fillR;
                        data[idx + 1] = fillG;
                        data[idx + 2] = fillB;
                        data[idx + 3] = 255;
                        filledCount++;
                        
                        // 添加鄰居
                        queue.push([x + 1, y]);
                        queue.push([x - 1, y]);
                        queue.push([x, y + 1]);
                        queue.push([x, y - 1]);
                    }
                    
                    ctx.putImageData(imageData, 0, 0);
                    toast(`已填充 ${filledCount} 個像素`, 'success');
                    updateUndoButton();
                    
                } catch (err) {
                    toast('填充失敗: ' + err.message, 'error');
                }
            }, 50);
        }
        
        // ============ 漸層填充 ============
        
        function applyGradientFill(x1, y1, x2, y2) {
            const gradientType = state.gradientType || 'linear';
            const gradientShape = state.gradientShape || 'rect';
            const opacity = state.gradientOpacity !== undefined ? state.gradientOpacity : 1;
            const color1 = state.gradientColor1 || '#ff0000';
            const color2 = state.gradientColor2 || '#0000ff';
            
            // 計算拖曳的區域範圍
            const minX = Math.min(x1, x2);
            const minY = Math.min(y1, y2);
            const width = Math.abs(x2 - x1);
            const height = Math.abs(y2 - y1);
            
            // 如果拖曳範圍太小，使用預設大小
            const finalWidth = width < 20 ? 200 : width;
            const finalHeight = height < 20 ? 200 : height;
            const finalX = width < 20 ? Math.max(0, x1 - 100) : minX;
            const finalY = height < 20 ? Math.max(0, y1 - 100) : minY;
            
            // 計算漸層方向角度（用於線性漸層）
            const angle = Math.atan2(y2 - y1, x2 - x1);
            
            // 創建漸層物件
            const gradientObj = {
                id: Date.now(),
                x: finalX,
                y: finalY,
                width: finalWidth,
                height: finalHeight,
                type: gradientType,
                shape: gradientShape,
                color1: color1,
                color2: color2,
                opacity: opacity,
                angle: angle, // 漸層方向
                layerIndex: activeLayerIndex // 記錄所屬圖層
            };
            
            gradientObjects.push(gradientObj);
            renderGradientObjects();
            
            toast('漸層已創建，可拖拉調整位置', 'success');
        }
        
        // 渲染漸層物件
        function renderGradientObjects() {
            // 移除舊的漸層覆蓋層
            document.querySelectorAll('.gradient-object-overlay').forEach(el => el.remove());
            
            // 過濾只顯示可見圖層的物件
            gradientObjects.filter(obj => isLayerVisible(obj.layerIndex)).forEach(obj => {
                const overlay = document.createElement('div');
                overlay.className = 'gradient-object-overlay';
                overlay.dataset.id = obj.id;
                overlay.style.cssText = `
                    position: absolute;
                    left: ${obj.x}px;
                    top: ${obj.y}px;
                    width: ${obj.width}px;
                    height: ${obj.height}px;
                    cursor: move;
                    user-select: none;
                    border: 2px dashed transparent;
                    transition: border-color 0.2s;
                    z-index: 50;
                    pointer-events: auto;
                `;
                
                // 創建漸層 canvas
                const gradCanvas = document.createElement('canvas');
                gradCanvas.width = obj.width;
                gradCanvas.height = obj.height;
                const gctx = gradCanvas.getContext('2d');
                
                // 將顏色轉換為帶透明度的 rgba
                function hexToRgba(hex, alpha) {
                    const r = parseInt(hex.slice(1, 3), 16);
                    const g = parseInt(hex.slice(3, 5), 16);
                    const b = parseInt(hex.slice(5, 7), 16);
                    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
                }
                
                // 創建漸層
                let gradient;
                const centerX = obj.width / 2;
                const centerY = obj.height / 2;
                
                if (obj.type === 'radial') {
                    const radius = Math.max(obj.width, obj.height) / 2;
                    gradient = gctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
                } else {
                    // 線性漸層：根據角度
                    const length = Math.max(obj.width, obj.height);
                    const dx = Math.cos(obj.angle) * length;
                    const dy = Math.sin(obj.angle) * length;
                    gradient = gctx.createLinearGradient(
                        centerX - dx/2, centerY - dy/2,
                        centerX + dx/2, centerY + dy/2
                    );
                }
                
                gradient.addColorStop(0, hexToRgba(obj.color1, obj.opacity));
                gradient.addColorStop(1, hexToRgba(obj.color2, obj.opacity));
                
                gctx.fillStyle = gradient;
                
                // 根據形狀繪製
                gctx.beginPath();
                switch (obj.shape) {
                    case 'circle':
                        const circleRadius = Math.min(obj.width, obj.height) / 2;
                        gctx.arc(centerX, centerY, circleRadius, 0, Math.PI * 2);
                        break;
                    case 'ellipse':
                        gctx.ellipse(centerX, centerY, obj.width / 2, obj.height / 2, 0, 0, Math.PI * 2);
                        break;
                    case 'roundRect':
                        const cornerRadius = Math.min(obj.width, obj.height) * 0.15;
                        gctx.roundRect(0, 0, obj.width, obj.height, cornerRadius);
                        break;
                    case 'rect':
                    default:
                        gctx.rect(0, 0, obj.width, obj.height);
                        break;
                }
                gctx.fill();
                
                overlay.appendChild(gradCanvas);
                
                // 刪除按鈕
                const deleteBtn = document.createElement('button');
                deleteBtn.innerHTML = '×';
                deleteBtn.style.cssText = `
                    position: absolute;
                    top: -12px;
                    right: -12px;
                    width: 24px;
                    height: 24px;
                    border-radius: 50%;
                    background: #ff4444;
                    color: white;
                    border: 2px solid white;
                    cursor: pointer;
                    font-size: 14px;
                    font-weight: bold;
                    display: none;
                    align-items: center;
                    justify-content: center;
                    z-index: 10;
                `;
                deleteBtn.onclick = (e) => {
                    e.stopPropagation();
                    deleteGradientObject(obj.id);
                };
                overlay.appendChild(deleteBtn);
                
                // 編輯按鈕
                const editBtn = document.createElement('button');
                editBtn.innerHTML = '✏️';
                editBtn.style.cssText = `
                    position: absolute;
                    top: -12px;
                    left: -12px;
                    width: 24px;
                    height: 24px;
                    border-radius: 50%;
                    background: #4a90d9;
                    color: white;
                    border: 2px solid white;
                    cursor: pointer;
                    font-size: 12px;
                    display: none;
                    align-items: center;
                    justify-content: center;
                    z-index: 10;
                `;
                editBtn.onclick = (e) => {
                    e.stopPropagation();
                    editGradientObject(obj.id);
                };
                overlay.appendChild(editBtn);
                
                // 確認按鈕（合併到畫布）
                const confirmBtn = document.createElement('button');
                confirmBtn.innerHTML = '✓';
                confirmBtn.style.cssText = `
                    position: absolute;
                    top: -12px;
                    left: 50%;
                    transform: translateX(-50%);
                    width: 24px;
                    height: 24px;
                    border-radius: 50%;
                    background: #22c55e;
                    color: white;
                    border: 2px solid white;
                    cursor: pointer;
                    font-size: 14px;
                    font-weight: bold;
                    display: none;
                    align-items: center;
                    justify-content: center;
                    z-index: 10;
                `;
                confirmBtn.onclick = (e) => {
                    e.stopPropagation();
                    flattenGradientObject(obj.id);
                };
                overlay.appendChild(confirmBtn);
                
                // 縮放控制點
                const resizeHandle = document.createElement('div');
                resizeHandle.style.cssText = `
                    position: absolute;
                    bottom: -6px;
                    right: -6px;
                    width: 12px;
                    height: 12px;
                    background: #4a90d9;
                    border: 2px solid white;
                    border-radius: 2px;
                    cursor: se-resize;
                    display: none;
                    z-index: 10;
                `;
                resizeHandle.onmousedown = (e) => {
                    e.stopPropagation();
                    startGradientResize(e, obj.id);
                };
                overlay.appendChild(resizeHandle);
                
                // 滑鼠事件
                overlay.onmouseenter = () => {
                    overlay.style.borderColor = '#4a90d9';
                    deleteBtn.style.display = 'flex';
                    editBtn.style.display = 'flex';
                    confirmBtn.style.display = 'flex';
                    resizeHandle.style.display = 'block';
                };
                overlay.onmouseleave = () => {
                    if (activeGradientObject !== obj.id) {
                        overlay.style.borderColor = 'transparent';
                        deleteBtn.style.display = 'none';
                        editBtn.style.display = 'none';
                        confirmBtn.style.display = 'none';
                        resizeHandle.style.display = 'none';
                    }
                };
                
                // 拖拉事件
                overlay.onmousedown = (e) => {
                    if (e.target === deleteBtn || e.target === editBtn || e.target === confirmBtn || e.target === resizeHandle) return;
                    e.preventDefault();
                    activeGradientObject = obj.id;
                    gradientDragOffset = {
                        x: e.clientX - overlay.offsetLeft * state.displayScale,
                        y: e.clientY - overlay.offsetTop * state.displayScale
                    };
                    overlay.style.borderColor = '#4a90d9';
                    overlay.style.zIndex = '100';
                };
                
                // 雙擊編輯
                overlay.ondblclick = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    editGradientObject(obj.id);
                };
                
                canvasContainer.appendChild(overlay);
            });
        }
        
        // 漸層拖拉處理
        document.addEventListener('mousemove', (e) => {
            if (activeGradientObject !== null && gradientDragOffset) {
                const obj = gradientObjects.find(g => g.id === activeGradientObject);
                if (obj) {
                    const containerRect = canvasContainer.getBoundingClientRect();
                    obj.x = (e.clientX - containerRect.left) / state.displayScale - obj.width / 2;
                    obj.y = (e.clientY - containerRect.top) / state.displayScale - obj.height / 2;
                    
                    // 邊界限制
                    obj.x = Math.max(-obj.width/2, Math.min(canvas.width - obj.width/2, obj.x));
                    obj.y = Math.max(-obj.height/2, Math.min(canvas.height - obj.height/2, obj.y));
                    
                    const overlay = document.querySelector(`.gradient-object-overlay[data-id="${obj.id}"]`);
                    if (overlay) {
                        overlay.style.left = obj.x + 'px';
                        overlay.style.top = obj.y + 'px';
                    }
                }
            }
            
            // 縮放處理
            if (resizingGradient) {
                const obj = gradientObjects.find(g => g.id === resizingGradient.id);
                if (obj) {
                    const containerRect = canvasContainer.getBoundingClientRect();
                    const mouseX = (e.clientX - containerRect.left) / state.displayScale;
                    const mouseY = (e.clientY - containerRect.top) / state.displayScale;
                    
                    obj.width = Math.max(30, mouseX - obj.x);
                    obj.height = Math.max(30, mouseY - obj.y);
                    
                    renderGradientObjects();
                }
            }
        });
        
        document.addEventListener('mouseup', () => {
            if (activeGradientObject !== null) {
                const overlay = document.querySelector(`.gradient-object-overlay[data-id="${activeGradientObject}"]`);
                if (overlay) {
                    overlay.style.zIndex = '';
                }
                activeGradientObject = null;
                gradientDragOffset = null;
            }
            resizingGradient = null;
        });
        
        // 縮放漸層
        let resizingGradient = null;
        function startGradientResize(e, id) {
            e.preventDefault();
            resizingGradient = { id };
        }
        
        // 刪除漸層物件
        function deleteGradientObject(id) {
            gradientObjects = gradientObjects.filter(g => g.id !== id);
            renderGradientObjects();
            toast('漸層已刪除', 'info');
        }
        
        // 編輯漸層物件
        function editGradientObject(id) {
            const obj = gradientObjects.find(g => g.id === id);
            if (!obj) return;
            
            const dialog = document.createElement('div');
            dialog.id = 'gradient-edit-dialog';
            dialog.style.cssText = `
                position: fixed;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                background: #1a1a1a;
                border: 1px solid #444;
                border-radius: 12px;
                padding: 20px;
                z-index: 10001;
                min-width: 350px;
                box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            `;
            
            dialog.innerHTML = `
                <h3 style="margin:0 0 15px 0;display:flex;justify-content:space-between;align-items:center;">
                    <span>🌈 編輯漸層</span>
                    <button onclick="document.getElementById('gradient-edit-dialog').remove()" 
                        style="background:none;border:none;color:#fff;font-size:20px;cursor:pointer;">×</button>
                </h3>
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-bottom:12px;">
                    <div>
                        <label style="display:block;margin-bottom:4px;font-size:12px;color:#aaa;">類型</label>
                        <select id="edit-grad-type" style="width:100%;padding:8px;background:#2a2a2a;border:1px solid #444;border-radius:6px;color:#fff;">
                            <option value="linear" ${obj.type === 'linear' ? 'selected' : ''}>線性漸層</option>
                            <option value="radial" ${obj.type === 'radial' ? 'selected' : ''}>放射漸層</option>
                        </select>
                    </div>
                    <div>
                        <label style="display:block;margin-bottom:4px;font-size:12px;color:#aaa;">形狀</label>
                        <select id="edit-grad-shape" style="width:100%;padding:8px;background:#2a2a2a;border:1px solid #444;border-radius:6px;color:#fff;">
                            <option value="rect" ${obj.shape === 'rect' ? 'selected' : ''}>矩形</option>
                            <option value="circle" ${obj.shape === 'circle' ? 'selected' : ''}>圓形</option>
                            <option value="ellipse" ${obj.shape === 'ellipse' ? 'selected' : ''}>橢圓</option>
                            <option value="roundRect" ${obj.shape === 'roundRect' ? 'selected' : ''}>圓角矩形</option>
                        </select>
                    </div>
                </div>
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-bottom:12px;">
                    <div>
                        <label style="display:block;margin-bottom:4px;font-size:12px;color:#aaa;">顏色1</label>
                        <input type="color" id="edit-grad-color1" value="${obj.color1}" style="width:100%;height:36px;border:none;border-radius:6px;cursor:pointer;">
                    </div>
                    <div>
                        <label style="display:block;margin-bottom:4px;font-size:12px;color:#aaa;">顏色2</label>
                        <input type="color" id="edit-grad-color2" value="${obj.color2}" style="width:100%;height:36px;border:none;border-radius:6px;cursor:pointer;">
                    </div>
                </div>
                <div style="margin-bottom:12px;">
                    <label style="display:block;margin-bottom:4px;font-size:12px;color:#aaa;">透明度: <span id="edit-grad-opacity-val">${Math.round(obj.opacity * 100)}%</span></label>
                    <input type="range" id="edit-grad-opacity" min="0" max="100" value="${Math.round(obj.opacity * 100)}" 
                        oninput="document.getElementById('edit-grad-opacity-val').textContent=this.value+'%'"
                        style="width:100%;">
                </div>
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-bottom:12px;">
                    <div>
                        <label style="display:block;margin-bottom:4px;font-size:12px;color:#aaa;">寬度</label>
                        <input type="number" id="edit-grad-width" value="${Math.round(obj.width)}" min="20" style="width:100%;padding:8px;background:#2a2a2a;border:1px solid #444;border-radius:6px;color:#fff;">
                    </div>
                    <div>
                        <label style="display:block;margin-bottom:4px;font-size:12px;color:#aaa;">高度</label>
                        <input type="number" id="edit-grad-height" value="${Math.round(obj.height)}" min="20" style="width:100%;padding:8px;background:#2a2a2a;border:1px solid #444;border-radius:6px;color:#fff;">
                    </div>
                </div>
                <div style="display:flex;gap:10px;justify-content:flex-end;">
                    <button onclick="document.getElementById('gradient-edit-dialog').remove()" class="btn btn-outline">取消</button>
                    <button onclick="updateGradientObject(${id})" class="btn btn-primary">更新</button>
                </div>
            `;
            
            document.body.appendChild(dialog);
            makeDraggable(dialog);
        }
        
        // 更新漸層物件
        function updateGradientObject(id) {
            const obj = gradientObjects.find(g => g.id === id);
            if (!obj) return;
            
            obj.type = document.getElementById('edit-grad-type').value;
            obj.shape = document.getElementById('edit-grad-shape').value;
            obj.color1 = document.getElementById('edit-grad-color1').value;
            obj.color2 = document.getElementById('edit-grad-color2').value;
            obj.opacity = parseInt(document.getElementById('edit-grad-opacity').value) / 100;
            obj.width = parseInt(document.getElementById('edit-grad-width').value);
            obj.height = parseInt(document.getElementById('edit-grad-height').value);
            
            document.getElementById('gradient-edit-dialog').remove();
            renderGradientObjects();
            toast('漸層已更新', 'success');
        }
        
        // 合併單個漸層到畫布
        function flattenGradientObject(id) {
            const obj = gradientObjects.find(g => g.id === id);
            if (!obj) return;
            
            saveHistory('漸層填充');
            
            // 將顏色轉換為帶透明度的 rgba
            function hexToRgba(hex, alpha) {
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            }
            
            // 創建漸層
            let gradient;
            const centerX = obj.x + obj.width / 2;
            const centerY = obj.y + obj.height / 2;
            
            if (obj.type === 'radial') {
                const radius = Math.max(obj.width, obj.height) / 2;
                gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
            } else {
                const length = Math.max(obj.width, obj.height);
                const dx = Math.cos(obj.angle) * length;
                const dy = Math.sin(obj.angle) * length;
                gradient = ctx.createLinearGradient(
                    centerX - dx/2, centerY - dy/2,
                    centerX + dx/2, centerY + dy/2
                );
            }
            
            gradient.addColorStop(0, hexToRgba(obj.color1, obj.opacity));
            gradient.addColorStop(1, hexToRgba(obj.color2, obj.opacity));
            
            ctx.save();
            ctx.fillStyle = gradient;
            
            // 根據形狀繪製
            ctx.beginPath();
            switch (obj.shape) {
                case 'circle':
                    const circleRadius = Math.min(obj.width, obj.height) / 2;
                    ctx.arc(centerX, centerY, circleRadius, 0, Math.PI * 2);
                    break;
                case 'ellipse':
                    ctx.ellipse(centerX, centerY, obj.width / 2, obj.height / 2, 0, 0, Math.PI * 2);
                    break;
                case 'roundRect':
                    const cornerRadius = Math.min(obj.width, obj.height) * 0.15;
                    ctx.roundRect(obj.x, obj.y, obj.width, obj.height, cornerRadius);
                    break;
                case 'rect':
                default:
                    ctx.rect(obj.x, obj.y, obj.width, obj.height);
                    break;
            }
            ctx.fill();
            ctx.restore();
            
            // 移除該漸層物件
            gradientObjects = gradientObjects.filter(g => g.id !== id);
            renderGradientObjects();
            
            toast('漸層已合併到圖片', 'success');
            updateUndoButton();
        }
        
        // 合併所有漸層到畫布
        function flattenAllGradients() {
            if (gradientObjects.length === 0) return;
            
            saveHistory('合併所有漸層');
            
            gradientObjects.forEach(obj => {
                // 將顏色轉換為帶透明度的 rgba
                function hexToRgba(hex, alpha) {
                    const r = parseInt(hex.slice(1, 3), 16);
                    const g = parseInt(hex.slice(3, 5), 16);
                    const b = parseInt(hex.slice(5, 7), 16);
                    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
                }
                
                let gradient;
                const centerX = obj.x + obj.width / 2;
                const centerY = obj.y + obj.height / 2;
                
                if (obj.type === 'radial') {
                    const radius = Math.max(obj.width, obj.height) / 2;
                    gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
                } else {
                    const length = Math.max(obj.width, obj.height);
                    const dx = Math.cos(obj.angle) * length;
                    const dy = Math.sin(obj.angle) * length;
                    gradient = ctx.createLinearGradient(
                        centerX - dx/2, centerY - dy/2,
                        centerX + dx/2, centerY + dy/2
                    );
                }
                
                gradient.addColorStop(0, hexToRgba(obj.color1, obj.opacity));
                gradient.addColorStop(1, hexToRgba(obj.color2, obj.opacity));
                
                ctx.save();
                ctx.fillStyle = gradient;
                
                ctx.beginPath();
                switch (obj.shape) {
                    case 'circle':
                        const circleRadius = Math.min(obj.width, obj.height) / 2;
                        ctx.arc(centerX, centerY, circleRadius, 0, Math.PI * 2);
                        break;
                    case 'ellipse':
                        ctx.ellipse(centerX, centerY, obj.width / 2, obj.height / 2, 0, 0, Math.PI * 2);
                        break;
                    case 'roundRect':
                        const cornerRadius = Math.min(obj.width, obj.height) * 0.15;
                        ctx.roundRect(obj.x, obj.y, obj.width, obj.height, cornerRadius);
                        break;
                    case 'rect':
                    default:
                        ctx.rect(obj.x, obj.y, obj.width, obj.height);
                        break;
                }
                ctx.fill();
                ctx.restore();
            });
            
            gradientObjects = [];
            renderGradientObjects();
            
            toast('所有漸層已合併到圖片', 'success');
            updateUndoButton();
        }
        
        // ============ 貼圖表情庫 ============
        
        function openStickerLibrary() {
            const dialog = document.createElement('div');
            dialog.id = 'sticker-library-dialog';
            dialog.style.cssText = `
                position: fixed;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                background: #1a1a1a;
                border: 1px solid #444;
                border-radius: 12px;
                padding: 20px;
                z-index: 10001;
                width: 500px;
                max-height: 80vh;
                overflow-y: auto;
                box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            `;
            
            // 貼圖分類
            const stickerCategories = {
                '😀 表情': ['😀','😃','😄','😁','😆','😅','🤣','😂','🙂','😊','😇','🥰','😍','🤩','😘','😗','😚','😋','😛','😜','🤪','😝','🤑','🤗','🤭','🤫','🤔','🤐','🤨','😐','😑','😶','😏','😒','🙄','😬','🤥','😌','😔','😪','🤤','😴','😷','🤒','🤕','🤢','🤮','🤧','🥵','🥶','🥴','😵','🤯','🤠','🥳','😎','🤓','🧐'],
                '❤️ 愛心': ['❤️','🧡','💛','💚','💙','💜','🖤','🤍','🤎','💔','❣️','💕','💞','💓','💗','💖','💘','💝','💟','♥️','💌','😻','😽','💋','👄'],
                '👍 手勢': ['👍','👎','👊','✊','🤛','🤜','🤝','👏','🙌','👐','🤲','🤚','✋','🖐','👋','🤙','💪','🙏','👈','👉','👆','👇','✌️','🤞','🤟','🤘','🤏','👌','🖕','☝️','✍️','🤳','💅'],
                '🎉 慶祝': ['🎉','🎊','🎈','🎁','🎀','🎄','🎃','🎗️','🏆','🥇','🥈','🥉','🏅','🎖️','⭐','🌟','✨','💫','🔥','💥','💢','💦','💨','🎵','🎶','🎼','🎤','🎧'],
                '⚠️ 符號': ['✅','❌','⭕','❗','❓','❕','❔','‼️','⁉️','💯','🔴','🟠','🟡','🟢','🔵','🟣','⚫','⚪','🟤','🔶','🔷','🔸','🔹','▪️','▫️','◾','◽','⬛','⬜','🔳','🔲'],
                '🌈 自然': ['☀️','🌤','⛅','🌥','☁️','🌦','🌧','⛈','🌩','🌨','❄️','☃️','⛄','🌬','💨','🌈','🌊','💧','💦','🔥','🌸','🌺','🌻','🌹','🌷','🌱','🌿','🍀','🍁','🍂','🍃'],
                '🍔 食物': ['🍎','🍊','🍋','🍌','🍇','🍓','🫐','🍑','🍒','🥝','🍅','🥑','🌽','🥕','🧄','🧅','🥦','🍕','🍔','🍟','🌭','🍿','🧂','🍜','🍣','🍱','🍙','🍚','🍛','🍝'],
                '🐱 動物': ['🐶','🐱','🐭','🐹','🐰','🦊','🐻','🐼','🐨','🐯','🦁','🐮','🐷','🐸','🐵','🙈','🙉','🙊','🐔','🐧','🐦','🐤','🦆','🦅','🦉','🦇','🐺','🐗','🐴','🦄'],
                '🚗 交通': ['🚗','🚕','🚙','🚌','🚎','🏎','🚓','🚑','🚒','🚐','🛻','🚚','🚛','🚜','🏍','🛵','🚲','🛴','🚂','✈️','🚀','🛸','🚁','⛵','🚢','⚓'],
                '📱 物品': ['📱','💻','🖥','🖨','⌨️','🖱','💾','💿','📷','📸','📹','🎥','📺','📻','🎙','⏰','⏱','📡','🔋','💡','🔦','📦','📫','✏️','📝','📁','📂','🗂','📊','📈','📉']
            };
            
            let categoryTabs = '';
            let categoryContents = '';
            
            Object.keys(stickerCategories).forEach((cat, idx) => {
                const isActive = idx === 0;
                categoryTabs += `<button class="sticker-tab ${isActive ? 'active' : ''}" onclick="switchStickerTab('${cat}')" style="padding:8px 12px;border:none;background:${isActive ? '#4a90d9' : '#333'};color:#fff;border-radius:6px;cursor:pointer;font-size:14px;white-space:nowrap;">${cat}</button>`;
                
                categoryContents += `<div class="sticker-content" id="sticker-cat-${cat.replace(/\s/g, '')}" style="display:${isActive ? 'flex' : 'none'};flex-wrap:wrap;gap:5px;">`;
                stickerCategories[cat].forEach(emoji => {
                    categoryContents += `<button onclick="insertSticker('${emoji}')" style="width:40px;height:40px;font-size:24px;border:none;background:#2a2a2a;border-radius:6px;cursor:pointer;transition:transform 0.1s,background 0.2s;" onmouseover="this.style.background='#444';this.style.transform='scale(1.2)'" onmouseout="this.style.background='#2a2a2a';this.style.transform='scale(1)'">${emoji}</button>`;
                });
                categoryContents += '</div>';
            });
            
            dialog.innerHTML = `
                <h3 style="margin:0 0 15px 0;display:flex;justify-content:space-between;align-items:center;">
                    <span>😀 貼圖表情庫</span>
                    <button onclick="document.getElementById('sticker-library-dialog').remove()" 
                        style="background:none;border:none;color:#fff;font-size:20px;cursor:pointer;">×</button>
                </h3>
                <div style="display:flex;gap:8px;margin-bottom:15px;overflow-x:auto;padding-bottom:5px;">
                    ${categoryTabs}
                </div>
                <div id="sticker-contents" style="min-height:200px;">
                    ${categoryContents}
                </div>
                <div style="border-top:1px solid #333;padding-top:15px;margin-top:15px;">
                    <label style="display:block;margin-bottom:8px;font-size:12px;color:#aaa;">貼圖大小</label>
                    <div style="display:flex;align-items:center;gap:10px;">
                        <input type="range" id="sticker-size" min="20" max="200" value="60" 
                            oninput="document.getElementById('sticker-size-val').textContent=this.value+'px'"
                            style="flex:1;">
                        <span id="sticker-size-val" style="font-size:12px;color:#fff;min-width:50px;">60px</span>
                    </div>
                </div>
                <div style="background:#2a2a2a;padding:10px;border-radius:6px;margin-top:10px;">
                    <div style="font-size:11px;color:#888;">💡 點擊貼圖後，在畫布上點擊放置位置，可拖拉移動</div>
                </div>
            `;
            
            document.body.appendChild(dialog);
        }
        
        // 切換貼圖分類
        function switchStickerTab(cat) {
            document.querySelectorAll('.sticker-tab').forEach(tab => {
                tab.style.background = '#333';
            });
            event.target.style.background = '#4a90d9';
            
            document.querySelectorAll('.sticker-content').forEach(content => {
                content.style.display = 'none';
            });
            const catId = 'sticker-cat-' + cat.replace(/\s/g, '');
            document.getElementById(catId).style.display = 'flex';
        }
        
        // 插入貼圖
        function insertSticker(emoji) {
            const size = parseInt(document.getElementById('sticker-size').value);
            document.getElementById('sticker-library-dialog').remove();
            
            // 創建貼圖物件
            const stickerObj = {
                id: Date.now(),
                type: 'sticker',
                emoji: emoji,
                x: canvas.width / 2 - size / 2,
                y: canvas.height / 2 - size / 2,
                size: size
            };
            
            // 加入文字物件陣列（可共用拖拉功能）
            const textObj = {
                id: stickerObj.id,
                text: emoji,
                x: stickerObj.x,
                y: stickerObj.y,
                font: 'Arial',
                size: size,
                color: '#000000',
                bgColor: '#ffffff',
                bgType: 'none',
                weight: 'normal',
                stroke: 0,
                strokeColor: '#ffffff',
                direction: 'horizontal',
                transform: 'none',
                transformAmount: 50,
                isSticker: true,
                layerIndex: activeLayerIndex // 記錄所屬圖層
            };
            
            // 計算尺寸
            textObj.width = size + 10;
            textObj.height = size + 10;
            
            textObjects.push(textObj);
            renderTextObjects();
            
            toast(`已添加貼圖 ${emoji}，可拖拉移動`, 'success');
        }
        
        // ============ 特殊效果 ============
        
        function openSpecialEffects() {
            if (!state.image) {
                toast('請先載入圖片', 'error');
                return;
            }
            
            const dialog = document.createElement('div');
            dialog.id = 'special-effects-dialog';
            dialog.style.cssText = `
                position: fixed;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                background: #1a1a1a;
                border: 1px solid #444;
                border-radius: 12px;
                padding: 20px;
                z-index: 10000;
                min-width: 350px;
                box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            `;
            
            dialog.innerHTML = `
                <h3 style="margin:0 0 15px 0;display:flex;justify-content:space-between;align-items:center;">
                    <span>✨ 特殊效果</span>
                    <button onclick="document.getElementById('special-effects-dialog').remove()" 
                        style="background:none;border:none;color:#fff;font-size:20px;cursor:pointer;">×</button>
                </h3>
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;">
                    <button onclick="applyVintageEffect();document.getElementById('special-effects-dialog').remove()" class="btn btn-outline" style="padding:15px;font-size:14px;">
                        📷 老照片效果
                    </button>
                    <button onclick="applyComicEffect();document.getElementById('special-effects-dialog').remove()" class="btn btn-outline" style="padding:15px;font-size:14px;">
                        🎭 漫畫效果
                    </button>
                    <button onclick="applySepiaEffect();document.getElementById('special-effects-dialog').remove()" class="btn btn-outline" style="padding:15px;font-size:14px;">
                        🟤 復古褐色
                    </button>
                    <button onclick="applySketchEffect();document.getElementById('special-effects-dialog').remove()" class="btn btn-outline" style="padding:15px;font-size:14px;">
                        ✏️ 素描效果
                    </button>
                    <button onclick="applyNegativeEffect();document.getElementById('special-effects-dialog').remove()" class="btn btn-outline" style="padding:15px;font-size:14px;">
                        🔄 負片效果
                    </button>
                    <button onclick="applyEmbossEffect();document.getElementById('special-effects-dialog').remove()" class="btn btn-outline" style="padding:15px;font-size:14px;">
                        🏛️ 浮雕效果
                    </button>
                    <button onclick="applyPixelateEffect();document.getElementById('special-effects-dialog').remove()" class="btn btn-outline" style="padding:15px;font-size:14px;">
                        🎮 像素化
                    </button>
                    <button onclick="applyVignetteEffect();document.getElementById('special-effects-dialog').remove()" class="btn btn-outline" style="padding:15px;font-size:14px;">
                        🔲 暈影效果
                    </button>
                </div>
            `;
            
            document.body.appendChild(dialog);
        }
        
        // 老照片效果
        function applyVintageEffect() {
            saveHistory('老照片效果');
            toast('正在套用老照片效果...', 'info');
            
            setTimeout(() => {
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    
                    // 褐色調
                    data[i] = Math.min(255, r * 0.9 + 40);
                    data[i + 1] = Math.min(255, g * 0.7 + 20);
                    data[i + 2] = Math.min(255, b * 0.5);
                    
                    // 降低對比度
                    data[i] = data[i] * 0.9 + 25;
                    data[i + 1] = data[i + 1] * 0.9 + 20;
                    data[i + 2] = data[i + 2] * 0.9 + 15;
                    
                    // 添加雜訊
                    const noise = (Math.random() - 0.5) * 20;
                    data[i] = Math.max(0, Math.min(255, data[i] + noise));
                    data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + noise));
                    data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + noise));
                }
                
                ctx.putImageData(imageData, 0, 0);
                
                // 添加暈影
                const gradient = ctx.createRadialGradient(
                    canvas.width / 2, canvas.height / 2, canvas.width * 0.2,
                    canvas.width / 2, canvas.height / 2, canvas.width * 0.7
                );
                gradient.addColorStop(0, 'rgba(0,0,0,0)');
                gradient.addColorStop(1, 'rgba(0,0,0,0.4)');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                toast('老照片效果已套用', 'success');
                updateUndoButton();
            }, 100);
        }
        
        // 漫畫效果
        function applyComicEffect() {
            saveHistory('漫畫效果');
            toast('正在套用漫畫效果...', 'info');
            
            setTimeout(() => {
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                const width = canvas.width;
                const height = canvas.height;
                
                // 先做色彩量化（減少顏色數量）
                const levels = 6;
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = Math.round(data[i] / (256 / levels)) * (256 / levels);
                    data[i + 1] = Math.round(data[i + 1] / (256 / levels)) * (256 / levels);
                    data[i + 2] = Math.round(data[i + 2] / (256 / levels)) * (256 / levels);
                }
                
                // 增加飽和度
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    const gray = (r + g + b) / 3;
                    const saturation = 1.5;
                    
                    data[i] = Math.max(0, Math.min(255, gray + (r - gray) * saturation));
                    data[i + 1] = Math.max(0, Math.min(255, gray + (g - gray) * saturation));
                    data[i + 2] = Math.max(0, Math.min(255, gray + (b - gray) * saturation));
                }
                
                ctx.putImageData(imageData, 0, 0);
                
                // 邊緣檢測（簡化版）
                const edgeData = ctx.getImageData(0, 0, width, height);
                const edge = edgeData.data;
                const original = new Uint8ClampedArray(data);
                
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        const idx = (y * width + x) * 4;
                        
                        // Sobel 算子
                        const gx = 
                            -original[(y - 1) * width * 4 + (x - 1) * 4] +
                            original[(y - 1) * width * 4 + (x + 1) * 4] +
                            -2 * original[y * width * 4 + (x - 1) * 4] +
                            2 * original[y * width * 4 + (x + 1) * 4] +
                            -original[(y + 1) * width * 4 + (x - 1) * 4] +
                            original[(y + 1) * width * 4 + (x + 1) * 4];
                        
                        const gy = 
                            -original[(y - 1) * width * 4 + (x - 1) * 4] +
                            -2 * original[(y - 1) * width * 4 + x * 4] +
                            -original[(y - 1) * width * 4 + (x + 1) * 4] +
                            original[(y + 1) * width * 4 + (x - 1) * 4] +
                            2 * original[(y + 1) * width * 4 + x * 4] +
                            original[(y + 1) * width * 4 + (x + 1) * 4];
                        
                        const magnitude = Math.sqrt(gx * gx + gy * gy);
                        
                        if (magnitude > 50) {
                            edge[idx] = 0;
                            edge[idx + 1] = 0;
                            edge[idx + 2] = 0;
                        }
                    }
                }
                
                ctx.putImageData(edgeData, 0, 0);
                toast('漫畫效果已套用', 'success');
                updateUndoButton();
            }, 100);
        }
        
        // 復古褐色
        function applySepiaEffect() {
            saveHistory('復古褐色');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                
                data[i] = Math.min(255, r * 0.393 + g * 0.769 + b * 0.189);
                data[i + 1] = Math.min(255, r * 0.349 + g * 0.686 + b * 0.168);
                data[i + 2] = Math.min(255, r * 0.272 + g * 0.534 + b * 0.131);
            }
            
            ctx.putImageData(imageData, 0, 0);
            toast('復古褐色已套用', 'success');
            updateUndoButton();
        }
        
        // 素描效果
        function applySketchEffect() {
            saveHistory('素描效果');
            toast('正在套用素描效果...', 'info');
            
            setTimeout(() => {
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                const width = canvas.width;
                const height = canvas.height;
                
                // 灰階化
                const gray = new Uint8ClampedArray(width * height);
                for (let i = 0; i < data.length; i += 4) {
                    gray[i / 4] = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                }
                
                // 反轉並模糊
                const inverted = gray.map(v => 255 - v);
                
                // 簡單模糊
                const blurred = new Uint8ClampedArray(width * height);
                const blurRadius = 2;
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        let sum = 0, count = 0;
                        for (let dy = -blurRadius; dy <= blurRadius; dy++) {
                            for (let dx = -blurRadius; dx <= blurRadius; dx++) {
                                const nx = x + dx, ny = y + dy;
                                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                    sum += inverted[ny * width + nx];
                                    count++;
                                }
                            }
                        }
                        blurred[y * width + x] = sum / count;
                    }
                }
                
                // 顏色減淡混合
                for (let i = 0; i < data.length; i += 4) {
                    const idx = i / 4;
                    const a = gray[idx];
                    const b = blurred[idx];
                    const result = b === 255 ? 255 : Math.min(255, (a * 256) / (256 - b));
                    
                    data[i] = result;
                    data[i + 1] = result;
                    data[i + 2] = result;
                }
                
                ctx.putImageData(imageData, 0, 0);
                toast('素描效果已套用', 'success');
                updateUndoButton();
            }, 100);
        }
        
        // 負片效果
        function applyNegativeEffect() {
            saveHistory('負片效果');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            for (let i = 0; i < data.length; i += 4) {
                data[i] = 255 - data[i];
                data[i + 1] = 255 - data[i + 1];
                data[i + 2] = 255 - data[i + 2];
            }
            
            ctx.putImageData(imageData, 0, 0);
            toast('負片效果已套用', 'success');
            updateUndoButton();
        }
        
        // 浮雕效果
        function applyEmbossEffect() {
            saveHistory('浮雕效果');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const width = canvas.width;
            const original = new Uint8ClampedArray(data);
            
            for (let y = 1; y < canvas.height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = (y * width + x) * 4;
                    const idxPrev = ((y - 1) * width + (x - 1)) * 4;
                    
                    for (let c = 0; c < 3; c++) {
                        const diff = original[idx + c] - original[idxPrev + c];
                        data[idx + c] = 128 + diff;
                    }
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
            toast('浮雕效果已套用', 'success');
            updateUndoButton();
        }
        
        // 像素化效果
        function applyPixelateEffect() {
            const size = parseInt(prompt('請輸入像素大小 (5-50):', '10'));
            if (!size || size < 5 || size > 50) return;
            
            saveHistory('像素化');
            const width = canvas.width;
            const height = canvas.height;
            
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            
            for (let y = 0; y < height; y += size) {
                for (let x = 0; x < width; x += size) {
                    let r = 0, g = 0, b = 0, count = 0;
                    
                    // 計算區塊平均顏色
                    for (let dy = 0; dy < size && y + dy < height; dy++) {
                        for (let dx = 0; dx < size && x + dx < width; dx++) {
                            const idx = ((y + dy) * width + (x + dx)) * 4;
                            r += data[idx];
                            g += data[idx + 1];
                            b += data[idx + 2];
                            count++;
                        }
                    }
                    
                    r = Math.round(r / count);
                    g = Math.round(g / count);
                    b = Math.round(b / count);
                    
                    // 填充區塊
                    for (let dy = 0; dy < size && y + dy < height; dy++) {
                        for (let dx = 0; dx < size && x + dx < width; dx++) {
                            const idx = ((y + dy) * width + (x + dx)) * 4;
                            data[idx] = r;
                            data[idx + 1] = g;
                            data[idx + 2] = b;
                        }
                    }
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
            toast('像素化已套用', 'success');
            updateUndoButton();
        }
        
        // 暈影效果
        function applyVignetteEffect() {
            saveHistory('暈影效果');
            
            const gradient = ctx.createRadialGradient(
                canvas.width / 2, canvas.height / 2, canvas.width * 0.2,
                canvas.width / 2, canvas.height / 2, canvas.width * 0.7
            );
            gradient.addColorStop(0, 'rgba(0,0,0,0)');
            gradient.addColorStop(1, 'rgba(0,0,0,0.6)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            toast('暈影效果已套用', 'success');
            updateUndoButton();
        }
        
        // ============ 社群尺寸預設 ============
        
        function openSocialSizeDialog() {
            const dialog = document.createElement('div');
            dialog.id = 'social-size-dialog';
            dialog.style.cssText = `
                position: fixed;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                background: #1a1a1a;
                border: 1px solid #444;
                border-radius: 12px;
                padding: 20px;
                z-index: 10000;
                min-width: 450px;
                max-height: 80vh;
                overflow-y: auto;
                box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            `;
            
            dialog.innerHTML = `
                <h3 style="margin:0 0 15px 0;display:flex;justify-content:space-between;align-items:center;">
                    <span>📱 社群尺寸預設</span>
                    <button onclick="document.getElementById('social-size-dialog').remove()" 
                        style="background:none;border:none;color:#fff;font-size:20px;cursor:pointer;">×</button>
                </h3>
                
                <div style="margin-bottom:15px;">
                    <h4 style="margin:0 0 10px 0;color:#6366f1;">📸 Instagram</h4>
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;">
                        <button onclick="resizeToSocial(1080,1080,'IG 貼文 1:1')" class="btn btn-outline">貼文 1:1 (1080×1080)</button>
                        <button onclick="resizeToSocial(1080,1350,'IG 貼文 4:5')" class="btn btn-outline">貼文 4:5 (1080×1350)</button>
                        <button onclick="resizeToSocial(1080,1920,'IG 限時動態')" class="btn btn-outline">限時動態 (1080×1920)</button>
                        <button onclick="resizeToSocial(1080,566,'IG 橫向')" class="btn btn-outline">橫向 (1080×566)</button>
                    </div>
                </div>
                
                <div style="margin-bottom:15px;">
                    <h4 style="margin:0 0 10px 0;color:#1877f2;">👍 Facebook</h4>
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;">
                        <button onclick="resizeToSocial(1200,630,'FB 貼文')" class="btn btn-outline">貼文 (1200×630)</button>
                        <button onclick="resizeToSocial(820,312,'FB 封面')" class="btn btn-outline">封面 (820×312)</button>
                        <button onclick="resizeToSocial(1080,1920,'FB 限動')" class="btn btn-outline">限時動態 (1080×1920)</button>
                        <button onclick="resizeToSocial(1200,1200,'FB 方形')" class="btn btn-outline">方形 (1200×1200)</button>
                    </div>
                </div>
                
                <div style="margin-bottom:15px;">
                    <h4 style="margin:0 0 10px 0;color:#ff0000;">▶️ YouTube</h4>
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;">
                        <button onclick="resizeToSocial(1280,720,'YT 縮圖 720p')" class="btn btn-outline">縮圖 720p (1280×720)</button>
                        <button onclick="resizeToSocial(1920,1080,'YT 縮圖 1080p')" class="btn btn-outline">縮圖 1080p (1920×1080)</button>
                        <button onclick="resizeToSocial(2560,1440,'YT 封面')" class="btn btn-outline">頻道封面 (2560×1440)</button>
                        <button onclick="resizeToSocial(800,800,'YT 頭像')" class="btn btn-outline">頻道頭像 (800×800)</button>
                    </div>
                </div>
                
                <div style="margin-bottom:15px;">
                    <h4 style="margin:0 0 10px 0;color:#1da1f2;">🐦 Twitter/X</h4>
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;">
                        <button onclick="resizeToSocial(1200,675,'X 貼文')" class="btn btn-outline">貼文 (1200×675)</button>
                        <button onclick="resizeToSocial(1500,500,'X 封面')" class="btn btn-outline">封面 (1500×500)</button>
                        <button onclick="resizeToSocial(400,400,'X 頭像')" class="btn btn-outline">頭像 (400×400)</button>
                    </div>
                </div>
                
                <div style="margin-bottom:15px;">
                    <h4 style="margin:0 0 10px 0;color:#0077b5;">💼 LinkedIn</h4>
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;">
                        <button onclick="resizeToSocial(1200,627,'LinkedIn 貼文')" class="btn btn-outline">貼文 (1200×627)</button>
                        <button onclick="resizeToSocial(1584,396,'LinkedIn 封面')" class="btn btn-outline">封面 (1584×396)</button>
                    </div>
                </div>
                
                <div style="margin-bottom:15px;">
                    <h4 style="margin:0 0 10px 0;color:#e60023;">📌 Pinterest</h4>
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;">
                        <button onclick="resizeToSocial(1000,1500,'Pinterest Pin')" class="btn btn-outline">Pin 2:3 (1000×1500)</button>
                        <button onclick="resizeToSocial(1000,2100,'Pinterest 長圖')" class="btn btn-outline">長圖 (1000×2100)</button>
                    </div>
                </div>
                
                <div style="margin-bottom:15px;">
                    <h4 style="margin:0 0 10px 0;color:#25d366;">📱 其他常用</h4>
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;">
                        <button onclick="resizeToSocial(1920,1080,'Full HD')" class="btn btn-outline">Full HD (1920×1080)</button>
                        <button onclick="resizeToSocial(3840,2160,'4K')" class="btn btn-outline">4K (3840×2160)</button>
                        <button onclick="resizeToSocial(1080,1920,'手機直式')" class="btn btn-outline">手機直式 (1080×1920)</button>
                        <button onclick="resizeToSocial(2480,3508,'A4 列印')" class="btn btn-outline">A4 300dpi (2480×3508)</button>
                    </div>
                </div>
                
                <div style="border-top:1px solid #333;padding-top:15px;margin-top:10px;">
                    <h4 style="margin:0 0 10px 0;color:#aaa;">🔧 自訂尺寸</h4>
                    <div style="display:flex;gap:10px;align-items:center;">
                        <input type="number" id="custom-width" placeholder="寬度" style="width:80px;padding:8px;background:#2a2a2a;border:1px solid #444;border-radius:6px;color:#fff;">
                        <span>×</span>
                        <input type="number" id="custom-height" placeholder="高度" style="width:80px;padding:8px;background:#2a2a2a;border:1px solid #444;border-radius:6px;color:#fff;">
                        <button onclick="resizeToCustom()" class="btn btn-primary">套用</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(dialog);
        }
        
        function resizeToSocial(width, height, name) {
            if (!state.image) {
                toast('請先載入圖片', 'error');
                return;
            }
            
            const fitMode = confirm(`調整為 ${name} (${width}×${height})\n\n確定 = 等比縮放並裁切\n取消 = 等比縮放並留白`);
            
            saveHistory('調整尺寸');
            
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = width;
            tempCanvas.height = height;
            const tempCtx = tempCanvas.getContext('2d');
            
            // 白色背景
            tempCtx.fillStyle = '#ffffff';
            tempCtx.fillRect(0, 0, width, height);
            
            const srcRatio = canvas.width / canvas.height;
            const dstRatio = width / height;
            
            let sx, sy, sw, sh, dx, dy, dw, dh;
            
            if (fitMode) {
                // 裁切模式（填滿）
                if (srcRatio > dstRatio) {
                    sh = canvas.height;
                    sw = sh * dstRatio;
                    sx = (canvas.width - sw) / 2;
                    sy = 0;
                } else {
                    sw = canvas.width;
                    sh = sw / dstRatio;
                    sx = 0;
                    sy = (canvas.height - sh) / 2;
                }
                dx = 0;
                dy = 0;
                dw = width;
                dh = height;
            } else {
                // 留白模式（完整顯示）
                sx = 0;
                sy = 0;
                sw = canvas.width;
                sh = canvas.height;
                
                if (srcRatio > dstRatio) {
                    dw = width;
                    dh = dw / srcRatio;
                    dx = 0;
                    dy = (height - dh) / 2;
                } else {
                    dh = height;
                    dw = dh * srcRatio;
                    dx = (width - dw) / 2;
                    dy = 0;
                }
            }
            
            tempCtx.drawImage(canvas, sx, sy, sw, sh, dx, dy, dw, dh);
            
            // 更新畫布
            canvas.width = width;
            canvas.height = height;
            ctx.drawImage(tempCanvas, 0, 0);
            
            state.image = { width, height };
            
            document.getElementById('social-size-dialog').remove();
            fitCanvasToScreen();
            toast(`已調整為 ${name} (${width}×${height})`, 'success');
            updateUndoButton();
        }
        
        function resizeToCustom() {
            const width = parseInt(document.getElementById('custom-width').value);
            const height = parseInt(document.getElementById('custom-height').value);
            
            if (!width || !height || width < 1 || height < 1) {
                toast('請輸入有效的尺寸', 'warning');
                return;
            }
            
            resizeToSocial(width, height, '自訂尺寸');
        }

        // ============ 顏色替換功能 ============
        
        let colorReplacePickingFrom = false;
        let colorReplaceRegion = null; // 儲存框選區域 { x, y, w, h }
        
        function openColorReplaceDialog() {
            if (!state.image) {
                toast('請先載入圖片', 'error');
                return;
            }
            
            // 檢查是否有框選區域（從最近的框選操作）
            if (state.selectBox && state.selectBox.w > 0 && state.selectBox.h > 0) {
                colorReplaceRegion = { ...state.selectBox };
            }
            
            document.getElementById('color-replace-dialog').classList.add('show');
            updateColorReplacePreview();
            updateColorReplaceMode();
            
            // 綁定事件
            document.getElementById('color-replace-from').oninput = updateColorReplacePreview;
            document.getElementById('color-replace-to').oninput = updateColorReplacePreview;
            document.getElementById('color-replace-tolerance').oninput = function() {
                document.getElementById('color-replace-tolerance-val').textContent = this.value;
            };
        }
        
        function closeColorReplaceDialog() {
            document.getElementById('color-replace-dialog').classList.remove('show');
            colorReplacePickingFrom = false;
        }
        
        function updateColorReplaceMode() {
            const mode = document.querySelector('input[name="color-replace-mode"]:checked').value;
            const hint = document.getElementById('color-replace-region-hint');
            const selectBtn = document.getElementById('btn-select-region');
            
            if (mode === 'region') {
                selectBtn.style.display = 'block';
                if (colorReplaceRegion && colorReplaceRegion.w > 0) {
                    hint.style.display = 'block';
                    hint.style.color = '#10b981';
                    hint.innerHTML = `✅ 已選擇區域: ${colorReplaceRegion.w} × ${colorReplaceRegion.h} 像素`;
                } else {
                    hint.style.display = 'block';
                    hint.style.color = '#f59e0b';
                    hint.innerHTML = '⚠️ 尚未選擇區域，請點擊「📐 框選區域」按鈕';
                }
            } else {
                hint.style.display = 'none';
                selectBtn.style.display = 'none';
            }
        }
        
        function selectColorReplaceRegion() {
            closeColorReplaceDialog();
            setMode('select');
            toast('請在圖片上框選要換色的區域，完成後再次點擊「🎨 換色」按鈕', 'info');
            
            // 設定回調，框選完成後自動記錄區域
            state.onSelectComplete = function(x, y, w, h) {
                colorReplaceRegion = { x, y, w, h };
                state.onSelectComplete = null;
                toast('已選擇區域，請點擊「🎨 換色」按鈕繼續', 'success');
            };
        }
        
        function updateColorReplacePreview() {
            const fromColor = document.getElementById('color-replace-from').value;
            const toColor = document.getElementById('color-replace-to').value;
            document.getElementById('color-preview-from').style.background = fromColor;
            document.getElementById('color-preview-from').style.color = isLightColor(fromColor) ? '#000' : '#fff';
            document.getElementById('color-preview-to').style.background = toColor;
            document.getElementById('color-preview-to').style.color = isLightColor(toColor) ? '#000' : '#fff';
        }
        
        function isLightColor(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return (r * 299 + g * 587 + b * 114) / 1000 > 128;
        }
        
        function pickColorFrom() {
            colorReplacePickingFrom = true;
            closeColorReplaceDialog();
            setMode('eyedropper');
            state.eyedropperTarget = 'colorReplaceFrom';
            toast('請在圖片上點擊選取來源顏色', 'info');
        }
        
        function previewColorReplace() {
            applyColorReplace(true);
        }
        
        function applyColorReplace(previewOnly = false) {
            if (!state.image) return;
            
            const mode = document.querySelector('input[name="color-replace-mode"]:checked').value;
            const fromColor = document.getElementById('color-replace-from').value;
            const toColor = document.getElementById('color-replace-to').value;
            const tolerance = parseInt(document.getElementById('color-replace-tolerance').value);
            
            // 檢查區域模式
            if (mode === 'region' && (!colorReplaceRegion || colorReplaceRegion.w <= 0)) {
                toast('請先框選要換色的區域', 'warning');
                return;
            }
            
            const fromR = parseInt(fromColor.slice(1, 3), 16);
            const fromG = parseInt(fromColor.slice(3, 5), 16);
            const fromB = parseInt(fromColor.slice(5, 7), 16);
            
            const toR = parseInt(toColor.slice(1, 3), 16);
            const toG = parseInt(toColor.slice(3, 5), 16);
            const toB = parseInt(toColor.slice(5, 7), 16);
            
            if (!previewOnly) {
                saveHistory('顏色替換');
            }
            
            let imageData, startX = 0, startY = 0;
            
            if (mode === 'region' && colorReplaceRegion) {
                // 區域換色
                startX = Math.max(0, Math.round(colorReplaceRegion.x));
                startY = Math.max(0, Math.round(colorReplaceRegion.y));
                const w = Math.min(canvas.width - startX, Math.round(colorReplaceRegion.w));
                const h = Math.min(canvas.height - startY, Math.round(colorReplaceRegion.h));
                imageData = ctx.getImageData(startX, startY, w, h);
            } else {
                // 全圖換色
                imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            }
            
            const data = imageData.data;
            let replacedCount = 0;
            
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                
                // 計算顏色距離
                const distance = Math.sqrt(
                    Math.pow(r - fromR, 2) +
                    Math.pow(g - fromG, 2) +
                    Math.pow(b - fromB, 2)
                );
                
                if (distance <= tolerance * 4.41) {
                    data[i] = toR;
                    data[i + 1] = toG;
                    data[i + 2] = toB;
                    replacedCount++;
                }
            }
            
            ctx.putImageData(imageData, startX, startY);
            
            const modeText = mode === 'region' ? '區域內' : '全圖';
            if (previewOnly) {
                toast(`預覽：${modeText}已替換 ${replacedCount} 個像素`, 'info');
            } else {
                closeColorReplaceDialog();
                toast(`${modeText}已替換 ${replacedCount} 個像素`, 'success');
            }
        }
        
        // ============ 智能去背功能 ============
        
        function removeBackground() {
            if (!state.image) {
                toast('請先載入圖片', 'error');
                return;
            }
            
            // 顯示選項
            const bgColor = prompt(
                '請選擇去背方式：\n' +
                '1. 輸入顏色代碼（如 #ffffff 去除白色背景）\n' +
                '2. 輸入 "auto" 自動偵測背景色\n' +
                '3. 輸入 "edge" 使用邊緣偵測',
                'auto'
            );
            
            if (!bgColor) return;
            
            saveHistory('智能去背');
            document.getElementById('remove-bg-progress').classList.add('show');
            
            setTimeout(() => {
                try {
                    if (bgColor.toLowerCase() === 'auto') {
                        autoRemoveBackground();
                    } else if (bgColor.toLowerCase() === 'edge') {
                        edgeRemoveBackground();
                    } else {
                        colorRemoveBackground(bgColor);
                    }
                } catch (err) {
                    toast('去背處理失敗: ' + err.message, 'error');
                }
                document.getElementById('remove-bg-progress').classList.remove('show');
            }, 100);
        }
        
        // 自動偵測背景色並去除
        function autoRemoveBackground() {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // 從四個角落取樣背景色
            const corners = [
                getPixelColor(data, 0, 0, canvas.width),
                getPixelColor(data, canvas.width - 1, 0, canvas.width),
                getPixelColor(data, 0, canvas.height - 1, canvas.width),
                getPixelColor(data, canvas.width - 1, canvas.height - 1, canvas.width)
            ];
            
            // 找出最常見的角落顏色
            const colorCounts = {};
            corners.forEach(c => {
                const key = `${c.r},${c.g},${c.b}`;
                colorCounts[key] = (colorCounts[key] || 0) + 1;
            });
            
            let bgColorKey = Object.keys(colorCounts).reduce((a, b) => 
                colorCounts[a] > colorCounts[b] ? a : b
            );
            
            const [bgR, bgG, bgB] = bgColorKey.split(',').map(Number);
            const tolerance = 30;
            
            let removedCount = 0;
            for (let i = 0; i < data.length; i += 4) {
                const distance = Math.sqrt(
                    Math.pow(data[i] - bgR, 2) +
                    Math.pow(data[i + 1] - bgG, 2) +
                    Math.pow(data[i + 2] - bgB, 2)
                );
                
                if (distance <= tolerance * 4.41) {
                    data[i + 3] = 0; // 設為透明
                    removedCount++;
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
            toast(`自動去背完成，已移除 ${removedCount} 個像素`, 'success');
        }
        
        // 指定顏色去背
        function colorRemoveBackground(colorHex) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // 解析顏色
            let bgR, bgG, bgB;
            if (colorHex.startsWith('#')) {
                bgR = parseInt(colorHex.slice(1, 3), 16);
                bgG = parseInt(colorHex.slice(3, 5), 16);
                bgB = parseInt(colorHex.slice(5, 7), 16);
            } else {
                toast('無效的顏色格式', 'error');
                return;
            }
            
            const tolerance = 35;
            let removedCount = 0;
            
            for (let i = 0; i < data.length; i += 4) {
                const distance = Math.sqrt(
                    Math.pow(data[i] - bgR, 2) +
                    Math.pow(data[i + 1] - bgG, 2) +
                    Math.pow(data[i + 2] - bgB, 2)
                );
                
                if (distance <= tolerance * 4.41) {
                    data[i + 3] = 0;
                    removedCount++;
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
            toast(`已移除 ${removedCount} 個 ${colorHex} 像素`, 'success');
        }
        
        // 邊緣偵測去背
        function edgeRemoveBackground() {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const width = canvas.width;
            const height = canvas.height;
            
            // 從邊緣開始 flood fill
            const visited = new Uint8Array(width * height);
            const bgColor = getPixelColor(data, 0, 0, width);
            const tolerance = 40;
            
            const stack = [];
            
            // 從四邊開始
            for (let x = 0; x < width; x++) {
                stack.push([x, 0]);
                stack.push([x, height - 1]);
            }
            for (let y = 0; y < height; y++) {
                stack.push([0, y]);
                stack.push([width - 1, y]);
            }
            
            let removedCount = 0;
            
            while (stack.length > 0) {
                const [x, y] = stack.pop();
                
                if (x < 0 || x >= width || y < 0 || y >= height) continue;
                
                const idx = y * width + x;
                if (visited[idx]) continue;
                visited[idx] = 1;
                
                const pixelIdx = idx * 4;
                const distance = Math.sqrt(
                    Math.pow(data[pixelIdx] - bgColor.r, 2) +
                    Math.pow(data[pixelIdx + 1] - bgColor.g, 2) +
                    Math.pow(data[pixelIdx + 2] - bgColor.b, 2)
                );
                
                if (distance <= tolerance * 4.41) {
                    data[pixelIdx + 3] = 0;
                    removedCount++;
                    
                    stack.push([x + 1, y]);
                    stack.push([x - 1, y]);
                    stack.push([x, y + 1]);
                    stack.push([x, y - 1]);
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
            toast(`邊緣去背完成，已移除 ${removedCount} 個像素`, 'success');
        }
        
        // 輔助函數：獲取像素顏色
        function getPixelColor(data, x, y, width) {
            const idx = (y * width + x) * 4;
            return {
                r: data[idx],
                g: data[idx + 1],
                b: data[idx + 2],
                a: data[idx + 3]
            };
        }
        
        // ============ 頁面縮圖功能 ============
        let thumbnailsPanelVisible = false;
        
        function togglePageThumbnails() {
            const panel = document.getElementById('page-thumbnails-panel');
            const main = document.querySelector('.main');
            thumbnailsPanelVisible = !thumbnailsPanelVisible;
            
            if (thumbnailsPanelVisible) {
                panel.classList.add('show');
                main.classList.add('with-thumbnails');
                document.getElementById('btn-thumbnails').classList.add('active');
                updatePageThumbnails();
            } else {
                panel.classList.remove('show');
                main.classList.remove('with-thumbnails');
                document.getElementById('btn-thumbnails').classList.remove('active');
            }
        }
        
        async function updatePageThumbnails() {
            const list = document.getElementById('thumbnails-list');
            
            if (state.pdfPages.length === 0) {
                list.innerHTML = '<div style="text-align:center;color:#888;padding:40px 10px;font-size:12px;">載入 PDF 後顯示縮圖</div>';
                return;
            }
            
            list.innerHTML = '';
            
            for (let i = 0; i < state.pdfPages.length; i++) {
                const pageData = state.pdfPages[i];
                const item = document.createElement('div');
                item.className = 'thumbnail-item' + (i === state.currentPdfPage ? ' active' : '');
                item.dataset.index = i;
                item.draggable = true;
                
                // 縮圖圖片
                const img = document.createElement('img');
                img.src = pageData.editedData || pageData.dataUrl;
                img.alt = `第 ${i + 1} 頁`;
                
                // 頁碼標籤
                const number = document.createElement('div');
                number.className = 'thumbnail-number';
                number.textContent = i + 1;
                
                // 操作按鈕
                const actions = document.createElement('div');
                actions.className = 'thumbnail-actions';
                actions.innerHTML = `
                    <button class="thumbnail-action-btn" onclick="event.stopPropagation();rotateThumbnailPage(${i})" title="旋轉">↻</button>
                    <button class="thumbnail-action-btn" onclick="event.stopPropagation();duplicateThumbnailPage(${i})" title="複製">📋</button>
                    <button class="thumbnail-action-btn" onclick="event.stopPropagation();deleteThumbnailPage(${i})" title="刪除" style="background:#ef4444;">🗑️</button>
                `;
                
                item.appendChild(img);
                item.appendChild(number);
                item.appendChild(actions);
                
                // 點擊切換頁面
                item.onclick = () => goToThumbnailPage(i);
                
                // 拖拉排序事件
                item.ondragstart = (e) => {
                    e.dataTransfer.setData('text/plain', i);
                    item.classList.add('dragging');
                };
                
                item.ondragend = () => {
                    item.classList.remove('dragging');
                };
                
                item.ondragover = (e) => {
                    e.preventDefault();
                    item.classList.add('drag-over');
                };
                
                item.ondragleave = () => {
                    item.classList.remove('drag-over');
                };
                
                item.ondrop = (e) => {
                    e.preventDefault();
                    item.classList.remove('drag-over');
                    const fromIndex = parseInt(e.dataTransfer.getData('text/plain'));
                    const toIndex = i;
                    if (fromIndex !== toIndex) {
                        reorderPages(fromIndex, toIndex);
                    }
                };
                
                list.appendChild(item);
            }
        }
        
        async function goToThumbnailPage(index) {
            if (index === state.currentPdfPage) return;
            
            // 保存當前頁面
            state.pdfPages[state.currentPdfPage].editedData = canvas.toDataURL('image/jpeg', 0.92);
            state.pdfPages[state.currentPdfPage].regions = JSON.parse(JSON.stringify(state.regions));
            
            state.currentPdfPage = index;
            await loadPdfPageToCanvas(state.currentPdfPage);
            updatePageThumbnails();
        }
        
        async function rotateThumbnailPage(index) {
            const pageData = state.pdfPages[index];
            const img = await loadImageFromUrl(pageData.editedData || pageData.dataUrl);
            
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = img.height;
            tempCanvas.height = img.width;
            const tempCtx = tempCanvas.getContext('2d');
            
            tempCtx.translate(tempCanvas.width / 2, tempCanvas.height / 2);
            tempCtx.rotate(90 * Math.PI / 180);
            tempCtx.drawImage(img, -img.width / 2, -img.height / 2);
            
            pageData.editedData = tempCanvas.toDataURL('image/jpeg', 0.92);
            pageData.dataUrl = pageData.editedData;
            
            if (index === state.currentPdfPage) {
                const newImg = await loadImageFromUrl(pageData.editedData);
                state.image = newImg;
                canvas.width = newImg.width;
                canvas.height = newImg.height;
                ctx.drawImage(newImg, 0, 0);
            }
            
            updatePageThumbnails();
            toast(`第 ${index + 1} 頁已旋轉`, 'success');
        }
        
        async function duplicateThumbnailPage(index) {
            const pageData = state.pdfPages[index];
            const newPage = {
                dataUrl: pageData.editedData || pageData.dataUrl,
                editedData: pageData.editedData,
                regions: JSON.parse(JSON.stringify(pageData.regions || []))
            };
            
            state.pdfPages.splice(index + 1, 0, newPage);
            updatePageThumbnails();
            updatePdfNavigation();
            toast(`已複製第 ${index + 1} 頁`, 'success');
        }
        
        async function deleteThumbnailPage(index) {
            if (state.pdfPages.length <= 1) {
                toast('至少需要保留一頁', 'error');
                return;
            }
            
            if (!confirm(`確定要刪除第 ${index + 1} 頁嗎？`)) return;
            
            state.pdfPages.splice(index, 1);
            
            if (state.currentPdfPage >= state.pdfPages.length) {
                state.currentPdfPage = state.pdfPages.length - 1;
            }
            
            await loadPdfPageToCanvas(state.currentPdfPage);
            updatePageThumbnails();
            updatePdfNavigation();
            toast(`已刪除頁面`, 'success');
        }
        
        function reorderPages(fromIndex, toIndex) {
            // 保存當前頁面
            if (state.pdfPages.length > 0) {
                state.pdfPages[state.currentPdfPage].editedData = canvas.toDataURL('image/jpeg', 0.92);
            }
            
            const page = state.pdfPages.splice(fromIndex, 1)[0];
            state.pdfPages.splice(toIndex, 0, page);
            
            // 更新當前頁索引
            if (state.currentPdfPage === fromIndex) {
                state.currentPdfPage = toIndex;
            } else if (fromIndex < state.currentPdfPage && toIndex >= state.currentPdfPage) {
                state.currentPdfPage--;
            } else if (fromIndex > state.currentPdfPage && toIndex <= state.currentPdfPage) {
                state.currentPdfPage++;
            }
            
            updatePageThumbnails();
            updatePdfNavigation();
            toast('頁面順序已更新', 'success');
        }
        
        // ============ 印章功能 ============
        let stampState = {
            text: '已核准',
            color: '#dc2626',
            size: 100,
            rotation: 0,
            opacity: 80,
            shape: 'rect',
            imageData: null
        };
        
        function openStampDialog() {
            if (!state.image) {
                toast('請先載入圖片', 'error');
                return;
            }
            document.getElementById('stamp-dialog').classList.add('show');
            updateStampPreview();
        }
        
        function closeStampDialog() {
            document.getElementById('stamp-dialog').classList.remove('show');
        }
        
        function switchStampTab(tab) {
            document.querySelectorAll('.stamp-tab').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`.stamp-tab[data-tab="${tab}"]`).classList.add('active');
            
            document.getElementById('stamp-preset-tab').style.display = tab === 'preset' ? 'block' : 'none';
            document.getElementById('stamp-custom-tab').style.display = tab === 'custom' ? 'block' : 'none';
            document.getElementById('stamp-upload-tab').style.display = tab === 'upload' ? 'block' : 'none';
            
            stampState.imageData = null;
            updateStampPreview();
        }
        
        function selectStamp(element, text) {
            document.querySelectorAll('.stamp-item').forEach(item => item.classList.remove('selected'));
            element.classList.add('selected');
            stampState.text = text;
            stampState.imageData = null;
            updateStampPreview();
        }
        
        function setStampColor(color) {
            stampState.color = color;
            document.querySelectorAll('.stamp-color-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            updateStampPreview();
        }
        
        function handleStampUpload(file) {
            if (!file || !file.type.startsWith('image/')) {
                toast('請選擇圖片檔案', 'error');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = (e) => {
                stampState.imageData = e.target.result;
                updateStampPreview();
                toast('印章圖片已載入', 'success');
            };
            reader.readAsDataURL(file);
        }
        
        function updateStampPreview() {
            const preview = document.getElementById('stamp-preview-content');
            const size = parseInt(document.getElementById('stamp-size').value);
            const rotation = parseInt(document.getElementById('stamp-rotation').value);
            const opacity = parseInt(document.getElementById('stamp-opacity').value);
            
            stampState.size = size;
            stampState.rotation = rotation;
            stampState.opacity = opacity;
            
            document.getElementById('stamp-size-value').textContent = size + 'px';
            document.getElementById('stamp-rotation-value').textContent = rotation + '°';
            document.getElementById('stamp-opacity-value').textContent = opacity + '%';
            
            if (stampState.imageData) {
                preview.innerHTML = `<img src="${stampState.imageData}" style="max-width:${size}px;max-height:${size}px;transform:rotate(${rotation}deg);opacity:${opacity/100};">`;
            } else {
                const text = document.getElementById('stamp-custom-text')?.value || stampState.text;
                stampState.text = text;
                const shape = document.getElementById('stamp-custom-shape')?.value || stampState.shape;
                stampState.shape = shape;
                
                let borderRadius = '4px';
                if (shape === 'circle') borderRadius = '50%';
                else if (shape === 'rect-round') borderRadius = '12px';
                else if (shape === 'ellipse') borderRadius = '50%';
                
                const padding = shape === 'circle' || shape === 'ellipse' ? '20px 25px' : '10px 20px';
                
                preview.innerHTML = `
                    <div style="
                        display:inline-block;
                        border:3px solid ${stampState.color};
                        color:${stampState.color};
                        font-size:${Math.max(14, size/5)}px;
                        font-weight:bold;
                        padding:${padding};
                        border-radius:${borderRadius};
                        transform:rotate(${rotation}deg);
                        opacity:${opacity/100};
                        ${shape === 'ellipse' ? 'padding:15px 35px;' : ''}
                    ">${text}</div>
                `;
            }
        }
        
        function applyStamp() {
            if (!state.image) {
                toast('請先載入圖片', 'error');
                return;
            }
            
            saveHistory('添加印章');
            
            const size = stampState.size;
            const rotation = stampState.rotation;
            const opacity = stampState.opacity / 100;
            
            // 建立印章 canvas
            const stampCanvas = document.createElement('canvas');
            stampCanvas.width = size * 2;
            stampCanvas.height = size * 2;
            const stampCtx = stampCanvas.getContext('2d');
            
            // 清除背景（透明）
            stampCtx.clearRect(0, 0, stampCanvas.width, stampCanvas.height);
            
            stampCtx.translate(size, size);
            stampCtx.rotate(rotation * Math.PI / 180);
            
            if (stampState.imageData) {
                const img = new Image();
                img.onload = () => {
                    stampCtx.globalAlpha = opacity;
                    stampCtx.drawImage(img, -size/2, -size/2, size, size);
                    drawStampToMainCanvas(stampCanvas, size, opacity);
                    closeStampDialog();
                };
                img.onerror = () => {
                    toast('印章圖片載入失敗', 'error');
                };
                img.src = stampState.imageData;
            } else {
                // 繪製文字印章
                stampCtx.strokeStyle = stampState.color;
                stampCtx.fillStyle = stampState.color;
                stampCtx.lineWidth = 3;
                
                const text = stampState.text;
                const fontSize = Math.max(16, size / 4);
                stampCtx.font = `bold ${fontSize}px "Noto Sans TC", sans-serif`;
                stampCtx.textAlign = 'center';
                stampCtx.textBaseline = 'middle';
                
                const textWidth = stampCtx.measureText(text).width;
                const padding = 15;
                const boxWidth = textWidth + padding * 2;
                const boxHeight = fontSize + padding * 2;
                
                if (stampState.shape === 'circle') {
                    const radius = Math.max(boxWidth, boxHeight) / 2 + 5;
                    stampCtx.beginPath();
                    stampCtx.arc(0, 0, radius, 0, Math.PI * 2);
                    stampCtx.stroke();
                } else if (stampState.shape === 'ellipse') {
                    stampCtx.beginPath();
                    stampCtx.ellipse(0, 0, boxWidth/2 + 10, boxHeight/2 + 5, 0, 0, Math.PI * 2);
                    stampCtx.stroke();
                } else {
                    const r = stampState.shape === 'rect-round' ? 10 : 3;
                    stampCtx.beginPath();
                    stampCtx.roundRect(-boxWidth/2, -boxHeight/2, boxWidth, boxHeight, r);
                    stampCtx.stroke();
                }
                
                stampCtx.fillText(text, 0, 0);
                drawStampToMainCanvas(stampCanvas, size, opacity);
                closeStampDialog();
            }
        }
        
        function drawStampToMainCanvas(stampCanvas, size, opacity) {
            // 直接繪製到主畫布中央
            const x = Math.round(canvas.width / 2 - size);
            const y = Math.round(canvas.height / 2 - size);
            
            ctx.save();
            ctx.globalAlpha = opacity;
            ctx.drawImage(stampCanvas, x, y);
            ctx.restore();
            
            // 更新 PDF 頁面數據
            if (state.pdfPages.length > 0 && state.currentPdfPage >= 0) {
                state.pdfPages[state.currentPdfPage].editedData = canvas.toDataURL('image/jpeg', 0.92);
            }
            
            toast('印章已套用到畫布中央', 'success');
            updateUndoButton();
        }
        
        // 可編輯模式添加印章
        function applyStampEditable() {
            if (!state.image) {
                toast('請先載入圖片', 'error');
                return;
            }
            
            saveHistory('添加印章');
            
            const size = stampState.size;
            const rotation = stampState.rotation;
            const opacity = stampState.opacity / 100;
            
            // 建立印章 canvas
            const stampCanvas = document.createElement('canvas');
            stampCanvas.width = size * 2;
            stampCanvas.height = size * 2;
            const stampCtx = stampCanvas.getContext('2d');
            
            stampCtx.clearRect(0, 0, stampCanvas.width, stampCanvas.height);
            stampCtx.translate(size, size);
            stampCtx.rotate(rotation * Math.PI / 180);
            
            if (stampState.imageData) {
                const img = new Image();
                img.onload = () => {
                    stampCtx.globalAlpha = opacity;
                    stampCtx.drawImage(img, -size/2, -size/2, size, size);
                    addStampAsEditable(stampCanvas, size);
                    closeStampDialog();
                };
                img.src = stampState.imageData;
            } else {
                stampCtx.strokeStyle = stampState.color;
                stampCtx.fillStyle = stampState.color;
                stampCtx.lineWidth = 3;
                
                const text = stampState.text;
                const fontSize = Math.max(16, size / 4);
                stampCtx.font = `bold ${fontSize}px "Noto Sans TC", sans-serif`;
                stampCtx.textAlign = 'center';
                stampCtx.textBaseline = 'middle';
                
                const textWidth = stampCtx.measureText(text).width;
                const padding = 15;
                const boxWidth = textWidth + padding * 2;
                const boxHeight = fontSize + padding * 2;
                
                if (stampState.shape === 'circle') {
                    const radius = Math.max(boxWidth, boxHeight) / 2 + 5;
                    stampCtx.beginPath();
                    stampCtx.arc(0, 0, radius, 0, Math.PI * 2);
                    stampCtx.stroke();
                } else if (stampState.shape === 'ellipse') {
                    stampCtx.beginPath();
                    stampCtx.ellipse(0, 0, boxWidth/2 + 10, boxHeight/2 + 5, 0, 0, Math.PI * 2);
                    stampCtx.stroke();
                } else {
                    const r = stampState.shape === 'rect-round' ? 10 : 3;
                    stampCtx.beginPath();
                    stampCtx.roundRect(-boxWidth/2, -boxHeight/2, boxWidth, boxHeight, r);
                    stampCtx.stroke();
                }
                
                stampCtx.fillText(text, 0, 0);
                addStampAsEditable(stampCanvas, size);
                closeStampDialog();
            }
        }
        
        function addStampAsEditable(stampCanvas, size) {
            console.log('Adding stamp as editable, size:', size);
            
            const stampRegion = {
                id: Date.now(),
                x: Math.round(canvas.width / 2 - size),
                y: Math.round(canvas.height / 2 - size),
                w: size * 2,
                h: size * 2,
                originalW: size * 2,
                originalH: size * 2,
                scale: 1,
                rotation: 0,
                imageData: stampCanvas.toDataURL('image/png'),
                originalImageData: stampCanvas.toDataURL('image/png'),
                isStamp: true,
                layerIndex: 0, // 強制設為圖層 0
                bgColor: '#ffffff',
                tolerance: 30,
                transparentBg: true
            };
            
            if (!state.imageRegions) {
                state.imageRegions = [];
            }
            state.imageRegions.push(stampRegion);
            state.activeImageRegion = stampRegion;
            
            console.log('imageRegions count:', state.imageRegions.length);
            console.log('Stamp region:', stampRegion);
            
            setMode('select');
            
            // 確保 image-regions-layer 存在並可見
            let layer = document.getElementById('image-regions-layer');
            if (layer) {
                layer.style.display = 'block';
                layer.style.opacity = '1';
            }
            
            renderImageRegions();
            
            // 驗證渲染結果
            setTimeout(() => {
                const layer = document.getElementById('image-regions-layer');
                console.log('Layer element:', layer);
                console.log('Layer children:', layer ? layer.children.length : 'no layer');
            }, 100);
            
            updateImagePanel();
            toast('印章已添加，可拖動調整位置後點擊「📌 固定到圖片」', 'success');
        }
        
        // ============ 頁面管理功能 ============
        let pageManagerSelection = new Set();
        
        function openPageManagerDialog() {
            if (state.pdfPages.length === 0) {
                toast('請先載入 PDF 文件', 'error');
                return;
            }
            
            // 保存當前頁面
            state.pdfPages[state.currentPdfPage].editedData = canvas.toDataURL('image/jpeg', 0.92);
            
            document.getElementById('page-manager-dialog').classList.add('show');
            pageManagerSelection.clear();
            updatePageManagerGrid();
        }
        
        function closePageManagerDialog() {
            document.getElementById('page-manager-dialog').classList.remove('show');
        }
        
        function updatePageManagerGrid() {
            const grid = document.getElementById('page-manager-grid');
            grid.innerHTML = '';
            
            state.pdfPages.forEach((page, index) => {
                const item = document.createElement('div');
                item.className = 'page-manager-item' + (pageManagerSelection.has(index) ? ' selected' : '');
                item.dataset.index = index;
                item.draggable = true;
                
                const img = document.createElement('img');
                img.className = 'page-manager-img';
                img.src = page.editedData || page.dataUrl;
                
                const info = document.createElement('div');
                info.className = 'page-manager-info';
                info.innerHTML = `
                    <span class="page-manager-number">第 ${index + 1} 頁</span>
                    <div class="page-manager-actions">
                        <button class="page-manager-action" onclick="event.stopPropagation();pageManagerRotate(${index})" title="旋轉 90°">↻</button>
                        <button class="page-manager-action" onclick="event.stopPropagation();pageManagerDuplicate(${index})" title="複製">📋</button>
                        <button class="page-manager-action danger" onclick="event.stopPropagation();pageManagerDelete(${index})" title="刪除">🗑️</button>
                    </div>
                `;
                
                item.appendChild(img);
                item.appendChild(info);
                
                item.onclick = (e) => {
                    if (e.shiftKey && pageManagerSelection.size > 0) {
                        const lastSelected = Math.max(...pageManagerSelection);
                        const start = Math.min(lastSelected, index);
                        const end = Math.max(lastSelected, index);
                        for (let i = start; i <= end; i++) {
                            pageManagerSelection.add(i);
                        }
                    } else if (e.ctrlKey || e.metaKey) {
                        if (pageManagerSelection.has(index)) {
                            pageManagerSelection.delete(index);
                        } else {
                            pageManagerSelection.add(index);
                        }
                    } else {
                        pageManagerSelection.clear();
                        pageManagerSelection.add(index);
                    }
                    updatePageManagerGrid();
                };
                
                // 拖拉排序
                item.ondragstart = (e) => {
                    e.dataTransfer.setData('text/plain', index);
                    item.classList.add('dragging');
                };
                
                item.ondragend = () => item.classList.remove('dragging');
                
                item.ondragover = (e) => {
                    e.preventDefault();
                    item.classList.add('drag-over');
                };
                
                item.ondragleave = () => item.classList.remove('drag-over');
                
                item.ondrop = (e) => {
                    e.preventDefault();
                    item.classList.remove('drag-over');
                    const fromIndex = parseInt(e.dataTransfer.getData('text/plain'));
                    if (fromIndex !== index) {
                        const page = state.pdfPages.splice(fromIndex, 1)[0];
                        state.pdfPages.splice(index, 0, page);
                        updatePageManagerGrid();
                    }
                };
                
                grid.appendChild(item);
            });
        }
        
        function pageManagerSelectAll() {
            state.pdfPages.forEach((_, i) => pageManagerSelection.add(i));
            updatePageManagerGrid();
        }
        
        function pageManagerDeselectAll() {
            pageManagerSelection.clear();
            updatePageManagerGrid();
        }
        
        async function pageManagerRotate(index) {
            const pageData = state.pdfPages[index];
            const img = await loadImageFromUrl(pageData.editedData || pageData.dataUrl);
            
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = img.height;
            tempCanvas.height = img.width;
            const tempCtx = tempCanvas.getContext('2d');
            
            tempCtx.translate(tempCanvas.width / 2, tempCanvas.height / 2);
            tempCtx.rotate(90 * Math.PI / 180);
            tempCtx.drawImage(img, -img.width / 2, -img.height / 2);
            
            pageData.editedData = tempCanvas.toDataURL('image/jpeg', 0.92);
            pageData.dataUrl = pageData.editedData;
            
            updatePageManagerGrid();
            toast(`第 ${index + 1} 頁已旋轉`, 'success');
        }
        
        function pageManagerDuplicate(index) {
            const pageData = state.pdfPages[index];
            const newPage = {
                dataUrl: pageData.editedData || pageData.dataUrl,
                editedData: pageData.editedData,
                regions: JSON.parse(JSON.stringify(pageData.regions || []))
            };
            state.pdfPages.splice(index + 1, 0, newPage);
            updatePageManagerGrid();
            toast(`已複製第 ${index + 1} 頁`, 'success');
        }
        
        function pageManagerDelete(index) {
            if (state.pdfPages.length <= 1) {
                toast('至少需要保留一頁', 'error');
                return;
            }
            state.pdfPages.splice(index, 1);
            pageManagerSelection.delete(index);
            updatePageManagerGrid();
            toast('已刪除頁面', 'success');
        }
        
        function pageManagerDeleteSelected() {
            if (pageManagerSelection.size === 0) {
                toast('請先選取頁面', 'error');
                return;
            }
            if (pageManagerSelection.size >= state.pdfPages.length) {
                toast('至少需要保留一頁', 'error');
                return;
            }
            if (!confirm(`確定要刪除選取的 ${pageManagerSelection.size} 頁嗎？`)) return;
            
            const toDelete = Array.from(pageManagerSelection).sort((a, b) => b - a);
            toDelete.forEach(index => state.pdfPages.splice(index, 1));
            pageManagerSelection.clear();
            updatePageManagerGrid();
            toast('已刪除選取的頁面', 'success');
        }
        
        function pageManagerAddBlank() {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width || 595;
            tempCanvas.height = canvas.height || 842;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.fillStyle = '#ffffff';
            tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
            
            state.pdfPages.push({
                dataUrl: tempCanvas.toDataURL('image/jpeg', 0.92),
                editedData: null,
                regions: []
            });
            
            updatePageManagerGrid();
            toast('已添加空白頁', 'success');
        }
        
        function pageManagerImportImage() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.multiple = true;
            input.onchange = async (e) => {
                for (const file of e.target.files) {
                    const reader = new FileReader();
                    reader.onload = (ev) => {
                        state.pdfPages.push({
                            dataUrl: ev.target.result,
                            editedData: null,
                            regions: []
                        });
                        updatePageManagerGrid();
                    };
                    reader.readAsDataURL(file);
                }
                toast(`已匯入 ${e.target.files.length} 張圖片`, 'success');
            };
            input.click();
        }
        
        async function applyPageManagerChanges() {
            if (state.currentPdfPage >= state.pdfPages.length) {
                state.currentPdfPage = state.pdfPages.length - 1;
            }
            
            await loadPdfPageToCanvas(state.currentPdfPage);
            updatePageThumbnails();
            updatePdfNavigation();
            closePageManagerDialog();
            toast('頁面變更已套用', 'success');
        }
        
        // ============ 圖片優化功能 ============
        let optimizeOriginalImageData = null;
        
        function openImageOptimizeDialog() {
            if (!state.image) {
                toast('請先載入圖片', 'error');
                return;
            }
            
            document.getElementById('image-optimize-dialog').classList.add('show');
            
            // 重置設定
            document.getElementById('optimize-denoise').value = 0;
            document.getElementById('optimize-sharpen').value = 0;
            document.getElementById('optimize-contrast').value = 0;
            document.getElementById('optimize-brightness').value = 0;
            
            // 顯示原始圖片
            const originalCanvas = document.getElementById('optimize-preview-original');
            const originalCtx = originalCanvas.getContext('2d');
            const scale = Math.min(300 / canvas.width, 200 / canvas.height, 1);
            originalCanvas.width = canvas.width * scale;
            originalCanvas.height = canvas.height * scale;
            originalCtx.drawImage(canvas, 0, 0, originalCanvas.width, originalCanvas.height);
            
            optimizeOriginalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            
            updateOptimizePreview();
        }
        
        function closeImageOptimizeDialog() {
            document.getElementById('image-optimize-dialog').classList.remove('show');
        }
        
        function applyOptimizePreset(preset) {
            document.querySelectorAll('.optimize-preset-btn').forEach(btn => btn.classList.remove('active'));
            event.target.closest('.optimize-preset-btn').classList.add('active');
            
            switch (preset) {
                case 'auto':
                    document.getElementById('optimize-denoise').value = 20;
                    document.getElementById('optimize-sharpen').value = 25;
                    document.getElementById('optimize-contrast').value = 10;
                    document.getElementById('optimize-brightness').value = 5;
                    break;
                case 'denoise':
                    document.getElementById('optimize-denoise').value = 50;
                    document.getElementById('optimize-sharpen').value = 0;
                    document.getElementById('optimize-contrast').value = 0;
                    document.getElementById('optimize-brightness').value = 0;
                    break;
                case 'sharpen':
                    document.getElementById('optimize-denoise').value = 0;
                    document.getElementById('optimize-sharpen').value = 60;
                    document.getElementById('optimize-contrast').value = 5;
                    document.getElementById('optimize-brightness').value = 0;
                    break;
                case 'contrast':
                    document.getElementById('optimize-denoise').value = 0;
                    document.getElementById('optimize-sharpen').value = 10;
                    document.getElementById('optimize-contrast').value = 30;
                    document.getElementById('optimize-brightness').value = 0;
                    break;
                case 'brighten':
                    document.getElementById('optimize-denoise').value = 0;
                    document.getElementById('optimize-sharpen').value = 0;
                    document.getElementById('optimize-contrast').value = 5;
                    document.getElementById('optimize-brightness').value = 25;
                    break;
                case 'vivid':
                    document.getElementById('optimize-denoise').value = 10;
                    document.getElementById('optimize-sharpen').value = 30;
                    document.getElementById('optimize-contrast').value = 20;
                    document.getElementById('optimize-brightness').value = 10;
                    break;
            }
            
            updateOptimizePreview();
        }
        
        function updateOptimizePreview() {
            const denoise = parseInt(document.getElementById('optimize-denoise').value);
            const sharpen = parseInt(document.getElementById('optimize-sharpen').value);
            const contrast = parseInt(document.getElementById('optimize-contrast').value);
            const brightness = parseInt(document.getElementById('optimize-brightness').value);
            
            document.getElementById('optimize-denoise-value').textContent = denoise;
            document.getElementById('optimize-sharpen-value').textContent = sharpen;
            document.getElementById('optimize-contrast-value').textContent = contrast;
            document.getElementById('optimize-brightness-value').textContent = brightness;
            
            // 創建預覽
            const resultCanvas = document.getElementById('optimize-preview-result');
            const resultCtx = resultCanvas.getContext('2d');
            const scale = Math.min(300 / canvas.width, 200 / canvas.height, 1);
            resultCanvas.width = canvas.width * scale;
            resultCanvas.height = canvas.height * scale;
            
            // 繪製並應用效果
            resultCtx.filter = `
                contrast(${100 + contrast}%)
                brightness(${100 + brightness}%)
                ${sharpen > 0 ? `url(#sharpen)` : ''}
            `;
            resultCtx.drawImage(canvas, 0, 0, resultCanvas.width, resultCanvas.height);
            
            // 應用去噪（簡單模糊）
            if (denoise > 0) {
                resultCtx.filter = `blur(${denoise * 0.02}px)`;
                resultCtx.drawImage(resultCanvas, 0, 0);
                resultCtx.filter = 'none';
            }
        }
        
        function resetOptimizeSettings() {
            document.getElementById('optimize-denoise').value = 0;
            document.getElementById('optimize-sharpen').value = 0;
            document.getElementById('optimize-contrast').value = 0;
            document.getElementById('optimize-brightness').value = 0;
            document.querySelectorAll('.optimize-preset-btn').forEach(btn => btn.classList.remove('active'));
            updateOptimizePreview();
        }
        
        async function applyImageOptimize() {
            const denoise = parseInt(document.getElementById('optimize-denoise').value);
            const sharpen = parseInt(document.getElementById('optimize-sharpen').value);
            const contrast = parseInt(document.getElementById('optimize-contrast').value);
            const brightness = parseInt(document.getElementById('optimize-brightness').value);
            const applyToAll = document.getElementById('optimize-apply-all').checked;
            
            saveHistory('圖片優化');
            
            async function optimizePage(imgData, w, h) {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = w;
                tempCanvas.height = h;
                const tempCtx = tempCanvas.getContext('2d');
                
                const img = await loadImageFromUrl(imgData);
                
                // 應用對比度和亮度
                tempCtx.filter = `contrast(${100 + contrast}%) brightness(${100 + brightness}%)`;
                tempCtx.drawImage(img, 0, 0);
                tempCtx.filter = 'none';
                
                // 應用去噪
                if (denoise > 0) {
                    const blurCanvas = document.createElement('canvas');
                    blurCanvas.width = w;
                    blurCanvas.height = h;
                    const blurCtx = blurCanvas.getContext('2d');
                    blurCtx.filter = `blur(${denoise * 0.03}px)`;
                    blurCtx.drawImage(tempCanvas, 0, 0);
                    
                    // 混合原圖和模糊圖
                    tempCtx.globalAlpha = denoise / 100;
                    tempCtx.drawImage(blurCanvas, 0, 0);
                    tempCtx.globalAlpha = 1;
                }
                
                // 應用銳化
                if (sharpen > 0) {
                    const imageData = tempCtx.getImageData(0, 0, w, h);
                    const data = imageData.data;
                    const factor = sharpen / 100;
                    
                    const original = new Uint8ClampedArray(data);
                    
                    for (let y = 1; y < h - 1; y++) {
                        for (let x = 1; x < w - 1; x++) {
                            const idx = (y * w + x) * 4;
                            for (let c = 0; c < 3; c++) {
                                const center = original[idx + c];
                                const neighbors = (
                                    original[idx - 4 + c] +
                                    original[idx + 4 + c] +
                                    original[idx - w * 4 + c] +
                                    original[idx + w * 4 + c]
                                ) / 4;
                                
                                data[idx + c] = Math.min(255, Math.max(0,
                                    center + (center - neighbors) * factor
                                ));
                            }
                        }
                    }
                    
                    tempCtx.putImageData(imageData, 0, 0);
                }
                
                return tempCanvas.toDataURL('image/jpeg', 0.92);
            }
            
            showLoading('優化圖片中...');
            
            try {
                if (applyToAll && state.pdfPages.length > 1) {
                    for (let i = 0; i < state.pdfPages.length; i++) {
                        setProgress(Math.round((i / state.pdfPages.length) * 100));
                        const page = state.pdfPages[i];
                        const img = await loadImageFromUrl(page.editedData || page.dataUrl);
                        page.editedData = await optimizePage(page.editedData || page.dataUrl, img.width, img.height);
                    }
                    
                    const currentImg = await loadImageFromUrl(state.pdfPages[state.currentPdfPage].editedData);
                    canvas.width = currentImg.width;
                    canvas.height = currentImg.height;
                    ctx.drawImage(currentImg, 0, 0);
                    state.image = currentImg;
                    
                    toast(`已優化 ${state.pdfPages.length} 頁`, 'success');
                } else {
                    const optimized = await optimizePage(canvas.toDataURL(), canvas.width, canvas.height);
                    const newImg = await loadImageFromUrl(optimized);
                    ctx.drawImage(newImg, 0, 0);
                    state.image = newImg;
                    
                    if (state.pdfPages.length > 0) {
                        state.pdfPages[state.currentPdfPage].editedData = optimized;
                    }
                    
                    toast('圖片優化完成', 'success');
                }
                
                hideLoading();
                closeImageOptimizeDialog();
                updateUndoButton();
                
            } catch (e) {
                hideLoading();
                toast('優化失敗: ' + e.message, 'error');
            }
        }
        
        // ============ 頁首頁尾功能 ============
        let hfLastFocusedInput = null;
        
        function openHeaderFooterDialog() {
            if (state.pdfPages.length === 0) {
                toast('請先載入 PDF 文件', 'error');
                return;
            }
            
            document.getElementById('header-footer-dialog').classList.add('show');
            
            // 記錄最後聚焦的輸入框
            document.querySelectorAll('#header-footer-dialog input[type="text"]').forEach(input => {
                input.onfocus = () => { hfLastFocusedInput = input; };
            });
            
            updateHeaderFooterPreview();
        }
        
        function closeHeaderFooterDialog() {
            document.getElementById('header-footer-dialog').classList.remove('show');
        }
        
        function insertHFVariable(variable) {
            if (hfLastFocusedInput) {
                const start = hfLastFocusedInput.selectionStart;
                const end = hfLastFocusedInput.selectionEnd;
                const value = hfLastFocusedInput.value;
                hfLastFocusedInput.value = value.substring(0, start) + variable + value.substring(end);
                hfLastFocusedInput.focus();
                hfLastFocusedInput.setSelectionRange(start + variable.length, start + variable.length);
                updateHeaderFooterPreview();
            }
        }
        
        function updateHeaderFooterPreview() {
            const headerLeft = document.getElementById('hf-header-left').value;
            const headerCenter = document.getElementById('hf-header-center').value;
            const headerRight = document.getElementById('hf-header-right').value;
            const footerLeft = document.getElementById('hf-footer-left').value;
            const footerCenter = document.getElementById('hf-footer-center').value;
            const footerRight = document.getElementById('hf-footer-right').value;
            const fontSize = document.getElementById('hf-font-size').value;
            const fontColor = document.getElementById('hf-font-color').value;
            
            const replaceVars = (text, page = 1, total = 5) => {
                return text
                    .replace(/{page}/g, page)
                    .replace(/{total}/g, total)
                    .replace(/{date}/g, new Date().toLocaleDateString())
                    .replace(/{time}/g, new Date().toLocaleTimeString())
                    .replace(/{filename}/g, 'document.pdf');
            };
            
            const headerHTML = `
                <div style="display:flex;justify-content:space-between;font-size:${fontSize}px;color:${fontColor};">
                    <span>${replaceVars(headerLeft)}</span>
                    <span>${replaceVars(headerCenter)}</span>
                    <span>${replaceVars(headerRight)}</span>
                </div>
            `;
            
            const footerHTML = `
                <div style="display:flex;justify-content:space-between;font-size:${fontSize}px;color:${fontColor};">
                    <span>${replaceVars(footerLeft)}</span>
                    <span>${replaceVars(footerCenter)}</span>
                    <span>${replaceVars(footerRight)}</span>
                </div>
            `;
            
            document.getElementById('hf-preview-header').innerHTML = headerHTML;
            document.getElementById('hf-preview-footer').innerHTML = footerHTML;
        }
        
        async function applyHeaderFooter() {
            const headerLeft = document.getElementById('hf-header-left').value;
            const headerCenter = document.getElementById('hf-header-center').value;
            const headerRight = document.getElementById('hf-header-right').value;
            const footerLeft = document.getElementById('hf-footer-left').value;
            const footerCenter = document.getElementById('hf-footer-center').value;
            const footerRight = document.getElementById('hf-footer-right').value;
            const fontSize = parseInt(document.getElementById('hf-font-size').value);
            const fontColor = document.getElementById('hf-font-color').value;
            
            if (!headerLeft && !headerCenter && !headerRight && !footerLeft && !footerCenter && !footerRight) {
                toast('請輸入頁首或頁尾內容', 'error');
                return;
            }
            
            saveHistory('添加頁首頁尾');
            showLoading('添加頁首頁尾中...');
            
            // 保存當前頁面
            state.pdfPages[state.currentPdfPage].editedData = canvas.toDataURL('image/jpeg', 0.92);
            
            const totalPages = state.pdfPages.length;
            
            const replaceVars = (text, page) => {
                return text
                    .replace(/{page}/g, page)
                    .replace(/{total}/g, totalPages)
                    .replace(/{date}/g, new Date().toLocaleDateString())
                    .replace(/{time}/g, new Date().toLocaleTimeString())
                    .replace(/{filename}/g, 'document.pdf');
            };
            
            try {
                for (let i = 0; i < state.pdfPages.length; i++) {
                    setProgress(Math.round((i / state.pdfPages.length) * 100));
                    
                    const page = state.pdfPages[i];
                    const img = await loadImageFromUrl(page.editedData || page.dataUrl);
                    
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = img.width;
                    tempCanvas.height = img.height;
                    const tempCtx = tempCanvas.getContext('2d');
                    
                    tempCtx.drawImage(img, 0, 0);
                    
                    tempCtx.font = `${fontSize}px "Noto Sans TC", sans-serif`;
                    tempCtx.fillStyle = fontColor;
                    
                    const margin = 30;
                    const pageNum = i + 1;
                    
                    // 繪製頁首
                    if (headerLeft) {
                        tempCtx.textAlign = 'left';
                        tempCtx.fillText(replaceVars(headerLeft, pageNum), margin, margin + fontSize);
                    }
                    if (headerCenter) {
                        tempCtx.textAlign = 'center';
                        tempCtx.fillText(replaceVars(headerCenter, pageNum), img.width / 2, margin + fontSize);
                    }
                    if (headerRight) {
                        tempCtx.textAlign = 'right';
                        tempCtx.fillText(replaceVars(headerRight, pageNum), img.width - margin, margin + fontSize);
                    }
                    
                    // 繪製頁尾
                    if (footerLeft) {
                        tempCtx.textAlign = 'left';
                        tempCtx.fillText(replaceVars(footerLeft, pageNum), margin, img.height - margin);
                    }
                    if (footerCenter) {
                        tempCtx.textAlign = 'center';
                        tempCtx.fillText(replaceVars(footerCenter, pageNum), img.width / 2, img.height - margin);
                    }
                    if (footerRight) {
                        tempCtx.textAlign = 'right';
                        tempCtx.fillText(replaceVars(footerRight, pageNum), img.width - margin, img.height - margin);
                    }
                    
                    page.editedData = tempCanvas.toDataURL('image/jpeg', 0.92);
                }
                
                // 重新載入當前頁面
                const currentImg = await loadImageFromUrl(state.pdfPages[state.currentPdfPage].editedData);
                canvas.width = currentImg.width;
                canvas.height = currentImg.height;
                ctx.drawImage(currentImg, 0, 0);
                state.image = currentImg;
                
                hideLoading();
                closeHeaderFooterDialog();
                updatePageThumbnails();
                toast(`已為 ${totalPages} 頁添加頁首頁尾`, 'success');
                
            } catch (e) {
                hideLoading();
                toast('添加失敗: ' + e.message, 'error');
            }
        }
        
        // ============ PDF 加密功能 ============
        function openPdfEncryptDialog() {
            document.getElementById('pdf-encrypt-dialog').classList.add('show');
        }
        
        function closePdfEncryptDialog() {
            document.getElementById('pdf-encrypt-dialog').classList.remove('show');
        }
        
        function toggleEncryptOptions() {
            const enabled = document.getElementById('encrypt-enable').checked;
            document.getElementById('encrypt-options-panel').style.display = enabled ? 'block' : 'none';
        }
        
        async function downloadEncryptedPdf() {
            if (!state.image) {
                toast('請先載入圖片', 'error');
                return;
            }
            
            const enabled = document.getElementById('encrypt-enable').checked;
            const userPassword = document.getElementById('encrypt-user-password').value;
            const ownerPassword = document.getElementById('encrypt-owner-password').value;
            
            if (enabled && !userPassword) {
                toast('請輸入開啟密碼', 'error');
                return;
            }
            
            showLoading('生成加密 PDF 中...');
            
            const loaded = await loadJsPDF();
            if (!loaded) {
                hideLoading();
                toast('無法載入 PDF 引擎', 'error');
                return;
            }
            
            try {
                const { jsPDF } = window.jspdf;
                
                // 保存當前頁面編輯
                if (state.pdfPages.length > 0) {
                    state.pdfPages[state.currentPdfPage].editedData = canvas.toDataURL('image/jpeg', 0.92);
                }
                
                // 創建 PDF 選項
                const pdfOptions = {
                    orientation: canvas.width > canvas.height ? 'landscape' : 'portrait',
                    unit: 'px',
                    format: [canvas.width, canvas.height],
                    compress: true
                };
                
                // 如果啟用加密，添加加密選項
                if (enabled) {
                    pdfOptions.encryption = {
                        userPassword: userPassword,
                        ownerPassword: ownerPassword || userPassword,
                        userPermissions: []
                    };
                    
                    if (document.getElementById('encrypt-allow-print').checked) {
                        pdfOptions.encryption.userPermissions.push('print');
                    }
                    if (document.getElementById('encrypt-allow-copy').checked) {
                        pdfOptions.encryption.userPermissions.push('copy');
                    }
                    if (document.getElementById('encrypt-allow-modify').checked) {
                        pdfOptions.encryption.userPermissions.push('modify');
                    }
                    if (document.getElementById('encrypt-allow-annotate').checked) {
                        pdfOptions.encryption.userPermissions.push('annot-forms');
                    }
                }
                
                const pdf = new jsPDF(pdfOptions);
                
                if (state.pdfPages.length > 1) {
                    for (let i = 0; i < state.pdfPages.length; i++) {
                        setProgress(Math.round((i / state.pdfPages.length) * 100));
                        
                        const pageData = state.pdfPages[i];
                        let pageDataUrl = pageData.editedData || pageData.dataUrl;
                        
                        if (pageDataUrl.indexOf('image/png') > -1) {
                            const tempImg = await loadImageFromUrl(pageDataUrl);
                            const tempCanvas = document.createElement('canvas');
                            tempCanvas.width = tempImg.width;
                            tempCanvas.height = tempImg.height;
                            const tempCtx = tempCanvas.getContext('2d');
                            tempCtx.fillStyle = '#ffffff';
                            tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                            tempCtx.drawImage(tempImg, 0, 0);
                            pageDataUrl = tempCanvas.toDataURL('image/jpeg', 0.92);
                        }
                        
                        const pageImg = await loadImageFromUrl(pageDataUrl);
                        
                        if (i > 0) {
                            pdf.addPage([pageImg.width, pageImg.height], pageImg.width > pageImg.height ? 'landscape' : 'portrait');
                        }
                        
                        pdf.addImage(pageImg, 'JPEG', 0, 0, pageImg.width, pageImg.height, undefined, 'FAST');
                    }
                } else {
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = canvas.width;
                    tempCanvas.height = canvas.height;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.fillStyle = '#ffffff';
                    tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                    tempCtx.drawImage(canvas, 0, 0);
                    
                    const imgData = tempCanvas.toDataURL('image/jpeg', 0.92);
                    const img = await loadImageFromUrl(imgData);
                    
                    pdf.addImage(img, 'JPEG', 0, 0, canvas.width, canvas.height, undefined, 'FAST');
                }
                
                const filename = enabled ? `encrypted_document_${Date.now()}.pdf` : `document_${Date.now()}.pdf`;
                pdf.save(filename);
                
                hideLoading();
                closePdfEncryptDialog();
                toast(enabled ? 'PDF 已加密並下載' : 'PDF 已下載', 'success');
                
            } catch (e) {
                console.error('PDF export error:', e);
                hideLoading();
                toast('PDF 生成失敗: ' + e.message, 'error');
            }
        }
        
        // ============ 語音泡泡功能 ============
        let bubbleState = { type: 'speech', tailDirection: 'bottom-left', vertical: false };
        let speechBubbleObjects = []; // 儲存所有語音泡泡物件
        let activeBubble = null; // 當前選中的泡泡
        let bubbleDragging = false;
        let bubbleResizing = false;
        let bubbleDragOffset = { x: 0, y: 0 };
        let bubbleResizeStart = null;
        let editingBubbleId = null; // 正在編輯的泡泡 ID
        
        function openSpeechBubbleDialog(editBubble = null) {
            if (!state.image && !editBubble) { toast('請先載入圖片', 'error'); return; }
            
            // 如果是編輯模式
            if (editBubble) {
                editingBubbleId = editBubble.id;
                document.getElementById('bubble-text').value = editBubble.text;
                document.getElementById('bubble-bg-color').value = editBubble.bgColor;
                document.getElementById('bubble-border-color').value = editBubble.borderColor;
                document.getElementById('bubble-text-color').value = editBubble.textColor;
                document.getElementById('bubble-font-size').value = Math.round(editBubble.fontSize / 5);
                document.getElementById('bubble-font-family').value = editBubble.fontFamily || 'Noto Sans TC';
                document.getElementById('bubble-font-bold').checked = editBubble.fontBold || false;
                bubbleState.type = editBubble.type;
                bubbleState.tailDirection = editBubble.tailDirection;
                bubbleState.vertical = editBubble.vertical || false;
                
                // 更新按鈕狀態
                document.querySelectorAll('.bubble-type-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.type === editBubble.type);
                });
                setBubbleTail(editBubble.tailDirection);
                document.getElementById('bubble-vertical').checked = editBubble.vertical || false;
                
                document.getElementById('bubble-dialog-title').textContent = '✏️ 編輯語音泡泡';
                document.getElementById('bubble-add-btn').textContent = '更新泡泡';
            } else {
                editingBubbleId = null;
                document.getElementById('bubble-text').value = '你好！';
                document.getElementById('bubble-font-size').value = 18;
                document.getElementById('bubble-font-family').value = 'Noto Sans TC';
                document.getElementById('bubble-font-bold').checked = false;
                bubbleState.type = 'speech';
                bubbleState.tailDirection = 'bottom-left';
                bubbleState.vertical = false;
                document.getElementById('bubble-vertical').checked = false;
                
                document.querySelectorAll('.bubble-type-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.type === 'speech');
                });
                setBubbleTail('bottom-left');
                
                document.getElementById('bubble-dialog-title').textContent = '💬 語音泡泡';
                document.getElementById('bubble-add-btn').textContent = '添加到畫布';
            }
            
            document.getElementById('speech-bubble-dialog').classList.add('show');
            document.getElementById('bubble-text').oninput = updateBubblePreview;
            updateBubblePreview();
        }
        
        function closeSpeechBubbleDialog() {
            document.getElementById('speech-bubble-dialog').classList.remove('show');
            editingBubbleId = null;
        }
        
        function selectBubbleType(type) {
            bubbleState.type = type;
            document.querySelectorAll('.bubble-type-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.type === type);
            });
            updateBubblePreview();
        }
        
        function setBubbleTail(dir) {
            bubbleState.tailDirection = dir;
            ['tail-bl','tail-br','tail-tl','tail-tr','tail-none'].forEach(id => {
                document.getElementById(id)?.classList.remove('active');
            });
            const map = {'bottom-left':'tail-bl','bottom-right':'tail-br','top-left':'tail-tl','top-right':'tail-tr','none':'tail-none'};
            document.getElementById(map[dir])?.classList.add('active');
            updateBubblePreview();
        }
        
        function toggleVerticalText() {
            bubbleState.vertical = document.getElementById('bubble-vertical').checked;
            updateBubblePreview();
        }
        
        function updateBubblePreview() {
            const preview = document.getElementById('bubble-preview');
            const text = document.getElementById('bubble-text').value || '你好！';
            const bgColor = document.getElementById('bubble-bg-color').value;
            const borderColor = document.getElementById('bubble-border-color').value;
            const textColor = document.getElementById('bubble-text-color').value;
            const fontSize = document.getElementById('bubble-font-size').value;
            const fontFamily = document.getElementById('bubble-font-family')?.value || 'Noto Sans TC';
            const fontBold = document.getElementById('bubble-font-bold')?.checked || false;
            const isVertical = document.getElementById('bubble-vertical').checked;
            const fontWeight = fontBold ? 'bold' : 'normal';
            
            let bubbleHtml = '';
            
            if (bubbleState.type === 'thought') {
                // 思考泡泡 - 三個圓圈
                bubbleHtml = `
                    <div style="position:relative;display:flex;flex-direction:column;align-items:flex-start;">
                        <div style="background:${bgColor};border:2px solid ${borderColor};border-radius:50%;width:80px;height:60px;display:flex;align-items:center;justify-content:center;color:${textColor};font-size:${fontSize}px;font-family:'${fontFamily}',sans-serif;font-weight:${fontWeight};${isVertical ? 'writing-mode:vertical-rl;' : ''}padding:8px;text-align:center;word-wrap:break-word;">
                            ${isVertical ? text.split('').join('<br>') : text.replace(/\n/g,'<br>')}
                        </div>
                        <div style="background:${bgColor};border:2px solid ${borderColor};border-radius:50%;width:20px;height:20px;margin-left:10px;margin-top:-5px;"></div>
                        <div style="background:${bgColor};border:2px solid ${borderColor};border-radius:50%;width:12px;height:12px;margin-left:5px;margin-top:-3px;"></div>
                    </div>
                `;
            } else if (bubbleState.type === 'shout') {
                // 驚嘆框 - 爆炸形狀（雙層：紅色外框+白色內部）
                const textStyle = isVertical ? 'writing-mode:vertical-rl;text-orientation:upright;letter-spacing:2px;' : '';
                const displayText = isVertical ? text.split('\n').map(line => `<span style="display:block;">${line}</span>`).join('') : text.replace(/\n/g,'<br>');
                bubbleHtml = `
                    <div style="position:relative;width:120px;height:100px;display:flex;align-items:center;justify-content:center;">
                        <svg viewBox="0 0 100 100" style="position:absolute;top:0;left:0;width:100%;height:100%;">
                            <!-- 外層紅色爆炸 -->
                            <polygon points="50,0 60,28 92,8 72,35 100,50 72,65 92,92 60,72 50,100 40,72 8,92 28,65 0,50 28,35 8,8 40,28" 
                                fill="${borderColor}" stroke="${borderColor}" stroke-width="1"/>
                            <!-- 內層白色/背景色 -->
                            <polygon points="50,15 57,33 80,20 68,40 92,50 68,60 80,80 57,67 50,85 43,67 20,80 32,60 8,50 32,40 20,20 43,33" 
                                fill="${bgColor}" stroke="none"/>
                        </svg>
                        <div style="position:relative;z-index:1;color:${textColor};font-size:${fontSize}px;font-family:'${fontFamily}',sans-serif;font-weight:${fontWeight};text-align:center;max-width:50px;line-height:1.1;${textStyle}">
                            ${displayText}
                        </div>
                    </div>
                `;
            } else {
                let borderRadius = '15px';
                let borderStyle = `3px solid ${borderColor}`;
                if (bubbleState.type === 'cloud') borderRadius = '25px';
                
                let tailHtml = '';
                if (bubbleState.tailDirection !== 'none') {
                    const isBottom = bubbleState.tailDirection.includes('bottom');
                    const isLeft = bubbleState.tailDirection.includes('left');
                    tailHtml = `<div style="position:absolute;${isBottom?'bottom:-12px;':'top:-12px;'}${isLeft?'left:15px;':'right:15px;'}width:0;height:0;border:6px solid transparent;${isBottom?'border-top-color:'+borderColor:'border-bottom-color:'+borderColor};"></div>`;
                }
                
                const textStyle = isVertical ? 'writing-mode:vertical-rl;text-orientation:upright;letter-spacing:2px;' : '';
                const displayText = isVertical ? text.split('\n').map(line => `<span style="display:block;">${line}</span>`).join('') : text.replace(/\n/g,'<br>');
                
                bubbleHtml = `
                    <div style="position:relative;background:${bgColor};color:${textColor};padding:10px 15px;font-size:${fontSize}px;font-family:'${fontFamily}',sans-serif;font-weight:${fontWeight};border-radius:${borderRadius};border:${borderStyle};max-width:120px;text-align:center;word-wrap:break-word;${textStyle}">
                        ${displayText}${tailHtml}
                    </div>
                `;
            }
            
            preview.innerHTML = bubbleHtml;
        }
        
        function addSpeechBubble() {
            if (!state.image && !editingBubbleId) { toast('請先載入圖片', 'error'); return; }
            
            const text = document.getElementById('bubble-text').value || '你好！';
            const bgColor = document.getElementById('bubble-bg-color').value;
            const borderColor = document.getElementById('bubble-border-color').value;
            const textColor = document.getElementById('bubble-text-color').value;
            const fontSize = parseInt(document.getElementById('bubble-font-size').value) * 5;
            const fontFamily = document.getElementById('bubble-font-family')?.value || 'Noto Sans TC';
            const fontBold = document.getElementById('bubble-font-bold')?.checked || false;
            const isVertical = document.getElementById('bubble-vertical').checked;
            
            if (editingBubbleId) {
                // 更新現有泡泡
                const bubble = speechBubbleObjects.find(b => b.id === editingBubbleId);
                if (bubble) {
                    bubble.text = text;
                    bubble.type = bubbleState.type;
                    bubble.tailDirection = bubbleState.tailDirection;
                    bubble.bgColor = bgColor;
                    bubble.borderColor = borderColor;
                    bubble.textColor = textColor;
                    bubble.fontSize = fontSize;
                    bubble.fontFamily = fontFamily;
                    bubble.fontBold = fontBold;
                    bubble.vertical = isVertical;
                    renderSpeechBubbles();
                    toast('泡泡已更新', 'success');
                }
            } else {
                // 創建新泡泡
                const bubble = {
                    id: Date.now(),
                    text: text,
                    type: bubbleState.type,
                    tailDirection: bubbleState.tailDirection,
                    bgColor: bgColor,
                    borderColor: borderColor,
                    textColor: textColor,
                    fontSize: fontSize,
                    fontFamily: fontFamily,
                    fontBold: fontBold,
                    vertical: isVertical,
                    x: canvas.width / 2 - 150,
                    y: canvas.height / 2 - 100,
                    scale: 1
                };
                
                speechBubbleObjects.push(bubble);
                renderSpeechBubbles();
                toast('語音泡泡已添加', 'success');
            }
            
            closeSpeechBubbleDialog();
        }
        
        function renderSpeechBubbles() {
            document.querySelectorAll('.speech-bubble-obj').forEach(el => el.remove());
            
            const container = document.getElementById('canvas-container');
            
            speechBubbleObjects.forEach(bubble => {
                const wrapper = document.createElement('div');
                wrapper.className = 'speech-bubble-obj';
                wrapper.dataset.id = bubble.id;
                
                const scale = bubble.scale || 1;
                const fontSize = bubble.fontSize * scale;
                const padding = 30 * scale;
                const fontFamily = bubble.fontFamily || 'Noto Sans TC';
                const fontWeight = bubble.fontBold ? 'bold' : 'normal';
                
                // 計算泡泡尺寸
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.font = `${fontWeight} ${fontSize}px "${fontFamily}", sans-serif`;
                
                const lines = bubble.text.split('\n');
                let bubbleW, bubbleH;
                
                if (bubble.vertical) {
                    // 直式文字
                    const maxChars = Math.max(...lines.map(l => l.length));
                    bubbleW = lines.length * fontSize * 1.5 + padding * 2;
                    bubbleH = maxChars * fontSize * 1.3 + padding * 2;
                } else {
                    let maxWidth = 0;
                    lines.forEach(line => { maxWidth = Math.max(maxWidth, tempCtx.measureText(line).width); });
                    bubbleW = Math.max(maxWidth + padding * 2, 150 * scale);
                    bubbleH = lines.length * fontSize * 1.3 + padding * 2;
                }
                
                if (bubble.type === 'thought') {
                    // 思考泡泡 - 三個圓圈
                    wrapper.style.cssText = `
                        position: absolute;
                        left: ${bubble.x}px;
                        top: ${bubble.y}px;
                        cursor: move;
                        user-select: none;
                        z-index: 100;
                    `;
                    
                    // 主圓（最大，文字區域）
                    const mainCircle = document.createElement('div');
                    mainCircle.className = 'bubble-main-content';
                    mainCircle.style.cssText = `
                        background: ${bubble.bgColor};
                        border: ${4 * scale}px solid ${bubble.borderColor};
                        border-radius: 50%;
                        width: ${bubbleW}px;
                        height: ${bubbleH}px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        color: ${bubble.textColor};
                        font-size: ${fontSize}px;
                        font-family: "${fontFamily}", sans-serif;
                        font-weight: ${fontWeight};
                        padding: ${padding}px;
                        text-align: center;
                        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                        pointer-events: none;
                        ${bubble.vertical ? 'writing-mode: vertical-rl; text-orientation: upright; letter-spacing: 3px;' : ''}
                    `;
                    mainCircle.innerHTML = bubble.vertical 
                        ? lines.map(l => `<span style="display:block;">${l}</span>`).join('')
                        : bubble.text.replace(/\n/g, '<br>');
                    wrapper.appendChild(mainCircle);
                    
                    // 中圓
                    const midCircle = document.createElement('div');
                    const midSize = 25 * scale;
                    midCircle.style.cssText = `
                        position: absolute;
                        bottom: ${-midSize * 0.8}px;
                        left: ${20 * scale}px;
                        background: ${bubble.bgColor};
                        border: ${3 * scale}px solid ${bubble.borderColor};
                        border-radius: 50%;
                        width: ${midSize}px;
                        height: ${midSize}px;
                        box-shadow: 0 2px 10px rgba(0,0,0,0.2);
                        pointer-events: none;
                    `;
                    wrapper.appendChild(midCircle);
                    
                    // 小圓
                    const smallCircle = document.createElement('div');
                    const smallSize = 12 * scale;
                    smallCircle.style.cssText = `
                        position: absolute;
                        bottom: ${-midSize * 1.5}px;
                        left: ${10 * scale}px;
                        background: ${bubble.bgColor};
                        border: ${2 * scale}px solid ${bubble.borderColor};
                        border-radius: 50%;
                        width: ${smallSize}px;
                        height: ${smallSize}px;
                        box-shadow: 0 2px 8px rgba(0,0,0,0.2);
                        pointer-events: none;
                    `;
                    wrapper.appendChild(smallCircle);
                    
                } else if (bubble.type === 'shout') {
                    // 驚嘆框 - 爆炸形狀（雙層：外框色外層+背景色內層）
                    const shoutW = Math.max(bubbleW * 2.5, 220 * scale);
                    const shoutH = Math.max(bubbleH * 2.5, 200 * scale);
                    
                    wrapper.style.cssText = `
                        position: absolute;
                        left: ${bubble.x}px;
                        top: ${bubble.y}px;
                        width: ${shoutW}px;
                        height: ${shoutH}px;
                        cursor: move;
                        user-select: none;
                        z-index: 100;
                    `;
                    
                    // SVG 雙層爆炸形狀
                    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    svg.setAttribute('viewBox', '0 0 100 100');
                    svg.style.cssText = `position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;`;
                    
                    // 外層爆炸（邊框色）
                    const outerPolygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    outerPolygon.setAttribute('points', '50,0 60,28 92,8 72,35 100,50 72,65 92,92 60,72 50,100 40,72 8,92 28,65 0,50 28,35 8,8 40,28');
                    outerPolygon.setAttribute('fill', bubble.borderColor);
                    svg.appendChild(outerPolygon);
                    
                    // 內層爆炸（背景色）
                    const innerPolygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    innerPolygon.setAttribute('points', '50,12 58,32 82,18 70,38 93,50 70,62 82,82 58,68 50,88 42,68 18,82 30,62 7,50 30,38 18,18 42,32');
                    innerPolygon.setAttribute('fill', bubble.bgColor);
                    svg.appendChild(innerPolygon);
                    
                    wrapper.appendChild(svg);
                    
                    // 文字容器
                    const textDiv = document.createElement('div');
                    textDiv.className = 'bubble-main-content';
                    textDiv.style.cssText = `
                        position: absolute;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        width: ${shoutW * 0.35}px;
                        max-height: ${shoutH * 0.35}px;
                        color: ${bubble.textColor};
                        font-size: ${fontSize * 0.85}px;
                        font-family: "${fontFamily}", sans-serif;
                        font-weight: ${fontWeight};
                        text-align: center;
                        pointer-events: none;
                        line-height: 1.1;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        overflow: hidden;
                        ${bubble.vertical ? 'writing-mode: vertical-rl; text-orientation: upright; letter-spacing: 2px;' : ''}
                    `;
                    textDiv.innerHTML = bubble.vertical 
                        ? lines.map(l => `<span style="display:block;">${l}</span>`).join('')
                        : bubble.text.replace(/\n/g, '<br>');
                    wrapper.appendChild(textDiv);
                    
                } else {
                    // 一般泡泡（對話框、雲朵框）
                    let borderRadius = 30 * scale + 'px';
                    if (bubble.type === 'cloud') borderRadius = 40 * scale + 'px';
                    
                    wrapper.style.cssText = `
                        position: absolute;
                        left: ${bubble.x}px;
                        top: ${bubble.y}px;
                        width: ${bubbleW}px;
                        min-height: ${bubbleH}px;
                        background: ${bubble.bgColor};
                        border: ${4 * scale}px solid ${bubble.borderColor};
                        border-radius: ${borderRadius};
                        color: ${bubble.textColor};
                        font-size: ${fontSize}px;
                        font-family: "${fontFamily}", sans-serif;
                        font-weight: ${fontWeight};
                        padding: ${padding}px;
                        cursor: move;
                        user-select: none;
                        z-index: 100;
                        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                        text-align: center;
                        line-height: 1.3;
                        word-wrap: break-word;
                        ${bubble.vertical ? 'writing-mode: vertical-rl; text-orientation: upright; letter-spacing: 3px;' : ''}
                    `;
                    
                    // 文字內容容器
                    const textContent = document.createElement('div');
                    textContent.className = 'bubble-main-content';
                    textContent.style.cssText = 'pointer-events: none;';
                    textContent.innerHTML = bubble.vertical 
                        ? lines.map(l => `<span style="display:block;">${l}</span>`).join('')
                        : bubble.text.replace(/\n/g, '<br>');
                    wrapper.appendChild(textContent);
                    
                    // 尾巴
                    if (bubble.tailDirection !== 'none') {
                        const tail = document.createElement('div');
                        const isBottom = bubble.tailDirection.includes('bottom');
                        const isLeft = bubble.tailDirection.includes('left');
                        const tailSize = 15 * scale;
                        tail.style.cssText = `
                            position: absolute;
                            ${isBottom ? 'bottom: ' + (-tailSize * 2) + 'px;' : 'top: ' + (-tailSize * 2) + 'px;'}
                            ${isLeft ? 'left: ' + (40 * scale) + 'px;' : 'right: ' + (40 * scale) + 'px;'}
                            width: 0;
                            height: 0;
                            border: ${tailSize}px solid transparent;
                            ${isBottom ? 'border-top-color: ' + bubble.borderColor + ';' : 'border-bottom-color: ' + bubble.borderColor + ';'}
                            pointer-events: none;
                        `;
                        wrapper.appendChild(tail);
                    }
                }
                
                // 選中狀態
                if (activeBubble && activeBubble.id === bubble.id) {
                    wrapper.style.outline = '3px dashed #6366f1';
                    wrapper.style.outlineOffset = '5px';
                }
                
                // 縮放手柄
                const resizeHandle = document.createElement('div');
                resizeHandle.className = 'bubble-resize-handle';
                resizeHandle.style.cssText = `
                    position: absolute;
                    bottom: -8px;
                    right: -8px;
                    width: 16px;
                    height: 16px;
                    background: #6366f1;
                    border: 2px solid #fff;
                    border-radius: 50%;
                    cursor: se-resize;
                    z-index: 102;
                `;
                wrapper.appendChild(resizeHandle);
                
                // 刪除按鈕
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'bubble-delete-btn';
                deleteBtn.innerHTML = '✕';
                deleteBtn.style.cssText = `
                    position: absolute;
                    top: -12px;
                    right: -12px;
                    width: 28px;
                    height: 28px;
                    background: #ef4444;
                    border: none;
                    border-radius: 50%;
                    color: white;
                    font-size: 14px;
                    cursor: pointer;
                    display: none;
                    z-index: 102;
                `;
                wrapper.appendChild(deleteBtn);
                
                // 編輯按鈕
                const editBtn = document.createElement('button');
                editBtn.className = 'bubble-edit-btn';
                editBtn.innerHTML = '✏️';
                editBtn.style.cssText = `
                    position: absolute;
                    top: -12px;
                    left: -12px;
                    width: 28px;
                    height: 28px;
                    background: #22c55e;
                    border: none;
                    border-radius: 50%;
                    font-size: 14px;
                    cursor: pointer;
                    display: none;
                    z-index: 102;
                `;
                wrapper.appendChild(editBtn);
                
                // 顯示/隱藏按鈕
                wrapper.onmouseenter = () => { 
                    deleteBtn.style.display = 'block'; 
                    editBtn.style.display = 'block';
                };
                wrapper.onmouseleave = () => { 
                    if (!bubbleDragging && !bubbleResizing) {
                        deleteBtn.style.display = 'none';
                        editBtn.style.display = 'none';
                    }
                };
                
                // 刪除按鈕點擊
                deleteBtn.onclick = (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    deleteSpeechBubble(bubble.id);
                };
                
                // 編輯按鈕點擊
                editBtn.onclick = (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    openSpeechBubbleDialog(bubble);
                };
                
                // 縮放手柄事件
                resizeHandle.onmousedown = (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    bubbleResizing = true;
                    activeBubble = bubble;
                    bubbleResizeStart = {
                        x: e.clientX,
                        y: e.clientY,
                        scale: bubble.scale || 1
                    };
                };
                
                // 記錄點擊時間用於判斷雙擊
                let lastClickTime = 0;
                
                // 拖曳和雙擊
                wrapper.onmousedown = (e) => {
                    if (e.target.classList.contains('bubble-resize-handle') || 
                        e.target.classList.contains('bubble-delete-btn') ||
                        e.target.classList.contains('bubble-edit-btn')) return;
                    
                    const now = Date.now();
                    if (now - lastClickTime < 350) {
                        // 雙擊 - 開啟編輯對話框
                        e.preventDefault();
                        e.stopPropagation();
                        openSpeechBubbleDialog(bubble);
                        lastClickTime = 0;
                        return;
                    }
                    lastClickTime = now;
                    
                    e.preventDefault();
                    activeBubble = bubble;
                    bubbleDragging = true;
                    const rect = wrapper.getBoundingClientRect();
                    bubbleDragOffset = {
                        x: e.clientX - rect.left,
                        y: e.clientY - rect.top
                    };
                };
                
                container.appendChild(wrapper);
            });
        }
        
        // 全局滑鼠事件
        document.addEventListener('mousemove', (e) => {
            if (bubbleResizing && activeBubble && bubbleResizeStart) {
                const dx = e.clientX - bubbleResizeStart.x;
                const dy = e.clientY - bubbleResizeStart.y;
                const delta = (dx + dy) / 200;
                activeBubble.scale = Math.max(0.3, Math.min(3, bubbleResizeStart.scale + delta));
                renderSpeechBubbles();
                return;
            }
            
            if (!bubbleDragging || !activeBubble) return;
            
            const container = document.getElementById('canvas-container');
            const rect = container.getBoundingClientRect();
            
            activeBubble.x = (e.clientX - rect.left - bubbleDragOffset.x) / state.displayScale;
            activeBubble.y = (e.clientY - rect.top - bubbleDragOffset.y) / state.displayScale;
            
            renderSpeechBubbles();
        });
        
        document.addEventListener('mouseup', () => {
            bubbleDragging = false;
            bubbleResizing = false;
            bubbleResizeStart = null;
        });
        
        function deleteSpeechBubble(id) {
            speechBubbleObjects = speechBubbleObjects.filter(b => b.id !== id);
            if (activeBubble && activeBubble.id === id) activeBubble = null;
            renderSpeechBubbles();
            toast('泡泡已刪除', 'info');
        }
        
        // 將泡泡合併到畫布
        function flattenSpeechBubbles() {
            if (speechBubbleObjects.length === 0) {
                toast('沒有泡泡需要合併', 'info');
                return;
            }
            
            saveHistory('合併語音泡泡');
            
            speechBubbleObjects.forEach(bubble => {
                const scale = bubble.scale || 1;
                const fontSize = bubble.fontSize * scale;
                const padding = 30 * scale;
                const fontFamily = bubble.fontFamily || 'Noto Sans TC';
                const fontWeight = bubble.fontBold ? 'bold' : 'normal';
                
                ctx.font = `${fontWeight} ${fontSize}px "${fontFamily}", sans-serif`;
                const lines = bubble.text.split('\n');
                
                let bubbleW, bubbleH;
                if (bubble.vertical) {
                    const maxChars = Math.max(...lines.map(l => l.length));
                    bubbleW = lines.length * fontSize * 1.5 + padding * 2;
                    bubbleH = maxChars * fontSize * 1.3 + padding * 2;
                } else {
                    let maxWidth = 0;
                    lines.forEach(line => { maxWidth = Math.max(maxWidth, ctx.measureText(line).width); });
                    bubbleW = Math.max(maxWidth + padding * 2, 150 * scale);
                    bubbleH = lines.length * fontSize * 1.3 + padding * 2;
                }
                
                const x = bubble.x;
                const y = bubble.y;
                
                ctx.save();
                ctx.fillStyle = bubble.bgColor;
                ctx.strokeStyle = bubble.borderColor;
                ctx.lineWidth = 4 * scale;
                
                if (bubble.type === 'thought') {
                    // 思考泡泡三圓
                    // 主圓
                    ctx.beginPath();
                    ctx.ellipse(x + bubbleW/2, y + bubbleH/2, bubbleW/2, bubbleH/2, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    
                    // 中圓
                    const midSize = 25 * scale;
                    ctx.beginPath();
                    ctx.arc(x + 20 * scale + midSize/2, y + bubbleH + midSize * 0.3, midSize/2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    
                    // 小圓
                    const smallSize = 12 * scale;
                    ctx.beginPath();
                    ctx.arc(x + 10 * scale + smallSize/2, y + bubbleH + midSize * 1.2, smallSize/2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    
                } else if (bubble.type === 'shout') {
                    // 驚嘆框 - 爆炸形狀（雙層：外框色外層+背景色內層）
                    const shoutW = Math.max(bubbleW * 2.5, 220 * scale);
                    const shoutH = Math.max(bubbleH * 2.5, 200 * scale);
                    const cx = x + shoutW / 2;
                    const cy = y + shoutH / 2;
                    
                    // 繪製外層爆炸（邊框色）
                    const outerR = Math.min(shoutW, shoutH) / 2;
                    const outerInnerR = outerR * 0.55;
                    const spikes = 8;
                    
                    ctx.fillStyle = bubble.borderColor;
                    ctx.beginPath();
                    for (let i = 0; i < spikes * 2; i++) {
                        const r = i % 2 === 0 ? outerR : outerInnerR;
                        const angle = (i * Math.PI / spikes) - Math.PI / 2;
                        const px = cx + r * Math.cos(angle);
                        const py = cy + r * Math.sin(angle);
                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    ctx.fill();
                    
                    // 繪製內層爆炸（背景色）
                    const innerOuterR = outerR * 0.85;
                    const innerInnerR = innerOuterR * 0.55;
                    
                    ctx.fillStyle = bubble.bgColor;
                    ctx.beginPath();
                    for (let i = 0; i < spikes * 2; i++) {
                        const r = i % 2 === 0 ? innerOuterR : innerInnerR;
                        const angle = (i * Math.PI / spikes) - Math.PI / 2;
                        const px = cx + r * Math.cos(angle);
                        const py = cy + r * Math.sin(angle);
                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    ctx.fill();
                    
                    // 繪製驚嘆框文字（在中心，縮小 85%）
                    const shoutFontSize = fontSize * 0.85;
                    ctx.fillStyle = bubble.textColor;
                    ctx.font = `${fontWeight} ${shoutFontSize}px "${fontFamily}", sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    if (bubble.vertical) {
                        const charHeight = shoutFontSize * 1.1;
                        const colWidth = shoutFontSize * 1.4;
                        const totalWidth = lines.length * colWidth;
                        const startX = cx + totalWidth / 2 - colWidth / 2;
                        
                        lines.forEach((line, colIdx) => {
                            const chars = line.split('');
                            const totalH = chars.length * charHeight;
                            const startY = cy - totalH / 2 + charHeight / 2;
                            chars.forEach((char, charIdx) => {
                                ctx.fillText(char, startX - colIdx * colWidth, startY + charIdx * charHeight);
                            });
                        });
                    } else {
                        const lineHeight = shoutFontSize * 1.1;
                        const totalH = lines.length * lineHeight;
                        const startY = cy - totalH / 2 + lineHeight / 2;
                        lines.forEach((line, i) => {
                            ctx.fillText(line, cx, startY + i * lineHeight);
                        });
                    }
                    
                    ctx.restore();
                    return; // 驚嘆框已處理完畢，跳過後面的通用文字繪製
                    
                } else {
                    // 一般泡泡（對話框、雲朵框）
                    const radius = 30 * scale;
                    ctx.beginPath();
                    ctx.roundRect(x, y, bubbleW, bubbleH, radius);
                    ctx.fill();
                    ctx.stroke();
                    
                    // 尾巴
                    if (bubble.tailDirection !== 'none') {
                        const tailSize = 30 * scale;
                        ctx.beginPath();
                        if (bubble.tailDirection === 'bottom-left') {
                            ctx.moveTo(x + 40 * scale, y + bubbleH);
                            ctx.lineTo(x + 70 * scale, y + bubbleH);
                            ctx.lineTo(x + 40 * scale, y + bubbleH + tailSize);
                        } else if (bubble.tailDirection === 'bottom-right') {
                            ctx.moveTo(x + bubbleW - 70 * scale, y + bubbleH);
                            ctx.lineTo(x + bubbleW - 40 * scale, y + bubbleH);
                            ctx.lineTo(x + bubbleW - 40 * scale, y + bubbleH + tailSize);
                        } else if (bubble.tailDirection === 'top-left') {
                            ctx.moveTo(x + 40 * scale, y);
                            ctx.lineTo(x + 70 * scale, y);
                            ctx.lineTo(x + 40 * scale, y - tailSize);
                        } else {
                            ctx.moveTo(x + bubbleW - 70 * scale, y);
                            ctx.lineTo(x + bubbleW - 40 * scale, y);
                            ctx.lineTo(x + bubbleW - 40 * scale, y - tailSize);
                        }
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                    }
                }
                
                // 繪製文字
                ctx.fillStyle = bubble.textColor;
                ctx.font = `${fontWeight} ${fontSize}px "${fontFamily}", sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                if (bubble.vertical) {
                    // 直式文字
                    const charHeight = fontSize * 1.2;
                    const colWidth = fontSize * 1.5;
                    const startX = x + bubbleW - padding - colWidth / 2;
                    
                    lines.forEach((line, colIdx) => {
                        const chars = line.split('');
                        const startY = y + padding + charHeight / 2;
                        chars.forEach((char, charIdx) => {
                            ctx.fillText(char, startX - colIdx * colWidth, startY + charIdx * charHeight);
                        });
                    });
                } else {
                    // 橫式文字
                    const lineHeight = fontSize * 1.3;
                    lines.forEach((line, i) => {
                        ctx.fillText(line, x + bubbleW/2, y + padding + lineHeight/2 + i * lineHeight);
                    });
                }
                
                ctx.restore();
            });
            
            speechBubbleObjects = [];
            activeBubble = null;
            renderSpeechBubbles();
            
            const newImg = new Image();
            newImg.src = canvas.toDataURL();
            state.image = newImg;
            
            toast('語音泡泡已合併到圖片', 'success');
        }
        
        // ============ 編號標籤功能 ============
        let numberLabelObjects = [];
        let activeNumberLabel = null;
        let numberLabelDragging = false;
        let numberLabelResizing = false;
        let numberLabelDragOffset = { x: 0, y: 0 };
        let numberLabelResizeStart = null;
        let numberLabelCounter = 1;
        let editingNumberLabelId = null;
        
        function openNumberLabelDialog(editLabel = null) {
            if (!state.image && !editLabel) { toast('請先載入圖片', 'error'); return; }
            
            if (editLabel) {
                editingNumberLabelId = editLabel.id;
                document.getElementById('number-label-number').value = editLabel.number;
                document.getElementById('number-label-style').value = editLabel.style;
                document.getElementById('number-label-bg-color').value = editLabel.bgColor;
                document.getElementById('number-label-text-color').value = editLabel.textColor;
                document.getElementById('number-label-border-color').value = editLabel.borderColor;
                document.getElementById('number-label-dialog-title').textContent = '✏️ 編輯編號標籤';
                document.getElementById('number-label-add-btn').textContent = '更新標籤';
            } else {
                editingNumberLabelId = null;
                document.getElementById('number-label-number').value = numberLabelCounter;
                document.getElementById('number-label-style').value = 'circle';
                document.getElementById('number-label-bg-color').value = '#ef4444';
                document.getElementById('number-label-text-color').value = '#ffffff';
                document.getElementById('number-label-border-color').value = '#ffffff';
                document.getElementById('number-label-dialog-title').textContent = '🔢 編號標籤';
                document.getElementById('number-label-add-btn').textContent = '添加到畫布';
            }
            
            document.getElementById('number-label-dialog').classList.add('show');
            updateNumberLabelPreview();
        }
        
        function closeNumberLabelDialog() {
            document.getElementById('number-label-dialog').classList.remove('show');
            editingNumberLabelId = null;
        }
        
        function updateNumberLabelPreview() {
            const preview = document.getElementById('number-label-preview');
            const number = document.getElementById('number-label-number').value || '1';
            const style = document.getElementById('number-label-style').value;
            const bgColor = document.getElementById('number-label-bg-color').value;
            const textColor = document.getElementById('number-label-text-color').value;
            const borderColor = document.getElementById('number-label-border-color').value;
            
            let shapeStyle = 'border-radius: 50%;';
            if (style === 'square') shapeStyle = 'border-radius: 8px;';
            if (style === 'diamond') shapeStyle = 'border-radius: 8px; transform: rotate(45deg);';
            if (style === 'star') shapeStyle = 'border-radius: 50%; clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);';
            
            const textTransform = style === 'diamond' ? 'transform: rotate(-45deg);' : '';
            
            preview.innerHTML = `
                <div style="width:60px;height:60px;background:${bgColor};border:4px solid ${borderColor};${shapeStyle}display:flex;align-items:center;justify-content:center;">
                    <span style="color:${textColor};font-size:24px;font-weight:bold;${textTransform}">${number}</span>
                </div>
            `;
        }
        
        function addNumberLabel() {
            if (!state.image && !editingNumberLabelId) { toast('請先載入圖片', 'error'); return; }
            
            const number = document.getElementById('number-label-number').value || '1';
            const style = document.getElementById('number-label-style').value;
            const bgColor = document.getElementById('number-label-bg-color').value;
            const textColor = document.getElementById('number-label-text-color').value;
            const borderColor = document.getElementById('number-label-border-color').value;
            
            if (editingNumberLabelId) {
                const label = numberLabelObjects.find(l => l.id === editingNumberLabelId);
                if (label) {
                    label.number = number;
                    label.style = style;
                    label.bgColor = bgColor;
                    label.textColor = textColor;
                    label.borderColor = borderColor;
                    renderNumberLabels();
                    toast('標籤已更新', 'success');
                }
            } else {
                const label = {
                    id: Date.now(),
                    number: number,
                    style: style,
                    bgColor: bgColor,
                    textColor: textColor,
                    borderColor: borderColor,
                    x: canvas.width / 2 - 40,
                    y: canvas.height / 2 - 40,
                    scale: 1
                };
                
                numberLabelObjects.push(label);
                numberLabelCounter = parseInt(number) + 1;
                renderNumberLabels();
                toast('編號標籤已添加', 'success');
            }
            
            closeNumberLabelDialog();
        }
        
        function renderNumberLabels() {
            document.querySelectorAll('.number-label-obj').forEach(el => el.remove());
            
            const container = document.getElementById('canvas-container');
            
            numberLabelObjects.forEach(label => {
                const wrapper = document.createElement('div');
                wrapper.className = 'number-label-obj';
                wrapper.dataset.id = label.id;
                
                const scale = label.scale || 1;
                const size = 80 * scale;
                const fontSize = 36 * scale;
                const borderWidth = 4 * scale;
                
                let shapeStyle = 'border-radius: 50%;';
                if (label.style === 'square') shapeStyle = 'border-radius: ' + (8 * scale) + 'px;';
                if (label.style === 'diamond') shapeStyle = 'border-radius: ' + (8 * scale) + 'px; transform: rotate(45deg);';
                if (label.style === 'star') shapeStyle = 'border-radius: 50%;';
                
                wrapper.style.cssText = `
                    position: absolute;
                    left: ${label.x}px;
                    top: ${label.y}px;
                    width: ${size}px;
                    height: ${size}px;
                    background: ${label.bgColor};
                    border: ${borderWidth}px solid ${label.borderColor};
                    ${shapeStyle}
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    cursor: move;
                    user-select: none;
                    z-index: 100;
                    box-shadow: 0 4px 15px rgba(0,0,0,0.3);
                `;
                
                // 星形使用 clip-path
                if (label.style === 'star') {
                    wrapper.style.clipPath = 'polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%)';
                }
                
                const textSpan = document.createElement('span');
                textSpan.style.cssText = `
                    color: ${label.textColor};
                    font-size: ${fontSize}px;
                    font-weight: bold;
                    font-family: Arial, sans-serif;
                    pointer-events: none;
                    ${label.style === 'diamond' ? 'transform: rotate(-45deg);' : ''}
                `;
                textSpan.textContent = label.number;
                wrapper.appendChild(textSpan);
                
                // 選中狀態
                if (activeNumberLabel && activeNumberLabel.id === label.id) {
                    wrapper.style.outline = '3px dashed #6366f1';
                    wrapper.style.outlineOffset = '5px';
                }
                
                // 縮放手柄
                const resizeHandle = document.createElement('div');
                resizeHandle.className = 'number-label-resize-handle';
                resizeHandle.style.cssText = `
                    position: absolute;
                    bottom: -8px;
                    right: -8px;
                    width: 16px;
                    height: 16px;
                    background: #6366f1;
                    border: 2px solid #fff;
                    border-radius: 50%;
                    cursor: se-resize;
                    z-index: 102;
                    ${label.style === 'diamond' ? 'transform: rotate(-45deg);' : ''}
                `;
                wrapper.appendChild(resizeHandle);
                
                // 刪除按鈕
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'number-label-delete-btn';
                deleteBtn.innerHTML = '✕';
                deleteBtn.style.cssText = `
                    position: absolute;
                    top: -12px;
                    right: -12px;
                    width: 24px;
                    height: 24px;
                    background: #ef4444;
                    border: none;
                    border-radius: 50%;
                    color: white;
                    font-size: 12px;
                    cursor: pointer;
                    display: none;
                    z-index: 102;
                    ${label.style === 'diamond' ? 'transform: rotate(-45deg);' : ''}
                `;
                wrapper.appendChild(deleteBtn);
                
                // 編輯按鈕
                const editBtn = document.createElement('button');
                editBtn.className = 'number-label-edit-btn';
                editBtn.innerHTML = '✏️';
                editBtn.style.cssText = `
                    position: absolute;
                    top: -12px;
                    left: -12px;
                    width: 24px;
                    height: 24px;
                    background: #22c55e;
                    border: none;
                    border-radius: 50%;
                    font-size: 12px;
                    cursor: pointer;
                    display: none;
                    z-index: 102;
                    ${label.style === 'diamond' ? 'transform: rotate(-45deg);' : ''}
                `;
                wrapper.appendChild(editBtn);
                
                // 事件綁定
                wrapper.onmouseenter = () => {
                    deleteBtn.style.display = 'block';
                    editBtn.style.display = 'block';
                };
                wrapper.onmouseleave = () => {
                    if (!numberLabelDragging && !numberLabelResizing) {
                        deleteBtn.style.display = 'none';
                        editBtn.style.display = 'none';
                    }
                };
                
                deleteBtn.onclick = (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    deleteNumberLabel(label.id);
                };
                
                editBtn.onclick = (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    openNumberLabelDialog(label);
                };
                
                resizeHandle.onmousedown = (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    numberLabelResizing = true;
                    activeNumberLabel = label;
                    numberLabelResizeStart = {
                        x: e.clientX,
                        y: e.clientY,
                        scale: label.scale || 1
                    };
                };
                
                // 雙擊檢測
                let lastClickTime = 0;
                wrapper.onmousedown = (e) => {
                    if (e.target.classList.contains('number-label-resize-handle') ||
                        e.target.classList.contains('number-label-delete-btn') ||
                        e.target.classList.contains('number-label-edit-btn')) return;
                    
                    const now = Date.now();
                    if (now - lastClickTime < 350) {
                        e.preventDefault();
                        e.stopPropagation();
                        openNumberLabelDialog(label);
                        lastClickTime = 0;
                        return;
                    }
                    lastClickTime = now;
                    
                    e.preventDefault();
                    activeNumberLabel = label;
                    numberLabelDragging = true;
                    const rect = wrapper.getBoundingClientRect();
                    numberLabelDragOffset = {
                        x: e.clientX - rect.left,
                        y: e.clientY - rect.top
                    };
                };
                
                container.appendChild(wrapper);
            });
        }
        
        // 全局滑鼠事件處理編號標籤
        document.addEventListener('mousemove', (e) => {
            if (numberLabelResizing && activeNumberLabel && numberLabelResizeStart) {
                const dx = e.clientX - numberLabelResizeStart.x;
                const dy = e.clientY - numberLabelResizeStart.y;
                const delta = (dx + dy) / 200;
                activeNumberLabel.scale = Math.max(0.3, Math.min(3, numberLabelResizeStart.scale + delta));
                renderNumberLabels();
                return;
            }
            
            if (!numberLabelDragging || !activeNumberLabel) return;
            
            const container = document.getElementById('canvas-container');
            const rect = container.getBoundingClientRect();
            
            activeNumberLabel.x = (e.clientX - rect.left - numberLabelDragOffset.x) / state.displayScale;
            activeNumberLabel.y = (e.clientY - rect.top - numberLabelDragOffset.y) / state.displayScale;
            
            renderNumberLabels();
        });
        
        document.addEventListener('mouseup', () => {
            numberLabelDragging = false;
            numberLabelResizing = false;
            numberLabelResizeStart = null;
        });
        
        function deleteNumberLabel(id) {
            numberLabelObjects = numberLabelObjects.filter(l => l.id !== id);
            if (activeNumberLabel && activeNumberLabel.id === id) activeNumberLabel = null;
            renderNumberLabels();
            toast('標籤已刪除', 'info');
        }
        
        function flattenNumberLabels() {
            if (numberLabelObjects.length === 0) {
                toast('沒有標籤需要合併', 'info');
                return;
            }
            
            saveHistory('合併編號標籤');
            
            numberLabelObjects.forEach(label => {
                const scale = label.scale || 1;
                const size = 80 * scale;
                const fontSize = 36 * scale;
                const borderWidth = 4 * scale;
                const x = label.x + size / 2;
                const y = label.y + size / 2;
                
                ctx.save();
                
                if (label.style === 'star') {
                    // 繪製星形
                    drawStar(ctx, x, y, 5, size / 2, size / 4, label.bgColor, label.borderColor, borderWidth);
                } else if (label.style === 'diamond') {
                    // 繪製菱形
                    ctx.translate(x, y);
                    ctx.rotate(Math.PI / 4);
                    ctx.fillStyle = label.bgColor;
                    ctx.strokeStyle = label.borderColor;
                    ctx.lineWidth = borderWidth;
                    ctx.beginPath();
                    ctx.roundRect(-size / 2, -size / 2, size, size, 8 * scale);
                    ctx.fill();
                    ctx.stroke();
                    ctx.rotate(-Math.PI / 4);
                    ctx.translate(-x, -y);
                } else if (label.style === 'square') {
                    // 繪製方形
                    ctx.fillStyle = label.bgColor;
                    ctx.strokeStyle = label.borderColor;
                    ctx.lineWidth = borderWidth;
                    ctx.beginPath();
                    ctx.roundRect(label.x, label.y, size, size, 8 * scale);
                    ctx.fill();
                    ctx.stroke();
                } else {
                    // 繪製圓形
                    ctx.fillStyle = label.bgColor;
                    ctx.strokeStyle = label.borderColor;
                    ctx.lineWidth = borderWidth;
                    ctx.beginPath();
                    ctx.arc(x, y, size / 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                }
                
                // 繪製數字
                ctx.fillStyle = label.textColor;
                ctx.font = `bold ${fontSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(label.number, x, y);
                
                ctx.restore();
            });
            
            numberLabelObjects = [];
            activeNumberLabel = null;
            renderNumberLabels();
            
            const newImg = new Image();
            newImg.src = canvas.toDataURL();
            state.image = newImg;
            
            toast('編號標籤已合併到圖片', 'success');
        }
        
        // 輔助函數：繪製星形
        function drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius, fillColor, strokeColor, lineWidth) {
            let rot = Math.PI / 2 * 3;
            let x = cx;
            let y = cy;
            const step = Math.PI / spikes;
            
            ctx.beginPath();
            ctx.moveTo(cx, cy - outerRadius);
            for (let i = 0; i < spikes; i++) {
                x = cx + Math.cos(rot) * outerRadius;
                y = cy + Math.sin(rot) * outerRadius;
                ctx.lineTo(x, y);
                rot += step;
                
                x = cx + Math.cos(rot) * innerRadius;
                y = cy + Math.sin(rot) * innerRadius;
                ctx.lineTo(x, y);
                rot += step;
            }
            ctx.lineTo(cx, cy - outerRadius);
            ctx.closePath();
            ctx.fillStyle = fillColor;
            ctx.fill();
            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = lineWidth;
            ctx.stroke();
        }
        
        function resetNumberLabelCounter() {
            numberLabelCounter = 1;
            toast('編號已重置為 1', 'info');
        }
        
        // ============ 局部調整功能 ============
        let localAdjustState = { selection: null, scale: 1 };
        
        function openLocalAdjustDialog() {
            if (!state.image) { toast('請先載入圖片', 'error'); return; }
            document.getElementById('local-adjust-dialog').classList.add('show');
            
            const laCanvas = document.getElementById('local-adjust-canvas');
            const maxW = 380, maxH = 300;
            localAdjustState.scale = Math.min(maxW / canvas.width, maxH / canvas.height, 1);
            laCanvas.width = canvas.width * localAdjustState.scale;
            laCanvas.height = canvas.height * localAdjustState.scale;
            const laCtx = laCanvas.getContext('2d');
            laCtx.drawImage(canvas, 0, 0, laCanvas.width, laCanvas.height);
            
            localAdjustState.selection = null;
            resetLocalAdjust();
            
            let isSelecting = false, startX, startY;
            laCanvas.onmousedown = (e) => {
                const rect = laCanvas.getBoundingClientRect();
                startX = e.clientX - rect.left;
                startY = e.clientY - rect.top;
                isSelecting = true;
            };
            laCanvas.onmousemove = (e) => {
                if (!isSelecting) return;
                const rect = laCanvas.getBoundingClientRect();
                const endX = e.clientX - rect.left;
                const endY = e.clientY - rect.top;
                laCtx.drawImage(canvas, 0, 0, laCanvas.width, laCanvas.height);
                laCtx.strokeStyle = '#6366f1';
                laCtx.lineWidth = 2;
                laCtx.setLineDash([5,5]);
                laCtx.strokeRect(startX, startY, endX - startX, endY - startY);
                laCtx.setLineDash([]);
            };
            laCanvas.onmouseup = (e) => {
                if (!isSelecting) return;
                isSelecting = false;
                const rect = laCanvas.getBoundingClientRect();
                const endX = e.clientX - rect.left;
                const endY = e.clientY - rect.top;
                const s = localAdjustState.scale;
                localAdjustState.selection = {
                    x: Math.min(startX, endX) / s,
                    y: Math.min(startY, endY) / s,
                    w: Math.abs(endX - startX) / s,
                    h: Math.abs(endY - startY) / s
                };
            };
        }
        
        function closeLocalAdjustDialog() {
            document.getElementById('local-adjust-dialog').classList.remove('show');
        }
        
        function resetLocalAdjust() {
            ['local-brightness','local-contrast','local-saturation','local-exposure'].forEach(id => {
                document.getElementById(id).value = 0;
                document.getElementById(id + '-val').textContent = '0';
            });
        }
        
        function clearLocalSelection() {
            localAdjustState.selection = null;
            const laCanvas = document.getElementById('local-adjust-canvas');
            const laCtx = laCanvas.getContext('2d');
            laCtx.drawImage(canvas, 0, 0, laCanvas.width, laCanvas.height);
            toast('選取已清除', 'info');
        }
        
        function applyLocalAdjust() {
            if (!localAdjustState.selection || localAdjustState.selection.w < 5) {
                toast('請先框選要調整的區域', 'error');
                return;
            }
            saveHistory('局部調整');
            
            const sel = localAdjustState.selection;
            const brightness = parseInt(document.getElementById('local-brightness').value);
            const contrast = parseInt(document.getElementById('local-contrast').value);
            const saturation = parseInt(document.getElementById('local-saturation').value);
            const exposure = parseInt(document.getElementById('local-exposure').value);
            
            const imageData = ctx.getImageData(sel.x, sel.y, sel.w, sel.h);
            const data = imageData.data;
            
            for (let i = 0; i < data.length; i += 4) {
                let r = data[i], g = data[i+1], b = data[i+2];
                
                // 曝光
                const expFactor = Math.pow(2, exposure / 50);
                r *= expFactor; g *= expFactor; b *= expFactor;
                
                // 亮度
                r += brightness * 2.55; g += brightness * 2.55; b += brightness * 2.55;
                
                // 對比度
                const cf = (259 * (contrast + 255)) / (255 * (259 - contrast));
                r = cf * (r - 128) + 128;
                g = cf * (g - 128) + 128;
                b = cf * (b - 128) + 128;
                
                // 飽和度
                const gray = 0.299*r + 0.587*g + 0.114*b;
                const sf = 1 + saturation / 100;
                r = gray + sf * (r - gray);
                g = gray + sf * (g - gray);
                b = gray + sf * (b - gray);
                
                data[i] = Math.max(0, Math.min(255, r));
                data[i+1] = Math.max(0, Math.min(255, g));
                data[i+2] = Math.max(0, Math.min(255, b));
            }
            
            ctx.putImageData(imageData, sel.x, sel.y);
            closeLocalAdjustDialog();
            toast('局部調整已套用', 'success');
        }
        
        // ============ 透視校正功能 ============
        let perspState = {
            points: { tl: {x:0.1,y:0.1}, tr: {x:0.9,y:0.1}, bl: {x:0.1,y:0.9}, br: {x:0.9,y:0.9} },
            dragging: null,
            scale: 1
        };
        
        function openPerspectiveDialog() {
            if (!state.image) { toast('請先載入圖片', 'error'); return; }
            document.getElementById('perspective-dialog').classList.add('show');
            
            const pCanvas = document.getElementById('perspective-canvas');
            const maxW = 550, maxH = 400;
            perspState.scale = Math.min(maxW / canvas.width, maxH / canvas.height, 1);
            pCanvas.width = canvas.width * perspState.scale;
            pCanvas.height = canvas.height * perspState.scale;
            const pCtx = pCanvas.getContext('2d');
            pCtx.drawImage(canvas, 0, 0, pCanvas.width, pCanvas.height);
            
            resetPerspective();
            initPerspectiveDrag();
        }
        
        function closePerspectiveDialog() {
            document.getElementById('perspective-dialog').classList.remove('show');
        }
        
        function updatePerspectivePoints() {
            const wrapper = document.getElementById('perspective-wrapper');
            const pCanvas = document.getElementById('perspective-canvas');
            ['tl','tr','bl','br'].forEach(corner => {
                const pt = document.getElementById('persp-' + corner);
                pt.style.left = (perspState.points[corner].x * pCanvas.width + 10) + 'px';
                pt.style.top = (perspState.points[corner].y * pCanvas.height + 10) + 'px';
            });
            drawPerspectiveGrid();
        }
        
        function drawPerspectiveGrid() {
            const pCanvas = document.getElementById('perspective-canvas');
            const pCtx = pCanvas.getContext('2d');
            pCtx.drawImage(canvas, 0, 0, pCanvas.width, pCanvas.height);
            
            const p = perspState.points;
            const w = pCanvas.width, h = pCanvas.height;
            
            pCtx.strokeStyle = '#6366f1';
            pCtx.lineWidth = 2;
            pCtx.beginPath();
            pCtx.moveTo(p.tl.x * w, p.tl.y * h);
            pCtx.lineTo(p.tr.x * w, p.tr.y * h);
            pCtx.lineTo(p.br.x * w, p.br.y * h);
            pCtx.lineTo(p.bl.x * w, p.bl.y * h);
            pCtx.closePath();
            pCtx.stroke();
        }
        
        function initPerspectiveDrag() {
            ['tl','tr','bl','br'].forEach(corner => {
                const pt = document.getElementById('persp-' + corner);
                pt.onmousedown = (e) => {
                    e.preventDefault();
                    perspState.dragging = corner;
                };
            });
            
            document.onmousemove = (e) => {
                if (!perspState.dragging) return;
                const wrapper = document.getElementById('perspective-wrapper');
                const pCanvas = document.getElementById('perspective-canvas');
                const rect = pCanvas.getBoundingClientRect();
                let x = (e.clientX - rect.left) / pCanvas.width;
                let y = (e.clientY - rect.top) / pCanvas.height;
                x = Math.max(0, Math.min(1, x));
                y = Math.max(0, Math.min(1, y));
                perspState.points[perspState.dragging] = {x, y};
                updatePerspectivePoints();
            };
            
            document.onmouseup = () => { perspState.dragging = null; };
            updatePerspectivePoints();
        }
        
        function resetPerspective() {
            perspState.points = { tl:{x:0.1,y:0.1}, tr:{x:0.9,y:0.1}, bl:{x:0.1,y:0.9}, br:{x:0.9,y:0.9} };
            updatePerspectivePoints();
        }
        
        function applyPerspectivePreset(preset) {
            const presets = {
                document: { tl:{x:0.05,y:0.05}, tr:{x:0.95,y:0.08}, bl:{x:0.08,y:0.92}, br:{x:0.92,y:0.95} },
                book: { tl:{x:0.1,y:0.08}, tr:{x:0.88,y:0.12}, bl:{x:0.1,y:0.88}, br:{x:0.88,y:0.92} },
                wide: { tl:{x:0.15,y:0.05}, tr:{x:0.85,y:0.05}, bl:{x:0.05,y:0.95}, br:{x:0.95,y:0.95} }
            };
            if (presets[preset]) {
                perspState.points = JSON.parse(JSON.stringify(presets[preset]));
                updatePerspectivePoints();
            }
        }
        
        function applyPerspective() {
            saveHistory('透視校正');
            showLoading('正在進行透視校正...');
            
            setTimeout(() => {
                const p = perspState.points;
                const srcW = canvas.width, srcH = canvas.height;
                
                // 來源四點
                const srcPts = [
                    p.tl.x * srcW, p.tl.y * srcH,
                    p.tr.x * srcW, p.tr.y * srcH,
                    p.br.x * srcW, p.br.y * srcH,
                    p.bl.x * srcW, p.bl.y * srcH
                ];
                
                // 目標四點 (完整畫布)
                const dstPts = [0, 0, srcW, 0, srcW, srcH, 0, srcH];
                
                // 取得原始圖像數據
                const srcData = ctx.getImageData(0, 0, srcW, srcH);
                const dstData = ctx.createImageData(srcW, srcH);
                
                // 計算透視變換矩陣 (簡化版本)
                for (let y = 0; y < srcH; y++) {
                    for (let x = 0; x < srcW; x++) {
                        // 雙線性插值計算源座標
                        const u = x / srcW;
                        const v = y / srcH;
                        
                        const srcX = (1-u)*(1-v)*srcPts[0] + u*(1-v)*srcPts[2] + u*v*srcPts[4] + (1-u)*v*srcPts[6];
                        const srcY = (1-u)*(1-v)*srcPts[1] + u*(1-v)*srcPts[3] + u*v*srcPts[5] + (1-u)*v*srcPts[7];
                        
                        const sx = Math.floor(srcX);
                        const sy = Math.floor(srcY);
                        
                        if (sx >= 0 && sx < srcW && sy >= 0 && sy < srcH) {
                            const srcIdx = (sy * srcW + sx) * 4;
                            const dstIdx = (y * srcW + x) * 4;
                            dstData.data[dstIdx] = srcData.data[srcIdx];
                            dstData.data[dstIdx+1] = srcData.data[srcIdx+1];
                            dstData.data[dstIdx+2] = srcData.data[srcIdx+2];
                            dstData.data[dstIdx+3] = srcData.data[srcIdx+3];
                        }
                    }
                }
                
                ctx.putImageData(dstData, 0, 0);
                hideLoading();
                closePerspectiveDialog();
                toast('透視校正已套用', 'success');
            }, 100);
        }
        
        // ============ 長圖拼接功能 ============
        let longStitchImages = [];
        
        function openLongStitchDialog() {
            document.getElementById('long-stitch-dialog').classList.add('show');
            longStitchImages = [];
            updateLongStitchPreview();
            
            const dropzone = document.getElementById('long-stitch-dropzone');
            const fileInput = document.getElementById('long-stitch-input');
            
            dropzone.onclick = () => fileInput.click();
            dropzone.ondragover = (e) => { e.preventDefault(); dropzone.classList.add('dragover'); };
            dropzone.ondragleave = () => dropzone.classList.remove('dragover');
            dropzone.ondrop = (e) => {
                e.preventDefault();
                dropzone.classList.remove('dragover');
                addLongStitchFiles(e.dataTransfer.files);
            };
            fileInput.onchange = (e) => addLongStitchFiles(e.target.files);
        }
        
        function closeLongStitchDialog() {
            document.getElementById('long-stitch-dialog').classList.remove('show');
            longStitchImages = [];
        }
        
        function addLongStitchFiles(files) {
            const fileArray = Array.from(files);
            
            fileArray.forEach(file => {
                if (!file.type.startsWith('image/')) {
                    console.log('跳過非圖片檔案:', file.name);
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        console.log('圖片載入成功:', file.name, img.width, 'x', img.height);
                        longStitchImages.push({ img: img, name: file.name });
                        updateLongStitchPreview();
                    };
                    img.onerror = (err) => {
                        console.error('圖片載入失敗:', file.name, err);
                        toast('圖片載入失敗: ' + file.name, 'error');
                    };
                    img.src = e.target.result;
                };
                reader.onerror = (err) => {
                    console.error('檔案讀取失敗:', file.name, err);
                };
                reader.readAsDataURL(file);
            });
        }
        
        function updateLongStitchPreview() {
            const preview = document.getElementById('long-stitch-preview');
            const info = document.getElementById('long-stitch-info');
            const direction = document.getElementById('long-stitch-direction')?.value || 'vertical';
            const isVertical = direction === 'vertical';
            
            if (longStitchImages.length === 0) {
                preview.innerHTML = '<div style="text-align:center;color:#666;padding:30px;">尚未添加圖片</div>';
                preview.style.flexDirection = 'column';
                info.textContent = '0 張圖片';
                return;
            }
            
            preview.style.flexDirection = isVertical ? 'column' : 'row';
            preview.style.flexWrap = isVertical ? 'nowrap' : 'nowrap';
            
            let html = '';
            longStitchImages.forEach((item, i) => {
                const imgStyle = isVertical 
                    ? 'max-width:100%;max-height:80px;object-fit:contain;'
                    : 'max-height:100%;max-width:100px;object-fit:contain;';
                html += `<div class="long-stitch-item" draggable="true" data-index="${i}" style="${isVertical ? '' : 'flex-shrink:0;'}">
                    <img src="${item.img.src}" alt="${item.name}" style="${imgStyle}">
                    <div class="long-stitch-item-controls">
                        <button class="long-stitch-item-btn" onclick="removeLongStitchImage(${i})">✕</button>
                    </div>
                </div>`;
            });
            preview.innerHTML = html;
            info.textContent = `${longStitchImages.length} 張圖片`;
            
            // 拖曳排序
            preview.querySelectorAll('.long-stitch-item').forEach(item => {
                item.ondragstart = (e) => {
                    e.dataTransfer.setData('text/plain', item.dataset.index);
                    item.classList.add('dragging');
                };
                item.ondragend = () => item.classList.remove('dragging');
                item.ondragover = (e) => e.preventDefault();
                item.ondrop = (e) => {
                    e.preventDefault();
                    const fromIdx = parseInt(e.dataTransfer.getData('text/plain'));
                    const toIdx = parseInt(item.dataset.index);
                    if (fromIdx !== toIdx) {
                        const [moved] = longStitchImages.splice(fromIdx, 1);
                        longStitchImages.splice(toIdx, 0, moved);
                        updateLongStitchPreview();
                    }
                };
            });
        }
        
        function removeLongStitchImage(idx) {
            longStitchImages.splice(idx, 1);
            updateLongStitchPreview();
        }
        
        function clearLongStitchImages() {
            longStitchImages = [];
            updateLongStitchPreview();
        }
        
        function applyLongStitch() {
            if (longStitchImages.length < 2) {
                toast('請至少添加 2 張圖片', 'error');
                return;
            }
            
            const gap = parseInt(document.getElementById('long-stitch-gap').value) || 0;
            const bgColor = document.getElementById('long-stitch-bg').value;
            const autoSize = document.getElementById('long-stitch-auto-width').checked;
            const direction = document.getElementById('long-stitch-direction').value;
            const isVertical = direction === 'vertical';
            const imageCount = longStitchImages.length;
            
            // 顯示處理中
            const btn = document.querySelector('#long-stitch-dialog .btn-primary');
            btn.textContent = '處理中...';
            btn.disabled = true;
            
            setTimeout(() => {
                try {
                    // 第一步：計算最大寬高
                    let maxW = 0, maxH = 0;
                    for (let i = 0; i < longStitchImages.length; i++) {
                        const item = longStitchImages[i];
                        if (item.img.width > maxW) maxW = item.img.width;
                        if (item.img.height > maxH) maxH = item.img.height;
                    }
                    
                    // 第二步：計算每張圖片縮放後的實際尺寸
                    const scaledSizes = [];
                    for (let i = 0; i < longStitchImages.length; i++) {
                        const item = longStitchImages[i];
                        let dw = item.img.width;
                        let dh = item.img.height;
                        
                        if (isVertical) {
                            // 直向：統一寬度
                            if (autoSize && dw !== maxW) {
                                const scale = maxW / dw;
                                dw = maxW;
                                dh = Math.round(item.img.height * scale);
                            }
                        } else {
                            // 橫向：統一高度
                            if (autoSize && dh !== maxH) {
                                const scale = maxH / dh;
                                dh = maxH;
                                dw = Math.round(item.img.width * scale);
                            }
                        }
                        scaledSizes.push({ w: dw, h: dh });
                    }
                    
                    // 第三步：計算畫布總尺寸
                    const gapTotal = gap * (longStitchImages.length - 1);
                    let canvasW, canvasH;
                    
                    if (isVertical) {
                        canvasW = maxW;
                        canvasH = scaledSizes.reduce((sum, s) => sum + s.h, 0) + gapTotal;
                    } else {
                        canvasW = scaledSizes.reduce((sum, s) => sum + s.w, 0) + gapTotal;
                        canvasH = maxH;
                    }
                    
                    console.log('拼接尺寸:', canvasW, 'x', canvasH);
                    
                    // 第四步：設定畫布並填充背景
                    canvas.width = canvasW;
                    canvas.height = canvasH;
                    ctx.fillStyle = bgColor;
                    ctx.fillRect(0, 0, canvasW, canvasH);
                    
                    // 第五步：繪製圖片
                    let pos = 0;
                    for (let i = 0; i < longStitchImages.length; i++) {
                        const item = longStitchImages[i];
                        const size = scaledSizes[i];
                        let dx = 0, dy = 0;
                        
                        if (isVertical) {
                            dx = Math.round((canvasW - size.w) / 2);
                            dy = pos;
                            pos += size.h + gap;
                        } else {
                            dx = pos;
                            dy = Math.round((canvasH - size.h) / 2);
                            pos += size.w + gap;
                        }
                        
                        ctx.drawImage(item.img, dx, dy, size.w, size.h);
                    }
                    
                    // 第六步：儲存結果
                    const dataUrl = canvas.toDataURL('image/png');
                    state.image = new Image();
                    state.image.src = dataUrl;
                    
                    // 關閉對話框
                    document.getElementById('long-stitch-dialog').classList.remove('show');
                    btn.textContent = '開始拼接';
                    btn.disabled = false;
                    longStitchImages = [];
                    
                    // 更新顯示
                    zoomFit();
                    enableTools();
                    saveHistory('長圖拼接');
                    
                    toast(`已拼接 ${imageCount} 張圖片 (${isVertical ? '直向' : '橫向'})`, 'success');
                    
                } catch (err) {
                    console.error('拼接錯誤:', err);
                    document.getElementById('long-stitch-dialog').classList.remove('show');
                    btn.textContent = '開始拼接';
                    btn.disabled = false;
                    toast('拼接失敗: ' + err.message, 'error');
                }
            }, 100);
        }
    </script>
    <!-- 歷史記錄面板 -->
    <div class="history-panel" id="history-panel">
        <div class="history-panel-header">
            <h3>📜 歷史記錄</h3>
            <button class="history-panel-close" onclick="toggleHistoryPanel()">×</button>
        </div>
        <div class="history-list" id="history-list">
            <div style="padding:20px;text-align:center;color:#666;">尚無歷史記錄</div>
        </div>
    </div>
    
    <!-- 圖層管理面板 -->
    <div class="layer-panel" id="layer-panel">
        <div class="layer-panel-header">
            <span>🔄 圖層管理</span>
            <button class="history-panel-close" onclick="toggleLayerPanel()">×</button>
        </div>
        <div class="layer-panel-body" id="layer-list">
            <div style="padding:20px;text-align:center;color:#666;">尚無圖層</div>
        </div>
        <div class="layer-panel-footer" style="flex-wrap:wrap;">
            <button class="btn btn-outline" onclick="addNewLayer()" title="從圖片新增圖層">📷 加圖</button>
            <button class="btn btn-outline" onclick="addEmptyLayer()" title="新增空白圖層">➕ 空白</button>
            <button class="btn btn-outline" onclick="previewAllLayers()" title="預覽所有圖層合成">👁️ 預覽</button>
            <button class="btn btn-outline" onclick="toggleLayerDragMode()" id="layer-drag-btn" title="拖拉調整圖層位置">🖐️ 拖拉</button>
            <button class="btn btn-outline" onclick="scaleLayer(activeLayerIndex)" title="縮放當前圖層">🔍 縮放</button>
            <button class="btn btn-outline" onclick="rotateLayer(activeLayerIndex)" title="旋轉當前圖層">🔄 旋轉</button>
            <button class="btn btn-outline" onclick="removeLayerBackground(activeLayerIndex)" title="當前圖層去背">✂️ 去背</button>
            <button class="btn btn-outline" onclick="editCurrentLayer()" title="返回編輯當前圖層">✏️ 編輯</button>
            <button class="btn btn-primary" onclick="mergeAllLayers()" title="合併所有可見圖層">🔗 合併</button>
        </div>
    </div>
    
    <!-- 顏色替換對話框 -->
    <div class="color-replace-dialog" id="color-replace-dialog">
        <h3>
            <span>🎨 顏色替換</span>
            <button class="history-panel-close" onclick="closeColorReplaceDialog()">×</button>
        </h3>
        <!-- 換色範圍選擇 -->
        <div class="color-replace-row" style="margin-bottom:12px;">
            <label style="width:auto;margin-right:12px;">範圍：</label>
            <label style="width:auto;cursor:pointer;">
                <input type="radio" name="color-replace-mode" value="all" checked onchange="updateColorReplaceMode()"> 全圖換色
            </label>
            <label style="width:auto;cursor:pointer;margin-left:12px;">
                <input type="radio" name="color-replace-mode" value="region" onchange="updateColorReplaceMode()"> 區域換色
            </label>
        </div>
        <div id="color-replace-region-hint" style="display:none;padding:8px 12px;background:#2a2a2a;border-radius:6px;margin-bottom:12px;font-size:12px;color:#f59e0b;">
            ⚠️ 請先在圖片上框選要換色的區域，再開啟此對話框
        </div>
        <div class="color-replace-row">
            <label>來源顏色：</label>
            <input type="color" id="color-replace-from" value="#ffffff">
            <button class="btn btn-outline" style="padding:4px 8px;font-size:11px;" onclick="pickColorFrom()">🔍 吸取</button>
        </div>
        <div class="color-replace-row">
            <label>目標顏色：</label>
            <input type="color" id="color-replace-to" value="#000000">
        </div>
        <div class="color-replace-row">
            <label>容差值：</label>
            <input type="range" id="color-replace-tolerance" min="0" max="100" value="30">
            <span id="color-replace-tolerance-val">30</span>
        </div>
        <div class="color-replace-preview">
            <div id="color-preview-from" style="background:#fff;">來源</div>
            <div style="font-size:20px;">→</div>
            <div id="color-preview-to" style="background:#000;color:#fff;">目標</div>
        </div>
        <div style="display:flex;gap:8px;">
            <button class="btn btn-outline" onclick="selectColorReplaceRegion()" id="btn-select-region" style="display:none;">📐 框選區域</button>
            <button class="btn btn-outline" onclick="previewColorReplace()">👁️ 預覽</button>
            <button class="btn btn-primary" onclick="applyColorReplace()">✓ 套用</button>
            <button class="btn btn-outline" onclick="closeColorReplaceDialog()">取消</button>
        </div>
    </div>
    
    <!-- 去背進度提示 -->
    <div class="remove-bg-progress" id="remove-bg-progress">
        <div class="spinner"></div>
        <p style="margin-top:16px;">智能去背處理中...</p>
    </div>
    
    <!-- 克隆圖章來源標記 -->
    <div class="clone-source-marker" id="clone-source-marker" style="display:none;"></div>
    
    <!-- 圖片拼接對話框 -->
    <!-- 浮水印對話框 -->
    <!-- 前後對照比較對話框 -->
    <div class="compare-dialog" id="compare-dialog">
        <div class="compare-header">
            <h2>🔀 前後對照比較</h2>
            <button class="history-panel-close" onclick="closeCompareDialog()">×</button>
        </div>
        <div class="compare-body">
            <div class="compare-container" id="compare-container">
                <div class="compare-wrapper" id="compare-wrapper">
                    <img class="compare-image compare-image-after" id="compare-after" alt="編輯後">
                    <img class="compare-image compare-image-before" id="compare-before" alt="編輯前">
                    <div class="compare-slider" id="compare-slider"></div>
                    <div class="compare-labels" id="compare-labels">
                        <span class="compare-label before">編輯前</span>
                        <span class="compare-label after">編輯後</span>
                    </div>
                </div>
            </div>
        </div>
        <div class="compare-footer">
            <div class="compare-mode-btns">
                <button class="compare-mode-btn active" onclick="setCompareMode('slider')" id="mode-slider">滑桿對照</button>
                <button class="compare-mode-btn" onclick="setCompareMode('sidebyside')" id="mode-sidebyside">左右並排</button>
                <button class="compare-mode-btn" onclick="setCompareMode('toggle')" id="mode-toggle">切換顯示</button>
            </div>
            <div class="compare-info">
                <span id="compare-info-text">拖動滑桿比較差異</span>
            </div>
            <button class="btn btn-outline" onclick="closeCompareDialog()">關閉</button>
        </div>
    </div>

    <!-- 濾鏡對話框 -->
    <div class="stitch-dialog" id="filter-dialog">
        <div class="stitch-dialog-content" style="max-width:700px;">
            <div class="stitch-dialog-header">
                <h2>🎨 圖片濾鏡調整</h2>
                <button class="history-panel-close" onclick="closeFilterDialog()">×</button>
            </div>
            <div class="stitch-dialog-body">
                <div class="filter-preview-container">
                    <canvas id="filter-preview-canvas"></canvas>
                </div>
                
                <div class="filter-controls">
                    <div class="filter-row">
                        <label>亮度</label>
                        <input type="range" id="filter-brightness" min="-100" max="100" value="0" oninput="updateFilterPreview()">
                        <span id="filter-brightness-val">0</span>
                    </div>
                    <div class="filter-row">
                        <label>對比度</label>
                        <input type="range" id="filter-contrast" min="-100" max="100" value="0" oninput="updateFilterPreview()">
                        <span id="filter-contrast-val">0</span>
                    </div>
                    <div class="filter-row">
                        <label>飽和度</label>
                        <input type="range" id="filter-saturation" min="-100" max="100" value="0" oninput="updateFilterPreview()">
                        <span id="filter-saturation-val">0</span>
                    </div>
                    <div class="filter-row">
                        <label>色調</label>
                        <input type="range" id="filter-hue" min="-180" max="180" value="0" oninput="updateFilterPreview()">
                        <span id="filter-hue-val">0°</span>
                    </div>
                    <div class="filter-row">
                        <label>模糊</label>
                        <input type="range" id="filter-blur-amount" min="0" max="20" value="0" oninput="updateFilterPreview()">
                        <span id="filter-blur-val">0</span>
                    </div>
                    <div class="filter-row">
                        <label>銳化</label>
                        <input type="range" id="filter-sharpen" min="0" max="100" value="0" oninput="updateFilterPreview()">
                        <span id="filter-sharpen-val">0</span>
                    </div>
                </div>
                
                <div class="filter-presets">
                    <button class="btn btn-outline" onclick="resetFilters()">重置</button>
                    <button class="btn btn-outline" onclick="applyFilterPreset('warm')">暖色調</button>
                    <button class="btn btn-outline" onclick="applyFilterPreset('cool')">冷色調</button>
                    <button class="btn btn-outline" onclick="applyFilterPreset('vintage')">復古</button>
                    <button class="btn btn-outline" onclick="applyFilterPreset('grayscale')">黑白</button>
                    <button class="btn btn-outline" onclick="applyFilterPreset('sepia')">懷舊</button>
                </div>
            </div>
            <div class="stitch-dialog-footer">
                <button class="btn btn-outline" onclick="closeFilterDialog()">取消</button>
                <button class="btn btn-primary" onclick="applyFilters()">套用濾鏡</button>
            </div>
        </div>
    </div>

    <!-- 搜尋取代對話框 -->
    <div class="stitch-dialog" id="search-dialog">
        <div class="stitch-dialog-content" style="max-width:500px;">
            <div class="stitch-dialog-header">
                <h2>🔍 搜尋與取代</h2>
                <button class="history-panel-close" onclick="closeSearchReplace()">×</button>
            </div>
            <div class="stitch-dialog-body">
                <div style="margin-bottom:16px;">
                    <label class="prop-label">搜尋文字</label>
                    <input type="text" class="prop-input" id="search-text" placeholder="輸入要搜尋的文字" style="width:100%;">
                </div>
                <div style="margin-bottom:16px;">
                    <label class="prop-label">取代為</label>
                    <input type="text" class="prop-input" id="replace-text" placeholder="輸入要取代的文字" style="width:100%;">
                </div>
                <div style="margin-bottom:16px;">
                    <label class="prop-label">
                        <input type="checkbox" id="search-case-sensitive"> 區分大小寫
                    </label>
                </div>
                <div id="search-results" style="padding:12px;background:#1a1a1a;border-radius:8px;min-height:60px;">
                    <span style="color:#888;">輸入搜尋文字後點擊「搜尋」</span>
                </div>
            </div>
            <div class="stitch-dialog-footer">
                <button class="btn btn-outline" onclick="closeSearchReplace()">關閉</button>
                <button class="btn btn-outline" onclick="searchText()">搜尋</button>
                <button class="btn btn-outline" onclick="replaceNext()">取代下一個</button>
                <button class="btn btn-primary" onclick="replaceAll()">全部取代</button>
            </div>
        </div>
    </div>

    <!-- 輔助線 -->
    <div class="guides-container hidden" id="guides-container">
        <!-- 滑鼠十字線 -->
        <div class="guide-crosshair guide-crosshair-h" id="guide-cursor-h"></div>
        <div class="guide-crosshair guide-crosshair-v" id="guide-cursor-v"></div>
        <!-- 對齊線（與區域對齊時顯示） -->
        <div class="guide-line guide-h" id="guide-snap-h"></div>
        <div class="guide-line guide-v" id="guide-snap-v"></div>
        <!-- 中心線 -->
        <div class="guide-line guide-h center-line" id="guide-center-h"></div>
        <div class="guide-line guide-v center-line" id="guide-center-v"></div>
        <!-- 固定的輔助線容器 -->
        <div id="guide-fixed-lines"></div>
        <!-- 座標顯示 -->
        <div class="guide-coord" id="guide-coord" style="display:none;"></div>
        <!-- 固定線數量提示 -->
        <div class="guide-fixed-count" id="guide-fixed-count" style="display:none;"></div>
    </div>

    <div class="stitch-dialog" id="watermark-dialog">
        <div class="stitch-dialog-content" style="max-width:900px;width:90vw;">
            <div class="stitch-dialog-header">
                <h2>💧 圖像浮水印</h2>
                <button class="history-panel-close" onclick="closeWatermarkDialog()">×</button>
            </div>
            <div class="stitch-dialog-body" style="max-height:80vh;overflow-y:auto;">
                <div class="stitch-dropzone" id="watermark-dropzone" onclick="document.getElementById('watermark-file-input').click()">
                    <p>拖放浮水印圖片或點擊選擇</p>
                    <input type="file" id="watermark-file-input" accept="image/*" style="display:none" onchange="handleWatermarkFile(this.files[0])">
                </div>
                
                <div id="watermark-settings" style="display:none;">
                    <div class="watermark-preview-container">
                        <div class="watermark-preview-label">預覽（可拖動位置、拖動角落縮放、拖動頂部圓點旋轉）</div>
                        <div class="watermark-preview-wrap" id="watermark-preview-wrap">
                            <canvas id="watermark-preview-canvas"></canvas>
                            <div class="watermark-overlay" id="watermark-overlay">
                                <!-- 四角縮放控制點 -->
                                <div class="watermark-resize-handle nw" data-corner="nw"></div>
                                <div class="watermark-resize-handle ne" data-corner="ne"></div>
                                <div class="watermark-resize-handle sw" data-corner="sw"></div>
                                <div class="watermark-resize-handle se" data-corner="se"></div>
                                <!-- 四邊縮放控制點 -->
                                <div class="watermark-edge-handle n" data-edge="n"></div>
                                <div class="watermark-edge-handle s" data-edge="s"></div>
                                <div class="watermark-edge-handle e" data-edge="e"></div>
                                <div class="watermark-edge-handle w" data-edge="w"></div>
                                <!-- 尺寸顯示 -->
                                <div class="watermark-size-display" id="watermark-size-display">100x100</div>
                                <!-- 旋轉控制 -->
                                <div class="watermark-rotate-line"></div>
                                <div class="watermark-rotate-handle" id="watermark-rotate-handle">↻</div>
                                <div class="watermark-angle-display" id="watermark-angle-display">0°</div>
                            </div>
                        </div>
                    </div>
                    
                    <div style="margin-top:16px;">
                        <label class="prop-label">🔍 快速縮放</label>
                        <div style="display:flex;gap:6px;margin-top:6px;">
                            <button class="btn btn-outline" style="flex:1;font-size:11px;" onclick="scaleWatermark(0.25)">25%</button>
                            <button class="btn btn-outline" style="flex:1;font-size:11px;" onclick="scaleWatermark(0.5)">50%</button>
                            <button class="btn btn-outline" style="flex:1;font-size:11px;" onclick="scaleWatermark(0.75)">75%</button>
                            <button class="btn btn-outline" style="flex:1;font-size:11px;background:#333;" onclick="scaleWatermark(1)">100%</button>
                            <button class="btn btn-outline" style="flex:1;font-size:11px;" onclick="scaleWatermark(1.5)">150%</button>
                            <button class="btn btn-outline" style="flex:1;font-size:11px;" onclick="scaleWatermark(2)">200%</button>
                        </div>
                    </div>
                    
                    <div style="margin-top:12px;display:grid;grid-template-columns:1fr 1fr;gap:12px;">
                        <div>
                            <label class="prop-label">寬度 (px)</label>
                            <input type="number" class="prop-input" id="watermark-width" value="100" min="10" max="2000" onchange="updateWatermarkSize('width', this.value)">
                        </div>
                        <div>
                            <label class="prop-label">高度 (px)</label>
                            <input type="number" class="prop-input" id="watermark-height" value="100" min="10" max="2000" onchange="updateWatermarkSize('height', this.value)">
                        </div>
                    </div>
                    
                    <div style="margin-top:12px;">
                        <label class="prop-label">
                            <input type="checkbox" id="watermark-lock-ratio" checked> 鎖定長寬比
                        </label>
                    </div>
                    
                    <div style="margin-top:12px;">
                        <label class="prop-label">透明度: <span id="watermark-opacity-value">50%</span></label>
                        <input type="range" class="prop-range" id="watermark-opacity" min="0" max="100" value="50" oninput="updateWatermarkOpacityPreview(this.value)">
                    </div>
                    
                    <div style="margin-top:12px;">
                        <label class="prop-label">旋轉角度: <span id="watermark-rotation-value">0°</span></label>
                        <input type="range" class="prop-range" id="watermark-rotation" min="-180" max="180" value="0" oninput="updateWatermarkRotation(this.value)">
                        <div style="display:flex;gap:6px;margin-top:6px;">
                            <button class="btn btn-outline" style="flex:1;font-size:11px;" onclick="setWatermarkRotation(-90)">-90°</button>
                            <button class="btn btn-outline" style="flex:1;font-size:11px;" onclick="setWatermarkRotation(-45)">-45°</button>
                            <button class="btn btn-outline" style="flex:1;font-size:11px;background:#333;" onclick="setWatermarkRotation(0)">0°</button>
                            <button class="btn btn-outline" style="flex:1;font-size:11px;" onclick="setWatermarkRotation(45)">45°</button>
                            <button class="btn btn-outline" style="flex:1;font-size:11px;" onclick="setWatermarkRotation(90)">90°</button>
                        </div>
                    </div>
                    
                    <div style="margin-top:12px;">
                        <label class="prop-label">快速定位</label>
                        <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-top:8px;">
                            <button class="btn btn-outline" onclick="positionWatermark('top-left')">↖ 左上</button>
                            <button class="btn btn-outline" onclick="positionWatermark('top-center')">↑ 上中</button>
                            <button class="btn btn-outline" onclick="positionWatermark('top-right')">↗ 右上</button>
                            <button class="btn btn-outline" onclick="positionWatermark('middle-left')">← 左中</button>
                            <button class="btn btn-outline" onclick="positionWatermark('center')">⊙ 置中</button>
                            <button class="btn btn-outline" onclick="positionWatermark('middle-right')">→ 右中</button>
                            <button class="btn btn-outline" onclick="positionWatermark('bottom-left')">↙ 左下</button>
                            <button class="btn btn-outline" onclick="positionWatermark('bottom-center')">↓ 下中</button>
                            <button class="btn btn-outline" onclick="positionWatermark('bottom-right')">↘ 右下</button>
                        </div>
                    </div>
                    
                    <div id="watermark-apply-scope" style="margin-top:16px;padding:12px;background:#1a1a1a;border-radius:8px;display:none;">
                        <label class="prop-label" style="color:#22c55e;">📄 多頁 PDF 模式</label>
                        <div style="margin-top:8px;display:flex;gap:16px;">
                            <label style="display:flex;align-items:center;gap:6px;cursor:pointer;">
                                <input type="radio" name="watermark-scope" value="current" checked> 僅套用當前頁
                            </label>
                            <label style="display:flex;align-items:center;gap:6px;cursor:pointer;">
                                <input type="radio" name="watermark-scope" value="all"> 套用到所有頁面（相同位置）
                            </label>
                        </div>
                    </div>
                </div>
            </div>
            <div class="stitch-dialog-footer">
                <button class="btn btn-outline" onclick="closeWatermarkDialog()">取消</button>
                <button class="btn btn-primary" onclick="applyWatermark()" id="apply-watermark-btn" disabled>套用浮水印</button>
            </div>
        </div>
    </div>

    <div class="stitch-dialog" id="stitch-dialog">
        <div class="stitch-dialog-content">
            <div class="stitch-dialog-header">
                <h2>📑 圖片拼接</h2>
                <button class="history-panel-close" onclick="closeStitchDialog()">×</button>
            </div>
            <div class="stitch-dialog-body">
                <div class="stitch-dropzone" id="stitch-dropzone" onclick="document.getElementById('stitch-file-input').click()">
                    <div style="font-size:48px;margin-bottom:12px;">📁</div>
                    <div>點擊選擇圖片或拖放圖片到此處</div>
                    <div style="font-size:12px;margin-top:8px;color:#666;">支援多選，可拖曳排序</div>
                    <input type="file" id="stitch-file-input" accept="image/*" multiple style="display:none" onchange="handleStitchFiles(this.files)">
                </div>
                
                <div class="stitch-images-list" id="stitch-images-list"></div>
                
                <div class="stitch-options">
                    <div class="stitch-option selected" onclick="setStitchMode('vertical')" data-mode="vertical">
                        <div class="stitch-option-icon">⬇️</div>
                        <div class="stitch-option-name">垂直拼接</div>
                    </div>
                    <div class="stitch-option" onclick="setStitchMode('horizontal')" data-mode="horizontal">
                        <div class="stitch-option-icon">➡️</div>
                        <div class="stitch-option-name">水平拼接</div>
                    </div>
                    <div class="stitch-option" onclick="setStitchMode('grid')" data-mode="grid">
                        <div class="stitch-option-icon">⊞</div>
                        <div class="stitch-option-name">網格拼接</div>
                    </div>
                </div>
                
                <div style="margin-bottom:16px;">
                    <label style="font-size:12px;color:#888;">圖片間距：</label>
                    <input type="range" id="stitch-gap" min="0" max="50" value="0" style="width:150px;" onchange="updateStitchPreview()">
                    <span id="stitch-gap-value">0px</span>
                </div>
                
                <div class="stitch-preview" id="stitch-preview">
                    <div style="color:#666;">請先添加圖片</div>
                </div>
            </div>
            <div class="stitch-dialog-footer">
                <button class="btn btn-outline" onclick="closeStitchDialog()">取消</button>
                <button class="btn btn-primary" onclick="applyStitch()" id="apply-stitch-btn" disabled>確認拼接</button>
            </div>
        </div>
    </div>
    
    <!-- 頁面縮圖側邊欄 -->
    <div class="page-thumbnails-panel" id="page-thumbnails-panel">
        <div class="thumbnails-header">
            <h3>🖼️ 頁面縮圖</h3>
            <button class="history-panel-close" onclick="togglePageThumbnails()" style="font-size:16px;">×</button>
        </div>
        <div class="thumbnails-list" id="thumbnails-list">
            <div style="text-align:center;color:#888;padding:40px 10px;font-size:12px;">
                載入 PDF 後顯示縮圖
            </div>
        </div>
        <div style="padding:10px;border-top:1px solid #333;">
            <button class="btn btn-outline" style="width:100%;font-size:11px;" onclick="openPageManagerDialog()">📄 頁面管理</button>
        </div>
    </div>
    
    <!-- 印章對話框 -->
    <div class="stitch-dialog" id="stamp-dialog">
        <div class="stitch-dialog-content" style="max-width:700px;">
            <div class="stitch-dialog-header">
                <h2>🔏 印章/圖章</h2>
                <button class="history-panel-close" onclick="closeStampDialog()">×</button>
            </div>
            <div class="stitch-dialog-body">
                <div style="display:grid;grid-template-columns:1fr 250px;gap:20px;">
                    <div>
                        <div class="prop-label" style="margin-bottom:8px;">選擇印章樣式</div>
                        <div style="display:flex;gap:8px;margin-bottom:12px;">
                            <button class="btn btn-outline stamp-tab active" onclick="switchStampTab('preset')" data-tab="preset">預設印章</button>
                            <button class="btn btn-outline stamp-tab" onclick="switchStampTab('custom')" data-tab="custom">自訂印章</button>
                            <button class="btn btn-outline stamp-tab" onclick="switchStampTab('upload')" data-tab="upload">上傳印章</button>
                        </div>
                        
                        <div id="stamp-preset-tab">
                            <div class="stamp-grid" id="stamp-grid">
                                <!-- 預設印章 -->
                                <div class="stamp-item" onclick="selectStamp(this, '已核准')" data-text="已核准">已核准</div>
                                <div class="stamp-item" onclick="selectStamp(this, '已簽收')" data-text="已簽收">已簽收</div>
                                <div class="stamp-item" onclick="selectStamp(this, '已審核')" data-text="已審核">已審核</div>
                                <div class="stamp-item" onclick="selectStamp(this, '急件')" data-text="急件">🔴 急件</div>
                                <div class="stamp-item" onclick="selectStamp(this, '機密')" data-text="機密">🔒 機密</div>
                                <div class="stamp-item" onclick="selectStamp(this, '作廢')" data-text="作廢">❌ 作廢</div>
                                <div class="stamp-item" onclick="selectStamp(this, '原件')" data-text="原件">📋 原件</div>
                                <div class="stamp-item" onclick="selectStamp(this, '副本')" data-text="副本">📄 副本</div>
                                <div class="stamp-item" onclick="selectStamp(this, '草稿')" data-text="草稿">✏️ 草稿</div>
                                <div class="stamp-item" onclick="selectStamp(this, '存查')" data-text="存查">📁 存查</div>
                                <div class="stamp-item" onclick="selectStamp(this, '傳閱')" data-text="傳閱">👀 傳閱</div>
                                <div class="stamp-item" onclick="selectStamp(this, '退回')" data-text="退回">↩️ 退回</div>
                            </div>
                        </div>
                        
                        <div id="stamp-custom-tab" style="display:none;">
                            <div style="margin-bottom:12px;">
                                <label class="prop-label">印章文字</label>
                                <input type="text" class="prop-input" id="stamp-custom-text" placeholder="輸入印章文字" 
                                    value="已核准" oninput="updateStampPreview()">
                            </div>
                            <div style="margin-bottom:12px;">
                                <label class="prop-label">印章形狀</label>
                                <select class="prop-input" id="stamp-custom-shape" onchange="updateStampPreview()">
                                    <option value="rect">方形</option>
                                    <option value="rect-round">圓角方形</option>
                                    <option value="circle">圓形</option>
                                    <option value="ellipse">橢圓形</option>
                                </select>
                            </div>
                        </div>
                        
                        <div id="stamp-upload-tab" style="display:none;">
                            <div class="stitch-dropzone" id="stamp-dropzone" style="min-height:150px;" 
                                onclick="document.getElementById('stamp-file-input').click()">
                                <p>拖放印章圖片或點擊選擇</p>
                                <input type="file" id="stamp-file-input" accept="image/*" style="display:none" 
                                    onchange="handleStampUpload(this.files[0])">
                            </div>
                        </div>
                    </div>
                    
                    <div>
                        <div class="prop-label" style="margin-bottom:8px;">預覽</div>
                        <div class="stamp-preview" id="stamp-preview">
                            <div class="stamp-preview-content" id="stamp-preview-content">已核准</div>
                        </div>
                        
                        <div style="margin-top:16px;">
                            <div class="prop-label" style="margin-bottom:8px;">印章顏色</div>
                            <div class="stamp-color-options">
                                <button class="stamp-color-btn active" style="background:#dc2626;" onclick="setStampColor('#dc2626')"></button>
                                <button class="stamp-color-btn" style="background:#2563eb;" onclick="setStampColor('#2563eb')"></button>
                                <button class="stamp-color-btn" style="background:#16a34a;" onclick="setStampColor('#16a34a')"></button>
                                <button class="stamp-color-btn" style="background:#000000;" onclick="setStampColor('#000000')"></button>
                                <button class="stamp-color-btn" style="background:#7c3aed;" onclick="setStampColor('#7c3aed')"></button>
                                <input type="color" value="#dc2626" style="width:30px;height:30px;border:none;cursor:pointer;" 
                                    onchange="setStampColor(this.value)">
                            </div>
                        </div>
                        
                        <div style="margin-top:16px;">
                            <div class="prop-row">
                                <span class="prop-label">大小</span>
                                <input type="range" class="prop-range" value="100" min="30" max="300" 
                                    id="stamp-size" oninput="updateStampPreview()">
                                <span id="stamp-size-value">100px</span>
                            </div>
                            <div class="prop-row">
                                <span class="prop-label">旋轉</span>
                                <input type="range" class="prop-range" value="0" min="-45" max="45" 
                                    id="stamp-rotation" oninput="updateStampPreview()">
                                <span id="stamp-rotation-value">0°</span>
                            </div>
                            <div class="prop-row">
                                <span class="prop-label">透明度</span>
                                <input type="range" class="prop-range" value="80" min="20" max="100" 
                                    id="stamp-opacity" oninput="updateStampPreview()">
                                <span id="stamp-opacity-value">80%</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="stitch-dialog-footer">
                <button class="btn btn-outline" onclick="closeStampDialog()">取消</button>
                <button class="btn btn-outline" onclick="applyStampEditable()" title="添加後可拖動調整位置">🖐️ 可編輯添加</button>
                <button class="btn btn-primary" onclick="applyStamp()" title="直接蓋印到畫布中央">套用印章</button>
            </div>
        </div>
    </div>
    
    <!-- 頁面管理對話框 -->
    <div class="stitch-dialog" id="page-manager-dialog">
        <div class="stitch-dialog-content" style="max-width:900px;width:90vw;">
            <div class="stitch-dialog-header">
                <h2>📄 頁面管理</h2>
                <button class="history-panel-close" onclick="closePageManagerDialog()">×</button>
            </div>
            <div class="stitch-dialog-body">
                <div style="display:flex;gap:10px;margin-bottom:16px;flex-wrap:wrap;">
                    <button class="btn btn-outline" onclick="pageManagerAddBlank()">➕ 新增空白頁</button>
                    <button class="btn btn-outline" onclick="pageManagerImportImage()">📷 匯入圖片</button>
                    <button class="btn btn-outline" onclick="pageManagerSelectAll()">☑️ 全選</button>
                    <button class="btn btn-outline" onclick="pageManagerDeselectAll()">⬜ 取消全選</button>
                    <div style="flex:1;"></div>
                    <button class="btn btn-danger" onclick="pageManagerDeleteSelected()">🗑️ 刪除選取</button>
                </div>
                
                <div class="page-manager-grid" id="page-manager-grid">
                    <div style="grid-column:1/-1;text-align:center;color:#888;padding:60px;">
                        載入 PDF 後顯示頁面
                    </div>
                </div>
                
                <div style="margin-top:16px;padding:12px;background:#1a1a1a;border-radius:8px;">
                    <div style="font-size:12px;color:#888;">
                        💡 提示：拖拉頁面可重新排序 | 點擊選取頁面 | Shift+點擊多選
                    </div>
                </div>
            </div>
            <div class="stitch-dialog-footer">
                <button class="btn btn-outline" onclick="closePageManagerDialog()">關閉</button>
                <button class="btn btn-primary" onclick="applyPageManagerChanges()">套用變更</button>
            </div>
        </div>
    </div>
    
    <!-- 圖片優化對話框 -->
    <div class="stitch-dialog" id="image-optimize-dialog">
        <div class="stitch-dialog-content" style="max-width:800px;">
            <div class="stitch-dialog-header">
                <h2>✨ 圖片自動優化</h2>
                <button class="history-panel-close" onclick="closeImageOptimizeDialog()">×</button>
            </div>
            <div class="stitch-dialog-body">
                <div class="optimize-preview-container">
                    <div class="optimize-preview-box">
                        <div class="optimize-preview-label">原始圖片</div>
                        <canvas id="optimize-preview-original" class="optimize-preview-canvas"></canvas>
                    </div>
                    <div class="optimize-preview-box">
                        <div class="optimize-preview-label">優化後預覽</div>
                        <canvas id="optimize-preview-result" class="optimize-preview-canvas"></canvas>
                    </div>
                </div>
                
                <div class="prop-label" style="margin-bottom:10px;">一鍵優化預設</div>
                <div class="optimize-presets">
                    <button class="optimize-preset-btn" onclick="applyOptimizePreset('auto')">
                        <div class="optimize-preset-icon">🎯</div>
                        <div class="optimize-preset-name">自動優化</div>
                    </button>
                    <button class="optimize-preset-btn" onclick="applyOptimizePreset('denoise')">
                        <div class="optimize-preset-icon">🔇</div>
                        <div class="optimize-preset-name">去噪</div>
                    </button>
                    <button class="optimize-preset-btn" onclick="applyOptimizePreset('sharpen')">
                        <div class="optimize-preset-icon">🔪</div>
                        <div class="optimize-preset-name">銳化</div>
                    </button>
                    <button class="optimize-preset-btn" onclick="applyOptimizePreset('contrast')">
                        <div class="optimize-preset-icon">◐</div>
                        <div class="optimize-preset-name">增強對比</div>
                    </button>
                    <button class="optimize-preset-btn" onclick="applyOptimizePreset('brighten')">
                        <div class="optimize-preset-icon">☀️</div>
                        <div class="optimize-preset-name">提亮</div>
                    </button>
                    <button class="optimize-preset-btn" onclick="applyOptimizePreset('vivid')">
                        <div class="optimize-preset-icon">🌈</div>
                        <div class="optimize-preset-name">鮮豔</div>
                    </button>
                </div>
                
                <div style="margin-top:20px;">
                    <div class="prop-label" style="margin-bottom:10px;">手動調整</div>
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:16px;">
                        <div>
                            <div class="prop-row">
                                <span class="prop-label">去噪強度</span>
                                <input type="range" class="prop-range" id="optimize-denoise" value="0" min="0" max="100" oninput="updateOptimizePreview()">
                                <span id="optimize-denoise-value">0</span>
                            </div>
                            <div class="prop-row">
                                <span class="prop-label">銳化程度</span>
                                <input type="range" class="prop-range" id="optimize-sharpen" value="0" min="0" max="100" oninput="updateOptimizePreview()">
                                <span id="optimize-sharpen-value">0</span>
                            </div>
                        </div>
                        <div>
                            <div class="prop-row">
                                <span class="prop-label">對比度</span>
                                <input type="range" class="prop-range" id="optimize-contrast" value="0" min="-50" max="50" oninput="updateOptimizePreview()">
                                <span id="optimize-contrast-value">0</span>
                            </div>
                            <div class="prop-row">
                                <span class="prop-label">亮度</span>
                                <input type="range" class="prop-range" id="optimize-brightness" value="0" min="-50" max="50" oninput="updateOptimizePreview()">
                                <span id="optimize-brightness-value">0</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div style="margin-top:12px;">
                    <label style="display:flex;align-items:center;gap:8px;cursor:pointer;font-size:13px;color:#aaa;">
                        <input type="checkbox" id="optimize-apply-all"> 套用到所有頁面
                    </label>
                </div>
            </div>
            <div class="stitch-dialog-footer">
                <button class="btn btn-outline" onclick="resetOptimizeSettings()">重置</button>
                <button class="btn btn-outline" onclick="closeImageOptimizeDialog()">取消</button>
                <button class="btn btn-primary" onclick="applyImageOptimize()">套用優化</button>
            </div>
        </div>
    </div>
    
    <!-- 頁首頁尾對話框 -->
    <div class="stitch-dialog" id="header-footer-dialog">
        <div class="stitch-dialog-content" style="max-width:800px;">
            <div class="stitch-dialog-header">
                <h2>📑 頁首頁尾</h2>
                <button class="history-panel-close" onclick="closeHeaderFooterDialog()">×</button>
            </div>
            <div class="stitch-dialog-body">
                <div style="display:grid;grid-template-columns:1fr 280px;gap:20px;">
                    <div>
                        <div class="prop-label" style="margin-bottom:12px;">頁首設定</div>
                        <div class="hf-input-row">
                            <label>左側</label>
                            <input type="text" class="prop-input" id="hf-header-left" placeholder="頁首左側文字" oninput="updateHeaderFooterPreview()">
                        </div>
                        <div class="hf-input-row">
                            <label>中間</label>
                            <input type="text" class="prop-input" id="hf-header-center" placeholder="頁首中間文字" oninput="updateHeaderFooterPreview()">
                        </div>
                        <div class="hf-input-row">
                            <label>右側</label>
                            <input type="text" class="prop-input" id="hf-header-right" placeholder="頁首右側文字" oninput="updateHeaderFooterPreview()">
                        </div>
                        
                        <div class="prop-label" style="margin:20px 0 12px;">頁尾設定</div>
                        <div class="hf-input-row">
                            <label>左側</label>
                            <input type="text" class="prop-input" id="hf-footer-left" placeholder="頁尾左側文字" oninput="updateHeaderFooterPreview()">
                        </div>
                        <div class="hf-input-row">
                            <label>中間</label>
                            <input type="text" class="prop-input" id="hf-footer-center" value="第 {page} 頁，共 {total} 頁" placeholder="頁尾中間文字" oninput="updateHeaderFooterPreview()">
                        </div>
                        <div class="hf-input-row">
                            <label>右側</label>
                            <input type="text" class="prop-input" id="hf-footer-right" placeholder="頁尾右側文字" oninput="updateHeaderFooterPreview()">
                        </div>
                        
                        <div class="prop-label" style="margin-top:16px;margin-bottom:8px;">插入變數</div>
                        <div class="hf-variables">
                            <button class="hf-variable-btn" onclick="insertHFVariable('{page}')">{page} 頁碼</button>
                            <button class="hf-variable-btn" onclick="insertHFVariable('{total}')">{total} 總頁數</button>
                            <button class="hf-variable-btn" onclick="insertHFVariable('{date}')">{date} 日期</button>
                            <button class="hf-variable-btn" onclick="insertHFVariable('{time}')">{time} 時間</button>
                            <button class="hf-variable-btn" onclick="insertHFVariable('{filename}')">{filename} 檔名</button>
                        </div>
                        
                        <div style="margin-top:16px;display:grid;grid-template-columns:1fr 1fr;gap:12px;">
                            <div>
                                <label class="prop-label">字體大小</label>
                                <input type="number" class="prop-input" id="hf-font-size" value="12" min="8" max="24" oninput="updateHeaderFooterPreview()">
                            </div>
                            <div>
                                <label class="prop-label">文字顏色</label>
                                <input type="color" class="prop-input" id="hf-font-color" value="#666666" style="height:36px;" oninput="updateHeaderFooterPreview()">
                            </div>
                        </div>
                    </div>
                    
                    <div>
                        <div class="prop-label" style="margin-bottom:8px;">預覽</div>
                        <div class="header-footer-preview" id="hf-preview">
                            <div class="hf-preview-header" id="hf-preview-header"></div>
                            <div class="hf-preview-content"></div>
                            <div class="hf-preview-footer" id="hf-preview-footer">第 1 頁，共 5 頁</div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="stitch-dialog-footer">
                <button class="btn btn-outline" onclick="closeHeaderFooterDialog()">取消</button>
                <button class="btn btn-primary" onclick="applyHeaderFooter()">套用到所有頁面</button>
            </div>
        </div>
    </div>
    
    <!-- PDF 加密對話框 -->
    <div class="stitch-dialog" id="pdf-encrypt-dialog">
        <div class="stitch-dialog-content" style="max-width:500px;">
            <div class="stitch-dialog-header">
                <h2>🔐 PDF 加密設定</h2>
                <button class="history-panel-close" onclick="closePdfEncryptDialog()">×</button>
            </div>
            <div class="stitch-dialog-body">
                <div class="pdf-encrypt-options">
                    <div class="encrypt-option-row">
                        <label style="display:flex;align-items:center;gap:8px;width:auto;">
                            <input type="checkbox" id="encrypt-enable" onchange="toggleEncryptOptions()"> 啟用密碼保護
                        </label>
                    </div>
                    
                    <div id="encrypt-options-panel" style="display:none;">
                        <div class="encrypt-option-row">
                            <label>開啟密碼</label>
                            <input type="password" class="prop-input" id="encrypt-user-password" placeholder="設定開啟 PDF 所需的密碼">
                        </div>
                        
                        <div class="encrypt-option-row">
                            <label>權限密碼</label>
                            <input type="password" class="prop-input" id="encrypt-owner-password" placeholder="設定修改權限的密碼（可選）">
                        </div>
                        
                        <div class="prop-label" style="margin-top:16px;margin-bottom:8px;">權限設定</div>
                        <div class="encrypt-permissions">
                            <label class="encrypt-permission-item">
                                <input type="checkbox" id="encrypt-allow-print" checked> 允許列印
                            </label>
                            <label class="encrypt-permission-item">
                                <input type="checkbox" id="encrypt-allow-copy" checked> 允許複製
                            </label>
                            <label class="encrypt-permission-item">
                                <input type="checkbox" id="encrypt-allow-modify"> 允許修改
                            </label>
                            <label class="encrypt-permission-item">
                                <input type="checkbox" id="encrypt-allow-annotate" checked> 允許註解
                            </label>
                        </div>
                        
                        <div style="margin-top:16px;padding:10px;background:#1a2a1a;border-radius:6px;border:1px solid #22c55e;">
                            <div style="font-size:12px;color:#22c55e;">
                                💡 提示：開啟密碼用於保護 PDF 不被未授權的人開啟。權限密碼用於控制列印、複製等操作。
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="stitch-dialog-footer">
                <button class="btn btn-outline" onclick="closePdfEncryptDialog()">取消</button>
                <button class="btn btn-primary" onclick="downloadEncryptedPdf()">下載加密 PDF</button>
            </div>
        </div>
    </div>
    
    <!-- 語音泡泡對話框 -->
    <div class="stitch-dialog" id="speech-bubble-dialog">
        <div class="stitch-dialog-content" style="max-width:580px;">
            <div class="stitch-dialog-header">
                <h2 id="bubble-dialog-title">💬 語音泡泡</h2>
                <button class="history-panel-close" onclick="closeSpeechBubbleDialog()">×</button>
            </div>
            <div class="stitch-dialog-body">
                <div class="prop-label" style="margin-bottom:10px;">選擇泡泡類型</div>
                <div class="bubble-type-selector">
                    <button class="bubble-type-btn active" data-type="speech" onclick="selectBubbleType('speech')">
                        <span>💬</span><small>對話框</small>
                    </button>
                    <button class="bubble-type-btn" data-type="thought" onclick="selectBubbleType('thought')">
                        <span>💭</span><small>思考泡泡</small>
                    </button>
                    <button class="bubble-type-btn" data-type="shout" onclick="selectBubbleType('shout')">
                        <span>💥</span><small>驚嘆框</small>
                    </button>
                    <button class="bubble-type-btn" data-type="cloud" onclick="selectBubbleType('cloud')">
                        <span>☁️</span><small>雲朵框</small>
                    </button>
                </div>
                
                <div style="display:grid;grid-template-columns:1fr 180px;gap:16px;margin-top:12px;">
                    <div>
                        <div class="prop-label">泡泡文字</div>
                        <textarea id="bubble-text" class="prop-input" rows="3" placeholder="輸入對話內容..." style="resize:none;">你好！</textarea>
                        
                        <div style="margin-top:10px;">
                            <label style="display:flex;align-items:center;gap:8px;cursor:pointer;font-size:13px;color:#ccc;">
                                <input type="checkbox" id="bubble-vertical" onchange="toggleVerticalText()"> 
                                <span>📝 直式文字（漫畫風格）</span>
                            </label>
                        </div>
                        
                        <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:12px;">
                            <div>
                                <label class="prop-label">背景色</label>
                                <input type="color" class="prop-input" id="bubble-bg-color" value="#ffffff" style="height:32px;" onchange="updateBubblePreview()">
                            </div>
                            <div>
                                <label class="prop-label">文字色</label>
                                <input type="color" class="prop-input" id="bubble-text-color" value="#000000" style="height:32px;" onchange="updateBubblePreview()">
                            </div>
                            <div>
                                <label class="prop-label">邊框色</label>
                                <input type="color" class="prop-input" id="bubble-border-color" value="#000000" style="height:32px;" onchange="updateBubblePreview()">
                            </div>
                            <div>
                                <label class="prop-label">字體大小</label>
                                <input type="number" class="prop-input" id="bubble-font-size" value="18" min="12" max="48" onchange="updateBubblePreview()">
                            </div>
                            <div>
                                <label class="prop-label">字型</label>
                                <select class="prop-input" id="bubble-font-family" style="height:32px;" onchange="updateBubblePreview()">
                                    <option value="Noto Sans TC">Noto Sans TC</option>
                                    <option value="Microsoft JhengHei">微軟正黑體</option>
                                    <option value="PMingLiU">新細明體</option>
                                    <option value="DFKai-SB">標楷體</option>
                                    <option value="jf-openhuninn">粉圓體</option>
                                    <option value="Arial">Arial</option>
                                    <option value="Comic Sans MS">Comic Sans</option>
                                    <option value="Impact">Impact</option>
                                </select>
                            </div>
                            <div>
                                <label class="prop-label">粗體</label>
                                <label style="display:flex;align-items:center;gap:8px;height:32px;cursor:pointer;">
                                    <input type="checkbox" id="bubble-font-bold" onchange="updateBubblePreview()">
                                    <span style="font-size:13px;color:#ccc;">啟用粗體</span>
                                </label>
                            </div>
                        </div>
                    </div>
                    <div>
                        <div class="prop-label">預覽</div>
                        <div class="bubble-preview-box" id="bubble-preview"></div>
                    </div>
                </div>
                
                <div style="margin-top:12px;">
                    <div class="prop-label">尾巴方向</div>
                    <div style="display:flex;gap:6px;margin-top:6px;flex-wrap:wrap;">
                        <button class="tool-btn active" id="tail-bl" onclick="setBubbleTail('bottom-left')">↙ 左下</button>
                        <button class="tool-btn" id="tail-br" onclick="setBubbleTail('bottom-right')">↘ 右下</button>
                        <button class="tool-btn" id="tail-tl" onclick="setBubbleTail('top-left')">↖ 左上</button>
                        <button class="tool-btn" id="tail-tr" onclick="setBubbleTail('top-right')">↗ 右上</button>
                        <button class="tool-btn" id="tail-none" onclick="setBubbleTail('none')">✕ 無</button>
                    </div>
                </div>
                
                <div style="margin-top:12px;padding:10px;background:#1a2a1a;border-radius:6px;border:1px solid #22c55e;">
                    <div style="font-size:12px;color:#22c55e;">
                        💡 <b>操作說明：</b><br>
                        • 拖曳泡泡移動位置<br>
                        • 拖曳右下角藍點縮放大小（文字會一起縮放）<br>
                        • 雙擊泡泡進入編輯模式<br>
                        • 思考泡泡會顯示三個由小到大的圓圈<br>
                        • 完成後點「合併泡泡」固定到圖片
                    </div>
                </div>
            </div>
            <div class="stitch-dialog-footer">
                <button class="btn btn-outline" onclick="closeSpeechBubbleDialog()">取消</button>
                <button class="btn btn-outline" onclick="flattenSpeechBubbles()" style="background:#f59e0b;border-color:#f59e0b;color:#000;">🔗 合併泡泡</button>
                <button class="btn btn-primary" id="bubble-add-btn" onclick="addSpeechBubble()">添加到畫布</button>
            </div>
        </div>
    </div>
    
    <!-- 編號標籤對話框 -->
    <div class="stitch-dialog" id="number-label-dialog">
        <div class="stitch-dialog-content" style="max-width:450px;">
            <div class="stitch-dialog-header">
                <h2 id="number-label-dialog-title">🔢 編號標籤</h2>
                <button class="history-panel-close" onclick="closeNumberLabelDialog()">×</button>
            </div>
            <div class="stitch-dialog-body">
                <div style="display:grid;grid-template-columns:1fr 120px;gap:20px;">
                    <div>
                        <div class="prop-row" style="margin-bottom:12px;">
                            <span class="prop-label">編號數字</span>
                            <input type="text" class="prop-input" id="number-label-number" value="1" style="width:80px;" oninput="updateNumberLabelPreview()">
                        </div>
                        
                        <div class="prop-row" style="margin-bottom:12px;">
                            <span class="prop-label">形狀樣式</span>
                            <select class="prop-input" id="number-label-style" style="width:120px;" onchange="updateNumberLabelPreview()">
                                <option value="circle">⭕ 圓形</option>
                                <option value="square">⬜ 方形</option>
                                <option value="diamond">🔷 菱形</option>
                                <option value="star">⭐ 星形</option>
                            </select>
                        </div>
                        
                        <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:8px;">
                            <div>
                                <label class="prop-label" style="font-size:11px;">背景色</label>
                                <input type="color" class="prop-input" id="number-label-bg-color" value="#ef4444" style="height:32px;width:100%;" onchange="updateNumberLabelPreview()">
                            </div>
                            <div>
                                <label class="prop-label" style="font-size:11px;">文字色</label>
                                <input type="color" class="prop-input" id="number-label-text-color" value="#ffffff" style="height:32px;width:100%;" onchange="updateNumberLabelPreview()">
                            </div>
                            <div>
                                <label class="prop-label" style="font-size:11px;">邊框色</label>
                                <input type="color" class="prop-input" id="number-label-border-color" value="#ffffff" style="height:32px;width:100%;" onchange="updateNumberLabelPreview()">
                            </div>
                        </div>
                        
                        <div style="margin-top:12px;">
                            <button class="btn btn-outline" style="width:100%;" onclick="resetNumberLabelCounter()">↺ 重置編號為 1</button>
                        </div>
                    </div>
                    <div>
                        <div class="prop-label" style="margin-bottom:8px;">預覽</div>
                        <div id="number-label-preview" style="width:100%;height:100px;background:#1a1a1a;border-radius:8px;display:flex;align-items:center;justify-content:center;"></div>
                    </div>
                </div>
                
                <div style="margin-top:12px;padding:10px;background:#1a2a1a;border-radius:6px;border:1px solid #22c55e;">
                    <div style="font-size:12px;color:#22c55e;">
                        💡 <b>操作說明：</b><br>
                        • 拖曳標籤移動位置<br>
                        • 拖曳右下角藍點縮放大小<br>
                        • 雙擊標籤編輯樣式和數字<br>
                        • 完成後點「合併標籤」固定到圖片
                    </div>
                </div>
            </div>
            <div class="stitch-dialog-footer">
                <button class="btn btn-outline" onclick="closeNumberLabelDialog()">取消</button>
                <button class="btn btn-outline" onclick="flattenNumberLabels()" style="background:#f59e0b;border-color:#f59e0b;color:#000;">🔗 合併標籤</button>
                <button class="btn btn-primary" id="number-label-add-btn" onclick="addNumberLabel()">添加到畫布</button>
            </div>
        </div>
    </div>
    
    <!-- 局部調整對話框 -->
    <div class="stitch-dialog" id="local-adjust-dialog">
        <div class="stitch-dialog-content" style="max-width:700px;">
            <div class="stitch-dialog-header">
                <h2>🎯 局部調整</h2>
                <button class="history-panel-close" onclick="closeLocalAdjustDialog()">×</button>
            </div>
            <div class="stitch-dialog-body">
                <div style="display:grid;grid-template-columns:1fr 250px;gap:20px;">
                    <div>
                        <div class="prop-label" style="margin-bottom:8px;">在預覽圖上框選要調整的區域</div>
                        <div style="background:#1a1a1a;border-radius:8px;padding:10px;overflow:hidden;">
                            <canvas id="local-adjust-canvas" style="max-width:100%;cursor:crosshair;display:block;margin:0 auto;"></canvas>
                        </div>
                    </div>
                    <div>
                        <div class="prop-label" style="margin-bottom:12px;">調整參數</div>
                        <div class="prop-row">
                            <span class="prop-label">亮度</span>
                            <input type="range" class="prop-range" id="local-brightness" value="0" min="-100" max="100" oninput="document.getElementById('local-brightness-val').textContent=this.value">
                            <span id="local-brightness-val">0</span>
                        </div>
                        <div class="prop-row">
                            <span class="prop-label">對比度</span>
                            <input type="range" class="prop-range" id="local-contrast" value="0" min="-100" max="100" oninput="document.getElementById('local-contrast-val').textContent=this.value">
                            <span id="local-contrast-val">0</span>
                        </div>
                        <div class="prop-row">
                            <span class="prop-label">飽和度</span>
                            <input type="range" class="prop-range" id="local-saturation" value="0" min="-100" max="100" oninput="document.getElementById('local-saturation-val').textContent=this.value">
                            <span id="local-saturation-val">0</span>
                        </div>
                        <div class="prop-row">
                            <span class="prop-label">曝光</span>
                            <input type="range" class="prop-range" id="local-exposure" value="0" min="-100" max="100" oninput="document.getElementById('local-exposure-val').textContent=this.value">
                            <span id="local-exposure-val">0</span>
                        </div>
                        
                        <div style="margin-top:16px;">
                            <button class="btn btn-outline" style="width:100%;margin-bottom:8px;" onclick="resetLocalAdjust()">重置參數</button>
                            <button class="btn btn-outline" style="width:100%;" onclick="clearLocalSelection()">清除選取</button>
                        </div>
                        
                        <div style="margin-top:12px;padding:8px;background:#1a2a1a;border-radius:6px;font-size:11px;color:#22c55e;">
                            💡 在左側預覽圖上拖曳框選區域，然後調整參數
                        </div>
                    </div>
                </div>
            </div>
            <div class="stitch-dialog-footer">
                <button class="btn btn-outline" onclick="closeLocalAdjustDialog()">取消</button>
                <button class="btn btn-primary" onclick="applyLocalAdjust()">套用調整</button>
            </div>
        </div>
    </div>
    
    <!-- 透視校正對話框 -->
    <div class="stitch-dialog" id="perspective-dialog">
        <div class="stitch-dialog-content" style="max-width:800px;">
            <div class="stitch-dialog-header">
                <h2>📐 透視校正</h2>
                <button class="history-panel-close" onclick="closePerspectiveDialog()">×</button>
            </div>
            <div class="stitch-dialog-body">
                <div style="display:grid;grid-template-columns:1fr 180px;gap:20px;">
                    <div>
                        <div class="prop-label" style="margin-bottom:8px;">拖曳四個藍色角點調整透視</div>
                        <div class="perspective-wrapper" id="perspective-wrapper" style="background:#1a1a1a;border-radius:8px;padding:10px;text-align:center;">
                            <canvas id="perspective-canvas" style="max-width:100%;max-height:400px;"></canvas>
                            <div class="perspective-point" id="persp-tl" style="left:10%;top:10%;"></div>
                            <div class="perspective-point" id="persp-tr" style="left:90%;top:10%;"></div>
                            <div class="perspective-point" id="persp-bl" style="left:10%;top:90%;"></div>
                            <div class="perspective-point" id="persp-br" style="left:90%;top:90%;"></div>
                        </div>
                    </div>
                    <div>
                        <div class="prop-label" style="margin-bottom:10px;">快速校正</div>
                        <button class="btn btn-outline" style="width:100%;margin-bottom:8px;" onclick="resetPerspective()">↺ 重置</button>
                        
                        <div class="prop-label" style="margin:16px 0 10px;">預設模式</div>
                        <button class="btn btn-outline" style="width:100%;margin-bottom:6px;" onclick="applyPerspectivePreset('document')">📄 文件校正</button>
                        <button class="btn btn-outline" style="width:100%;margin-bottom:6px;" onclick="applyPerspectivePreset('book')">📖 書本校正</button>
                        <button class="btn btn-outline" style="width:100%;" onclick="applyPerspectivePreset('wide')">🏢 廣角校正</button>
                        
                        <div style="margin-top:16px;padding:8px;background:#1a1a1a;border-radius:6px;font-size:11px;color:#888;">
                            提示：拖曳藍色角點到文件的四個角落位置
                        </div>
                    </div>
                </div>
            </div>
            <div class="stitch-dialog-footer">
                <button class="btn btn-outline" onclick="closePerspectiveDialog()">取消</button>
                <button class="btn btn-primary" onclick="applyPerspective()">套用校正</button>
            </div>
        </div>
    </div>
    
    <!-- 長圖拼接對話框 -->
    <div class="stitch-dialog" id="long-stitch-dialog">
        <div class="stitch-dialog-content" style="max-width:750px;">
            <div class="stitch-dialog-header">
                <h2>📜 長圖拼接</h2>
                <button class="history-panel-close" onclick="closeLongStitchDialog()">×</button>
            </div>
            <div class="stitch-dialog-body">
                <div style="display:grid;grid-template-columns:250px 1fr;gap:20px;">
                    <div>
                        <div class="prop-label" style="margin-bottom:8px;">添加圖片</div>
                        <div class="long-stitch-dropzone" id="long-stitch-dropzone">
                            <div style="font-size:28px;margin-bottom:6px;">📷</div>
                            <div>點擊或拖曳添加</div>
                            <div style="font-size:11px;margin-top:4px;">支援多選</div>
                        </div>
                        <input type="file" id="long-stitch-input" multiple accept="image/*" style="display:none;">
                        
                        <div style="margin-top:16px;">
                            <div class="prop-label">拼接設定</div>
                            
                            <div class="prop-row" style="margin-top:8px;">
                                <span class="prop-label">拼接方向</span>
                                <select class="prop-input" id="long-stitch-direction" style="width:100px;" onchange="updateLongStitchPreview()">
                                    <option value="vertical">⬇️ 直向</option>
                                    <option value="horizontal">➡️ 橫向</option>
                                </select>
                            </div>
                            
                            <div class="prop-row" style="margin-top:8px;">
                                <span class="prop-label">間距</span>
                                <input type="range" class="prop-range" id="long-stitch-gap" value="0" min="0" max="50" oninput="document.getElementById('long-stitch-gap-val').textContent=this.value+'px'">
                                <span id="long-stitch-gap-val">0px</span>
                            </div>
                            <div class="prop-row">
                                <span class="prop-label">背景色</span>
                                <input type="color" class="prop-input" id="long-stitch-bg" value="#ffffff" style="width:50px;height:26px;">
                            </div>
                            <div style="margin-top:10px;">
                                <label style="display:flex;align-items:center;gap:8px;cursor:pointer;font-size:12px;color:#aaa;">
                                    <input type="checkbox" id="long-stitch-auto-width" checked> 自動統一尺寸
                                </label>
                            </div>
                        </div>
                    </div>
                    
                    <div>
                        <div class="prop-label" style="margin-bottom:8px;">預覽 (可拖曳調整順序)</div>
                        <div class="long-stitch-preview" id="long-stitch-preview" style="display:flex;overflow:auto;">
                            <div style="text-align:center;color:#666;padding:30px;">尚未添加圖片</div>
                        </div>
                        <div style="margin-top:8px;display:flex;justify-content:space-between;align-items:center;">
                            <span style="font-size:11px;color:#888;" id="long-stitch-info">0 張圖片</span>
                            <button class="btn btn-outline" onclick="clearLongStitchImages()">清空全部</button>
                        </div>
                    </div>
                </div>
            </div>
            <div class="stitch-dialog-footer">
                <button class="btn btn-outline" onclick="closeLongStitchDialog()">取消</button>
                <button class="btn btn-primary" onclick="applyLongStitch()">開始拼接</button>
            </div>
        </div>
    </div>
    
</body>
</html>
